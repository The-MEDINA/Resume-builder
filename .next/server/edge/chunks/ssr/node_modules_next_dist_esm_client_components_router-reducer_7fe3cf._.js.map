{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/create-href-from-url.ts"],"sourcesContent":["export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n"],"names":["createHrefFromUrl","url","includeHash","pathname","search","hash"],"mappings":";;;AAAO,SAASA,kBACdC,GAA8C,EAC9CC,WAA2B;IAA3BA,IAAAA,gBAAAA,KAAAA,GAAAA,cAAuB;IAEvB,OAAOD,IAAIE,QAAQ,GAAGF,IAAIG,MAAM,GAAIF,CAAAA,cAAcD,IAAII,IAAI,GAAG,EAAC;AAChE","ignoreList":[0]}},
    {"offset": {"line": 14, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 20, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/create-router-cache-key.ts"],"sourcesContent":["import type { Segment } from '../../../server/app-render/types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\nexport function createRouterCacheKey(\n  segment: Segment,\n  withoutSearchParameters: boolean = false\n) {\n  // if the segment is an array, it means it's a dynamic segment\n  // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n  if (Array.isArray(segment)) {\n    return `${segment[0]}|${segment[1]}|${segment[2]}`\n  }\n\n  // Page segments might have search parameters, ie __PAGE__?foo=bar\n  // When `withoutSearchParameters` is true, we only want to return the page segment\n  if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\n    return PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n"],"names":["PAGE_SEGMENT_KEY","createRouterCacheKey","segment","withoutSearchParameters","Array","isArray","startsWith"],"mappings":";;;AACA,SAASA,gBAAgB,QAAQ,8BAA6B;;AAEvD,SAASC,qBACdC,OAAgB,EAChBC,uBAAwC;IAAxCA,IAAAA,4BAAAA,KAAAA,GAAAA,0BAAmC;IAEnC,8DAA8D;IAC9D,uGAAuG;IACvG,IAAIC,MAAMC,OAAO,CAACH,UAAU;QAC1B,OAAUA,OAAO,CAAC,EAAE,GAAC,MAAGA,OAAO,CAAC,EAAE,GAAC,MAAGA,OAAO,CAAC,EAAE;IAClD;IAEA,kEAAkE;IAClE,kFAAkF;IAClF,IAAIC,2BAA2BD,QAAQI,UAAU,yKAACN,mBAAAA,GAAmB;QACnE,+KAAOA,mBAAAA;IACT;IAEA,OAAOE;AACT","ignoreList":[0]}},
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 45, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/router-reducer-types.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../server/app-render/types'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_PREFETCH = 'prefetch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  previousTree,\n  serverResponse,\n}: {\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\nexport type RouterNavigate = (\n  href: string,\n  navigateType: 'push' | 'replace',\n  shouldScroll: boolean\n) => void\n\nexport interface Mutable {\n  mpaNavigation?: boolean\n  patchedTree?: FlightRouterState\n  canonicalUrl?: string\n  scrollableSegments?: FlightSegmentPath[]\n  pendingPush?: boolean\n  cache?: CacheNode\n  prefetchCache?: AppRouterState['prefetchCache']\n  hashFragment?: string\n  shouldScroll?: boolean\n  preserveCustomHistoryState?: boolean\n  onlyHashChange?: boolean\n}\n\nexport interface ServerActionMutable extends Mutable {\n  inFlightServerAction?: Promise<any> | null\n}\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n  origin: Location['origin']\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n  origin: Location['origin']\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n  allowAliasing: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  tree: FlightRouterState | undefined\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n * - Only triggered in layout-router.\n * - Creates a new cache and router state with the Flight data applied.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  serverResponse: FetchServerResponseResult\n  previousTree: FlightRouterState\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n * - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n  TEMPORARY = 'temporary',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\nexport interface PrefetchAction {\n  type: typeof ACTION_PREFETCH\n  url: URL\n  kind: PrefetchKind\n}\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\nexport type PrefetchCacheEntry = {\n  treeAtTimeOfPrefetch: FlightRouterState\n  data: Promise<FetchServerResponseResult>\n  kind: PrefetchKind\n  prefetchTime: number\n  staleTime: number\n  lastUsedTime: number | null\n  key: string\n  status: PrefetchCacheEntryStatus\n  url: URL\n}\n\nexport enum PrefetchCacheEntryStatus {\n  fresh = 'fresh',\n  reusable = 'reusable',\n  expired = 'expired',\n  stale = 'stale',\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   * Prefetched data is stored separately in `prefetchCache`, that is applied during ACTION_NAVIGATE.\n   */\n  cache: CacheNode\n  /**\n   * Cache that holds prefetched Flight responses keyed by url.\n   */\n  prefetchCache: Map<string, PrefetchCacheEntry>\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState = Promise<AppRouterState> | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | PrefetchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n"],"names":["ACTION_REFRESH","ACTION_NAVIGATE","ACTION_RESTORE","ACTION_SERVER_PATCH","ACTION_PREFETCH","ACTION_HMR_REFRESH","ACTION_SERVER_ACTION","PrefetchKind","PrefetchCacheEntryStatus"],"mappings":";;;;;;;;;;;AAOO,MAAMA,iBAAiB,UAAS;AAChC,MAAMC,kBAAkB,WAAU;AAClC,MAAMC,iBAAiB,UAAS;AAChC,MAAMC,sBAAsB,eAAc;AAC1C,MAAMC,kBAAkB,WAAU;AAClC,MAAMC,qBAAqB,cAAa;AACxC,MAAMC,uBAAuB,gBAAe;AAyI5C,IAAKC,eAAAA,WAAAA,GAAAA,SAAAA,YAAAA;;;;WAAAA;MAIX;AA4DM,IAAKC,2BAAAA,WAAAA,GAAAA,SAAAA,wBAAAA;;;;;WAAAA;MAKX","ignoreList":[0]}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  CacheNodeSeedData,\n} from '../../../server/app-render/types'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport {\n  PrefetchCacheEntryStatus,\n  type PrefetchCacheEntry,\n} from './router-reducer-types'\n\nexport function fillLazyItemsTillLeafWithHead(\n  newCache: CacheNode,\n  existingCache: CacheNode | undefined,\n  routerState: FlightRouterState,\n  cacheNodeSeedData: CacheNodeSeedData | null,\n  head: React.ReactNode,\n  prefetchEntry?: PrefetchCacheEntry\n): void {\n  const isLastSegment = Object.keys(routerState[1]).length === 0\n  if (isLastSegment) {\n    newCache.head = head\n    return\n  }\n  // Remove segment that we got data for so that it is filled in during rendering of rsc.\n  for (const key in routerState[1]) {\n    const parallelRouteState = routerState[1][key]\n    const segmentForParallelRoute = parallelRouteState[0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n\n    // TODO: We should traverse the cacheNodeSeedData tree instead of the router\n    // state tree. Ideally, they would always be the same shape, but because of\n    // the loading.js pattern, cacheNodeSeedData sometimes only represents a\n    // partial tree. That's why this node is sometimes null. Once PPR lands,\n    // loading.js will no longer have special behavior and we can traverse the\n    // data tree instead.\n    //\n    // We should also consider merging the router state tree and the data tree\n    // in the response format, so that we don't have to send the keys twice.\n    // Then the client can convert them into separate representations.\n    const parallelSeedData =\n      cacheNodeSeedData !== null && cacheNodeSeedData[2][key] !== undefined\n        ? cacheNodeSeedData[2][key]\n        : null\n    if (existingCache) {\n      const existingParallelRoutesCacheNode =\n        existingCache.parallelRoutes.get(key)\n      if (existingParallelRoutesCacheNode) {\n        const hasReusablePrefetch =\n          prefetchEntry?.kind === 'auto' &&\n          prefetchEntry.status === PrefetchCacheEntryStatus.reusable\n\n        let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n        const existingCacheNode = parallelRouteCacheNode.get(cacheKey)\n        let newCacheNode: CacheNode\n        if (parallelSeedData !== null) {\n          // New data was sent from the server.\n          const seedNode = parallelSeedData[1]\n          const loading = parallelSeedData[3]\n          newCacheNode = {\n            lazyData: null,\n            rsc: seedNode,\n            // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n            // this path during a navigation, but until PPR is fully implemented\n            // yet it's possible the existing node does have a non-null\n            // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n            // old behavior — no PPR value.\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            loading,\n            parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n          }\n        } else if (hasReusablePrefetch && existingCacheNode) {\n          // No new data was sent from the server, but the existing cache node\n          // was prefetched, so we should reuse that.\n          newCacheNode = {\n            lazyData: existingCacheNode.lazyData,\n            rsc: existingCacheNode.rsc,\n            // This is a PPR-only field. Unlike the previous branch, since we're\n            // just cloning the existing cache node, we might as well keep the\n            // PPR value, if it exists.\n            prefetchRsc: existingCacheNode.prefetchRsc,\n            head: existingCacheNode.head,\n            prefetchHead: existingCacheNode.prefetchHead,\n            parallelRoutes: new Map(existingCacheNode.parallelRoutes),\n            loading: existingCacheNode.loading,\n          } as CacheNode\n        } else {\n          // No data available for this node. This will trigger a lazy fetch\n          // during render.\n          newCacheNode = {\n            lazyData: null,\n            rsc: null,\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n            loading: null,\n          }\n        }\n\n        // Overrides the cache key with the new cache node.\n        parallelRouteCacheNode.set(cacheKey, newCacheNode)\n        // Traverse deeper to apply the head / fill lazy items till the head.\n        fillLazyItemsTillLeafWithHead(\n          newCacheNode,\n          existingCacheNode,\n          parallelRouteState,\n          parallelSeedData ? parallelSeedData : null,\n          head,\n          prefetchEntry\n        )\n\n        newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n        continue\n      }\n    }\n\n    let newCacheNode: CacheNode\n    if (parallelSeedData !== null) {\n      // New data was sent from the server.\n      const seedNode = parallelSeedData[1]\n      const loading = parallelSeedData[3]\n      newCacheNode = {\n        lazyData: null,\n        rsc: seedNode,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading,\n      }\n    } else {\n      // No data available for this node. This will trigger a lazy fetch\n      // during render.\n      newCacheNode = {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n      }\n    }\n\n    const existingParallelRoutes = newCache.parallelRoutes.get(key)\n    if (existingParallelRoutes) {\n      existingParallelRoutes.set(cacheKey, newCacheNode)\n    } else {\n      newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]))\n    }\n\n    fillLazyItemsTillLeafWithHead(\n      newCacheNode,\n      undefined,\n      parallelRouteState,\n      parallelSeedData,\n      head,\n      prefetchEntry\n    )\n  }\n}\n"],"names":["createRouterCacheKey","PrefetchCacheEntryStatus","fillLazyItemsTillLeafWithHead","newCache","existingCache","routerState","cacheNodeSeedData","head","prefetchEntry","isLastSegment","Object","keys","length","key","parallelRouteState","segmentForParallelRoute","cacheKey","parallelSeedData","undefined","existingParallelRoutesCacheNode","parallelRoutes","get","hasReusablePrefetch","kind","status","reusable","parallelRouteCacheNode","Map","existingCacheNode","newCacheNode","seedNode","loading","lazyData","rsc","prefetchRsc","prefetchHead","set","existingParallelRoutes"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 213, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 219, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/compute-changed-path.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  Segment,\n} from '../../../server/app-render/types'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../../server/lib/interception-routes'\nimport type { Params } from '../../../server/request/params'\nimport {\n  isGroupSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\n\nconst removeLeadingSlash = (segment: string): string => {\n  return segment[0] === '/' ? segment.slice(1) : segment\n}\n\nconst segmentToPathname = (segment: Segment): string => {\n  if (typeof segment === 'string') {\n    // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n    // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n    if (segment === 'children') return ''\n\n    return segment\n  }\n\n  return segment[1]\n}\n\nfunction normalizeSegments(segments: string[]): string {\n  return (\n    segments.reduce((acc, segment) => {\n      segment = removeLeadingSlash(segment)\n      if (segment === '' || isGroupSegment(segment)) {\n        return acc\n      }\n\n      return `${acc}/${segment}`\n    }, '') || '/'\n  )\n}\n\nexport function extractPathFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): string | undefined {\n  const segment = Array.isArray(flightRouterState[0])\n    ? flightRouterState[0][1]\n    : flightRouterState[0]\n\n  if (\n    segment === DEFAULT_SEGMENT_KEY ||\n    INTERCEPTION_ROUTE_MARKERS.some((m) => segment.startsWith(m))\n  )\n    return undefined\n\n  if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''\n\n  const segments = [segmentToPathname(segment)]\n  const parallelRoutes = flightRouterState[1] ?? {}\n\n  const childrenPath = parallelRoutes.children\n    ? extractPathFromFlightRouterState(parallelRoutes.children)\n    : undefined\n\n  if (childrenPath !== undefined) {\n    segments.push(childrenPath)\n  } else {\n    for (const [key, value] of Object.entries(parallelRoutes)) {\n      if (key === 'children') continue\n\n      const childPath = extractPathFromFlightRouterState(value)\n\n      if (childPath !== undefined) {\n        segments.push(childPath)\n      }\n    }\n  }\n\n  return normalizeSegments(segments)\n}\n\nfunction computeChangedPathImpl(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const [segmentA, parallelRoutesA] = treeA\n  const [segmentB, parallelRoutesB] = treeB\n\n  const normalizedSegmentA = segmentToPathname(segmentA)\n  const normalizedSegmentB = segmentToPathname(segmentB)\n\n  if (\n    INTERCEPTION_ROUTE_MARKERS.some(\n      (m) =>\n        normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)\n    )\n  ) {\n    return ''\n  }\n\n  if (!matchSegment(segmentA, segmentB)) {\n    // once we find where the tree changed, we compute the rest of the path by traversing the tree\n    return extractPathFromFlightRouterState(treeB) ?? ''\n  }\n\n  for (const parallelRouterKey in parallelRoutesA) {\n    if (parallelRoutesB[parallelRouterKey]) {\n      const changedPath = computeChangedPathImpl(\n        parallelRoutesA[parallelRouterKey],\n        parallelRoutesB[parallelRouterKey]\n      )\n      if (changedPath !== null) {\n        return `${segmentToPathname(segmentB)}/${changedPath}`\n      }\n    }\n  }\n\n  return null\n}\n\nexport function computeChangedPath(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const changedPath = computeChangedPathImpl(treeA, treeB)\n\n  if (changedPath == null || changedPath === '/') {\n    return changedPath\n  }\n\n  // lightweight normalization to remove route groups\n  return normalizeSegments(changedPath.split('/'))\n}\n\n/**\n * Recursively extracts dynamic parameters from FlightRouterState.\n */\nexport function getSelectedParams(\n  currentTree: FlightRouterState,\n  params: Params = {}\n): Params {\n  const parallelRoutes = currentTree[1]\n\n  for (const parallelRoute of Object.values(parallelRoutes)) {\n    const segment = parallelRoute[0]\n    const isDynamicParameter = Array.isArray(segment)\n    const segmentValue = isDynamicParameter ? segment[1] : segment\n    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue\n\n    // Ensure catchAll and optional catchall are turned into an array\n    const isCatchAll =\n      isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc')\n\n    if (isCatchAll) {\n      params[segment[0]] = segment[1].split('/')\n    } else if (isDynamicParameter) {\n      params[segment[0]] = segment[1]\n    }\n\n    params = getSelectedParams(parallelRoute, params)\n  }\n\n  return params\n}\n"],"names":["INTERCEPTION_ROUTE_MARKERS","isGroupSegment","DEFAULT_SEGMENT_KEY","PAGE_SEGMENT_KEY","matchSegment","removeLeadingSlash","segment","slice","segmentToPathname","normalizeSegments","segments","reduce","acc","extractPathFromFlightRouterState","flightRouterState","Array","isArray","some","m","startsWith","undefined","parallelRoutes","childrenPath","children","push","key","value","Object","entries","childPath","computeChangedPathImpl","treeA","treeB","segmentA","parallelRoutesA","segmentB","parallelRoutesB","normalizedSegmentA","normalizedSegmentB","parallelRouterKey","changedPath","computeChangedPath","split","getSelectedParams","currentTree","params","parallelRoute","values","isDynamicParameter","segmentValue","isCatchAll"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 324, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 329, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/esm/client/components/router-reducer/fetch-server-response.js/proxy.cjs"],"sourcesContent":["const { createClientModuleProxy } = require(\"react-server-dom-turbopack/server.edge\");\n\n__turbopack_export_namespace__(createClientModuleProxy(\"[project]/node_modules/next/dist/esm/client/components/router-reducer/fetch-server-response.js <module evaluation>\"));\n"],"names":[],"mappings":"AAAA,MAAM,EAAE,uBAAuB,EAAE;AAEjC,+BAA+B,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 331, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 336, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/esm/client/components/router-reducer/fetch-server-response.js/proxy.cjs"],"sourcesContent":["const { createClientModuleProxy } = require(\"react-server-dom-turbopack/server.edge\");\n\n__turbopack_export_namespace__(createClientModuleProxy(\"[project]/node_modules/next/dist/esm/client/components/router-reducer/fetch-server-response.js\"));\n"],"names":[],"mappings":"AAAA,MAAM,EAAE,uBAAuB,EAAE;AAEjC,+BAA+B,wBAAwB","ignoreList":[0]}},
    {"offset": {"line": 338, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 344, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/fetch-server-response.ts"],"sourcesContent":["'use client'\n\n// @ts-ignore\n// eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromReadableStream } from 'react-server-dom-webpack/client'\nconst { createFromReadableStream } = (\n  !!process.env.NEXT_RUNTIME\n    ? // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client.edge')\n    : // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client')\n) as typeof import('react-server-dom-webpack/client')\n\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../server/app-render/types'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_URL,\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n} from '../app-router-headers'\nimport { callServer } from '../../app-call-server'\nimport { findSourceMapURL } from '../../app-find-source-map-url'\nimport { PrefetchKind } from './router-reducer-types'\nimport { hexHash } from '../../../shared/lib/hash'\nimport {\n  normalizeFlightData,\n  type NormalizedFlightData,\n} from '../../flight-data-helpers'\nimport { getAppBuildId } from '../../app-build-id'\n\nexport interface FetchServerResponseOptions {\n  readonly flightRouterState: FlightRouterState\n  readonly nextUrl: string | null\n  readonly prefetchKind?: PrefetchKind\n  readonly isHmrRefresh?: boolean\n}\n\nexport type FetchServerResponseResult = {\n  flightData: NormalizedFlightData[] | string\n  canonicalUrl: URL | undefined\n  couldBeIntercepted: boolean\n  prerendered: boolean\n  postponed: boolean\n  staleTime: number\n}\n\nexport type RequestHeaders = {\n  [RSC_HEADER]?: '1'\n  [NEXT_ROUTER_STATE_TREE_HEADER]?: string\n  [NEXT_URL]?: string\n  [NEXT_ROUTER_PREFETCH_HEADER]?: '1'\n  [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string\n  'x-deployment-id'?: string\n  [NEXT_HMR_REFRESH_HEADER]?: '1'\n  // A header that is only added in test mode to assert on fetch priority\n  'Next-Test-Fetch-Priority'?: RequestInit['priority']\n}\n\nexport function urlToUrlWithoutFlightMarker(url: string): URL {\n  const urlWithoutFlightParameters = new URL(url, location.origin)\n  urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY)\n  if (process.env.NODE_ENV === 'production') {\n    if (\n      process.env.__NEXT_CONFIG_OUTPUT === 'export' &&\n      urlWithoutFlightParameters.pathname.endsWith('.txt')\n    ) {\n      const { pathname } = urlWithoutFlightParameters\n      const length = pathname.endsWith('/index.txt') ? 10 : 4\n      // Slice off `/index.txt` or `.txt` from the end of the pathname\n      urlWithoutFlightParameters.pathname = pathname.slice(0, -length)\n    }\n  }\n  return urlWithoutFlightParameters\n}\n\nfunction doMpaNavigation(url: string): FetchServerResponseResult {\n  return {\n    flightData: urlToUrlWithoutFlightMarker(url).toString(),\n    canonicalUrl: undefined,\n    couldBeIntercepted: false,\n    prerendered: false,\n    postponed: false,\n    staleTime: -1,\n  }\n}\n\n/**\n * Fetch the flight data for the provided url. Takes in the current router state\n * to decide what to render server-side.\n */\nexport async function fetchServerResponse(\n  url: URL,\n  options: FetchServerResponseOptions\n): Promise<FetchServerResponseResult> {\n  const { flightRouterState, nextUrl, prefetchKind } = options\n\n  const headers: RequestHeaders = {\n    // Enable flight response\n    [RSC_HEADER]: '1',\n    // Provide the current router state\n    [NEXT_ROUTER_STATE_TREE_HEADER]: encodeURIComponent(\n      JSON.stringify(flightRouterState)\n    ),\n  }\n\n  /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */\n  if (prefetchKind === PrefetchKind.AUTO) {\n    headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n  }\n\n  if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n    headers[NEXT_HMR_REFRESH_HEADER] = '1'\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  try {\n    // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n    // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n    // Otherwise, all other prefetches are sent with a \"low\" priority.\n    // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n    const fetchPriority = prefetchKind\n      ? prefetchKind === PrefetchKind.TEMPORARY\n        ? 'high'\n        : 'low'\n      : 'auto'\n\n    const res = await createFetch(url, headers, fetchPriority)\n\n    const responseUrl = urlToUrlWithoutFlightMarker(res.url)\n    const canonicalUrl = res.redirected ? responseUrl : undefined\n\n    const contentType = res.headers.get('content-type') || ''\n    const interception = !!res.headers.get('vary')?.includes(NEXT_URL)\n    const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)\n    const staleTimeHeader = res.headers.get(NEXT_ROUTER_STALE_TIME_HEADER)\n    const staleTime =\n      staleTimeHeader !== null ? parseInt(staleTimeHeader, 10) : -1\n    let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        if (!isFlightResponse) {\n          isFlightResponse = contentType.startsWith('text/plain')\n        }\n      }\n    }\n\n    // If fetch returns something different than flight response handle it like a mpa navigation\n    // If the fetch was not 200, we also handle it like a mpa navigation\n    if (!isFlightResponse || !res.ok || !res.body) {\n      // in case the original URL came with a hash, preserve it before redirecting to the new URL\n      if (url.hash) {\n        responseUrl.hash = url.hash\n      }\n\n      return doMpaNavigation(responseUrl.toString())\n    }\n\n    // We may navigate to a page that requires a different Webpack runtime.\n    // In prod, every page will have the same Webpack runtime.\n    // In dev, the Webpack runtime is minimal for each page.\n    // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n    if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n      await require('../react-dev-overlay/app/hot-reloader-client').waitForWebpackRuntimeHotUpdate()\n    }\n\n    // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n    const flightStream = postponed\n      ? createUnclosingPrefetchStream(res.body)\n      : res.body\n    const response = await (createFromNextReadableStream(\n      flightStream\n    ) as Promise<NavigationFlightResponse>)\n\n    if (getAppBuildId() !== response.b) {\n      return doMpaNavigation(res.url)\n    }\n\n    return {\n      flightData: normalizeFlightData(response.f),\n      canonicalUrl: canonicalUrl,\n      couldBeIntercepted: interception,\n      prerendered: response.S,\n      postponed,\n      staleTime,\n    }\n  } catch (err) {\n    console.error(\n      `Failed to fetch RSC payload for ${url}. Falling back to browser navigation.`,\n      err\n    )\n    // If fetch fails handle it like a mpa navigation\n    // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n    // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n    return {\n      flightData: url.toString(),\n      canonicalUrl: undefined,\n      couldBeIntercepted: false,\n      prerendered: false,\n      postponed: false,\n      staleTime: -1,\n    }\n  }\n}\n\nexport function createFetch(\n  url: URL,\n  headers: RequestHeaders,\n  fetchPriority: 'auto' | 'high' | 'low' | null\n) {\n  const fetchUrl = new URL(url)\n\n  if (process.env.NODE_ENV === 'production') {\n    if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n      if (fetchUrl.pathname.endsWith('/')) {\n        fetchUrl.pathname += 'index.txt'\n      } else {\n        fetchUrl.pathname += '.txt'\n      }\n    }\n  }\n\n  // This is used to cache bust CDNs that don't support custom headers. The\n  // result is stored in a search param.\n  // TODO: Given that we have to use a search param anyway, we might as well\n  // _only_ use a search param and not bother with the custom headers.\n  // Add unique cache query to avoid caching conflicts on CDN which don't respect the Vary header\n  const uniqueCacheQuery = hexHash(\n    [\n      headers[NEXT_ROUTER_PREFETCH_HEADER] || '0',\n      headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] || '0',\n      headers[NEXT_ROUTER_STATE_TREE_HEADER],\n      headers[NEXT_URL],\n    ].join(',')\n  )\n\n  fetchUrl.searchParams.set(NEXT_RSC_UNION_QUERY, uniqueCacheQuery)\n\n  if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n    headers['Next-Test-Fetch-Priority'] = fetchPriority\n  }\n\n  if (process.env.NEXT_DEPLOYMENT_ID) {\n    headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID\n  }\n\n  return fetch(fetchUrl, {\n    // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n    credentials: 'same-origin',\n    headers,\n    priority: fetchPriority || undefined,\n  })\n}\n\nexport function createFromNextReadableStream(\n  flightStream: ReadableStream<Uint8Array>\n): Promise<unknown> {\n  return createFromReadableStream(flightStream, {\n    callServer,\n    findSourceMapURL,\n  })\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n"],"names":["createFromReadableStream","process","env","NEXT_RUNTIME","require","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_RSC_UNION_QUERY","NEXT_URL","RSC_HEADER","RSC_CONTENT_TYPE_HEADER","NEXT_HMR_REFRESH_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","callServer","findSourceMapURL","PrefetchKind","hexHash","normalizeFlightData","getAppBuildId","urlToUrlWithoutFlightMarker","url","urlWithoutFlightParameters","URL","location","origin","searchParams","delete","NODE_ENV","__NEXT_CONFIG_OUTPUT","pathname","endsWith","length","slice","doMpaNavigation","flightData","toString","canonicalUrl","undefined","couldBeIntercepted","prerendered","postponed","staleTime","fetchServerResponse","options","flightRouterState","nextUrl","prefetchKind","headers","encodeURIComponent","JSON","stringify","AUTO","isHmrRefresh","res","fetchPriority","TEMPORARY","createFetch","responseUrl","redirected","contentType","get","interception","includes","staleTimeHeader","parseInt","isFlightResponse","startsWith","ok","body","hash","TURBOPACK","waitForWebpackRuntimeHotUpdate","flightStream","createUnclosingPrefetchStream","response","createFromNextReadableStream","b","f","S","err","console","error","fetchUrl","uniqueCacheQuery","join","set","__NEXT_TEST_MODE","NEXT_DEPLOYMENT_ID","fetch","credentials","priority","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","value","read","enqueue"],"mappings":"","ignoreList":[0]}},
    {"offset": {"line": 348, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 354, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/prefetch-reducer.ts"],"sourcesContent":["import type {\n  PrefetchAction,\n  ReducerState,\n  ReadonlyReducerState,\n} from '../router-reducer-types'\nimport { PromiseQueue } from '../../promise-queue'\nimport {\n  getOrCreatePrefetchCacheEntry,\n  prunePrefetchCache,\n} from '../prefetch-cache-utils'\n\nexport const prefetchQueue = new PromiseQueue(5)\n\nexport const prefetchReducer =\n  process.env.__NEXT_PPR && process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? identityReducerWhenSegmentCacheIsEnabled\n    : prefetchReducerImpl\n\nfunction identityReducerWhenSegmentCacheIsEnabled<T>(state: T): T {\n  // Unlike the old implementation, the Segment Cache doesn't store its data in\n  // the router reducer state.\n  //\n  // This shouldn't be reachable because we wrap the prefetch API in a check,\n  // too, which prevents the action from being dispatched. But it's here for\n  // clarity + code elimination.\n  return state\n}\n\nfunction prefetchReducerImpl(\n  state: ReadonlyReducerState,\n  action: PrefetchAction\n): ReducerState {\n  // let's prune the prefetch cache before we do anything else\n  prunePrefetchCache(state.prefetchCache)\n\n  const { url } = action\n\n  getOrCreatePrefetchCacheEntry({\n    url,\n    nextUrl: state.nextUrl,\n    prefetchCache: state.prefetchCache,\n    kind: action.kind,\n    tree: state.tree,\n    allowAliasing: true,\n  })\n\n  return state\n}\n"],"names":["PromiseQueue","getOrCreatePrefetchCacheEntry","prunePrefetchCache","prefetchQueue","prefetchReducer","process","env","__NEXT_PPR","__NEXT_CLIENT_SEGMENT_CACHE","identityReducerWhenSegmentCacheIsEnabled","prefetchReducerImpl","state","action","prefetchCache","url","nextUrl","kind","tree","allowAliasing"],"mappings":";;;;AAKA,SAASA,YAAY,QAAQ,sBAAqB;AAClD,SACEC,6BAA6B,EAC7BC,kBAAkB,QACb,0BAAyB;;;AAEzB,MAAMC,gBAAgB,4LAAIH,eAAAA,CAAa,GAAE;AAEzC,MAAMI,kBACXC,QAAQC,GAAG,CAACC,UAAU,IAAIF,QAAQC,GAAG,CAACE,2BAA2B,GAC7DC,SACAC,oBAAmB;AAEzB,SAASD,yCAA4CE,KAAQ;IAC3D,6EAA6E;IAC7E,4BAA4B;IAC5B,EAAE;IACF,2EAA2E;IAC3E,0EAA0E;IAC1E,8BAA8B;IAC9B,OAAOA;AACT;AAEA,SAASD,oBACPC,KAA2B,EAC3BC,MAAsB;IAEtB,4DAA4D;+NAC5DV,qBAAAA,EAAmBS,MAAME,aAAa;IAEtC,MAAM,EAAEC,GAAG,EAAE,GAAGF;+NAEhBX,gCAAAA,EAA8B;QAC5Ba;QACAC,SAASJ,MAAMI,OAAO;QACtBF,eAAeF,MAAME,aAAa;QAClCG,MAAMJ,OAAOI,IAAI;QACjBC,MAAMN,MAAMM,IAAI;QAChBC,eAAe;IACjB;IAEA,OAAOP;AACT","ignoreList":[0]}},
    {"offset": {"line": 387, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 393, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/prefetch-cache-utils.ts"],"sourcesContent":["import {\n  fetchServerResponse,\n  type FetchServerResponseResult,\n} from './fetch-server-response'\nimport {\n  PrefetchCacheEntryStatus,\n  type PrefetchCacheEntry,\n  PrefetchKind,\n  type ReadonlyReducerState,\n} from './router-reducer-types'\nimport { prefetchQueue } from './reducers/prefetch-reducer'\n\nconst INTERCEPTION_CACHE_KEY_MARKER = '%'\n\nexport type AliasedPrefetchCacheEntry = PrefetchCacheEntry & {\n  /** This is a special property that indicates a prefetch entry associated with a different URL\n   * was returned rather than the requested URL. This signals to the router that it should only\n   * apply the part that doesn't depend on searchParams (specifically the loading state).\n   */\n  aliased?: boolean\n}\n\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n * @return The generated prefetch cache key.\n */\nfunction createPrefetchCacheKeyImpl(\n  url: URL,\n  includeSearchParams: boolean,\n  prefix?: string | null\n) {\n  // Initially we only use the pathname as the cache key. We don't want to include\n  // search params so that multiple URLs with the same search parameter can re-use\n  // loading states.\n  let pathnameFromUrl = url.pathname\n\n  // RSC responses can differ based on search params, specifically in the case where we aren't\n  // returning a partial response (ie with `PrefetchKind.AUTO`).\n  // In the auto case, since loading.js & layout.js won't have access to search params,\n  // we can safely re-use that cache entry. But for full prefetches, we should not\n  // re-use the cache entry as the response may differ.\n  if (includeSearchParams) {\n    // if we have a full prefetch, we can include the search param in the key,\n    // as we'll be getting back a full response. The server might have read the search\n    // params when generating the full response.\n    pathnameFromUrl += url.search\n  }\n\n  if (prefix) {\n    return `${prefix}${INTERCEPTION_CACHE_KEY_MARKER}${pathnameFromUrl}`\n  }\n\n  return pathnameFromUrl\n}\n\nfunction createPrefetchCacheKey(\n  url: URL,\n  kind: PrefetchKind | undefined,\n  nextUrl?: string | null\n) {\n  return createPrefetchCacheKeyImpl(url, kind === PrefetchKind.FULL, nextUrl)\n}\n\nfunction getExistingCacheEntry(\n  url: URL,\n  kind: PrefetchKind = PrefetchKind.TEMPORARY,\n  nextUrl: string | null,\n  prefetchCache: Map<string, PrefetchCacheEntry>,\n  allowAliasing: boolean\n): AliasedPrefetchCacheEntry | undefined {\n  // We first check if there's a more specific interception route prefetch entry\n  // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n  // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n  for (const maybeNextUrl of [nextUrl, null]) {\n    const cacheKeyWithParams = createPrefetchCacheKeyImpl(\n      url,\n      true,\n      maybeNextUrl\n    )\n    const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(\n      url,\n      false,\n      maybeNextUrl\n    )\n\n    // First, we check if we have a cache entry that exactly matches the URL\n    const cacheKeyToUse = url.search\n      ? cacheKeyWithParams\n      : cacheKeyWithoutParams\n\n    const existingEntry = prefetchCache.get(cacheKeyToUse)\n    if (existingEntry && allowAliasing) {\n      // We know we're returning an aliased entry when the pathname matches but the search params don't,\n      const isAliased =\n        existingEntry.url.pathname === url.pathname &&\n        existingEntry.url.search !== url.search\n\n      if (isAliased) {\n        return {\n          ...existingEntry,\n          aliased: true,\n        }\n      }\n\n      return existingEntry\n    }\n\n    // If the request contains search params, and we're not doing a full prefetch, we can return the\n    // param-less entry if it exists.\n    // This is technically covered by the check at the bottom of this function, which iterates over cache entries,\n    // but lets us arrive there quicker in the param-full case.\n    const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams)\n    if (\n      process.env.NODE_ENV !== 'development' &&\n      allowAliasing &&\n      url.search &&\n      kind !== PrefetchKind.FULL &&\n      entryWithoutParams &&\n      // We shouldn't return the aliased entry if it was relocated to a new cache key.\n      // Since it's rewritten, it could respond with a completely different loading state.\n      !entryWithoutParams.key.includes(INTERCEPTION_CACHE_KEY_MARKER)\n    ) {\n      return { ...entryWithoutParams, aliased: true }\n    }\n  }\n\n  // If we've gotten to this point, we didn't find a specific cache entry that matched\n  // the request URL.\n  // We attempt a partial match by checking if there's a cache entry with the same pathname.\n  // Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it \"aliased\".\n  // This will signal to the router that it should only apply the loading state on the prefetched data.\n  if (\n    process.env.NODE_ENV !== 'development' &&\n    kind !== PrefetchKind.FULL &&\n    allowAliasing\n  ) {\n    for (const cacheEntry of prefetchCache.values()) {\n      if (\n        cacheEntry.url.pathname === url.pathname &&\n        // We shouldn't return the aliased entry if it was relocated to a new cache key.\n        // Since it's rewritten, it could respond with a completely different loading state.\n        !cacheEntry.key.includes(INTERCEPTION_CACHE_KEY_MARKER)\n      ) {\n        return { ...cacheEntry, aliased: true }\n      }\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Returns a prefetch cache entry if one exists. Otherwise creates a new one and enqueues a fetch request\n * to retrieve the prefetch data from the server.\n */\nexport function getOrCreatePrefetchCacheEntry({\n  url,\n  nextUrl,\n  tree,\n  prefetchCache,\n  kind,\n  allowAliasing = true,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'prefetchCache' | 'tree'> & {\n  url: URL\n  kind?: PrefetchKind\n  allowAliasing: boolean\n}): AliasedPrefetchCacheEntry {\n  const existingCacheEntry = getExistingCacheEntry(\n    url,\n    kind,\n    nextUrl,\n    prefetchCache,\n    allowAliasing\n  )\n\n  if (existingCacheEntry) {\n    // Grab the latest status of the cache entry and update it\n    existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry)\n\n    // when `kind` is provided, an explicit prefetch was requested.\n    // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n    const switchedToFullPrefetch =\n      existingCacheEntry.kind !== PrefetchKind.FULL &&\n      kind === PrefetchKind.FULL\n\n    if (switchedToFullPrefetch) {\n      // If we switched to a full prefetch, validate that the existing cache entry contained partial data.\n      // It's possible that the cache entry was seeded with full data but has a cache type of \"auto\" (ie when cache entries\n      // are seeded but without a prefetch intent)\n      existingCacheEntry.data.then((prefetchResponse) => {\n        const isFullPrefetch =\n          Array.isArray(prefetchResponse.flightData) &&\n          prefetchResponse.flightData.some((flightData) => {\n            // If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.\n            return flightData.isRootRender && flightData.seedData !== null\n          })\n\n        if (!isFullPrefetch) {\n          return createLazyPrefetchEntry({\n            tree,\n            url,\n            nextUrl,\n            prefetchCache,\n            // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n            // rather than assuming the same intent as the previous entry, to be consistent with how we\n            // lazily create prefetch entries when intent is left unspecified.\n            kind: kind ?? PrefetchKind.TEMPORARY,\n          })\n        }\n      })\n    }\n\n    // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n    // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n    if (kind && existingCacheEntry.kind === PrefetchKind.TEMPORARY) {\n      existingCacheEntry.kind = kind\n    }\n\n    // We've determined that the existing entry we found is still valid, so we return it.\n    return existingCacheEntry\n  }\n\n  // If we didn't return an entry, create a new one.\n  return createLazyPrefetchEntry({\n    tree,\n    url,\n    nextUrl,\n    prefetchCache,\n    kind: kind || PrefetchKind.TEMPORARY,\n  })\n}\n\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n */\nfunction prefixExistingPrefetchCacheEntry({\n  url,\n  nextUrl,\n  prefetchCache,\n  existingCacheKey,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'prefetchCache'> & {\n  url: URL\n  existingCacheKey: string\n}) {\n  const existingCacheEntry = prefetchCache.get(existingCacheKey)\n  if (!existingCacheEntry) {\n    // no-op -- there wasn't an entry to move\n    return\n  }\n\n  const newCacheKey = createPrefetchCacheKey(\n    url,\n    existingCacheEntry.kind,\n    nextUrl\n  )\n  prefetchCache.set(newCacheKey, { ...existingCacheEntry, key: newCacheKey })\n  prefetchCache.delete(existingCacheKey)\n\n  return newCacheKey\n}\n\n/**\n * Use to seed the prefetch cache with data that has already been fetched.\n */\nexport function createSeededPrefetchCacheEntry({\n  nextUrl,\n  tree,\n  prefetchCache,\n  url,\n  data,\n  kind,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'tree' | 'prefetchCache'> & {\n  url: URL\n  data: FetchServerResponseResult\n  kind: PrefetchKind\n}) {\n  // The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the\n  // prefetch cache so that we can skip an extra prefetch request later, since we already have the data.\n  // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n  const prefetchCacheKey = data.couldBeIntercepted\n    ? createPrefetchCacheKey(url, kind, nextUrl)\n    : createPrefetchCacheKey(url, kind)\n\n  const prefetchEntry = {\n    treeAtTimeOfPrefetch: tree,\n    data: Promise.resolve(data),\n    kind,\n    prefetchTime: Date.now(),\n    lastUsedTime: Date.now(),\n    staleTime: -1,\n    key: prefetchCacheKey,\n    status: PrefetchCacheEntryStatus.fresh,\n    url,\n  } satisfies PrefetchCacheEntry\n\n  prefetchCache.set(prefetchCacheKey, prefetchEntry)\n\n  return prefetchEntry\n}\n\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */\nfunction createLazyPrefetchEntry({\n  url,\n  kind,\n  tree,\n  nextUrl,\n  prefetchCache,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'tree' | 'prefetchCache'> & {\n  url: URL\n  kind: PrefetchKind\n}): PrefetchCacheEntry {\n  const prefetchCacheKey = createPrefetchCacheKey(url, kind)\n\n  // initiates the fetch request for the prefetch and attaches a listener\n  // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n  const data = prefetchQueue.enqueue(() =>\n    fetchServerResponse(url, {\n      flightRouterState: tree,\n      nextUrl,\n      prefetchKind: kind,\n    }).then((prefetchResponse) => {\n      // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n      // to avoid drift between this cache key prefixing logic\n      // (which is currently directly influenced by the server response)\n      let newCacheKey\n\n      if (prefetchResponse.couldBeIntercepted) {\n        // Determine if we need to prefix the cache key with the nextUrl\n        newCacheKey = prefixExistingPrefetchCacheEntry({\n          url,\n          existingCacheKey: prefetchCacheKey,\n          nextUrl,\n          prefetchCache,\n        })\n      }\n\n      // If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.\n      // This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`\n      // staleTime.\n      if (prefetchResponse.prerendered) {\n        const existingCacheEntry = prefetchCache.get(\n          // if we prefixed the cache key due to route interception, we want to use the new key. Otherwise we use the original key\n          newCacheKey ?? prefetchCacheKey\n        )\n        if (existingCacheEntry) {\n          existingCacheEntry.kind = PrefetchKind.FULL\n          if (prefetchResponse.staleTime !== -1) {\n            // This is the stale time that was collected by the server during\n            // static generation. Use this in place of the default stale time.\n            existingCacheEntry.staleTime = prefetchResponse.staleTime\n          }\n        }\n      }\n\n      return prefetchResponse\n    })\n  )\n\n  const prefetchEntry = {\n    treeAtTimeOfPrefetch: tree,\n    data,\n    kind,\n    prefetchTime: Date.now(),\n    lastUsedTime: null,\n    staleTime: -1,\n    key: prefetchCacheKey,\n    status: PrefetchCacheEntryStatus.fresh,\n    url,\n  }\n\n  prefetchCache.set(prefetchCacheKey, prefetchEntry)\n\n  return prefetchEntry\n}\n\nexport function prunePrefetchCache(\n  prefetchCache: ReadonlyReducerState['prefetchCache']\n) {\n  for (const [href, prefetchCacheEntry] of prefetchCache) {\n    if (\n      getPrefetchEntryCacheStatus(prefetchCacheEntry) ===\n      PrefetchCacheEntryStatus.expired\n    ) {\n      prefetchCache.delete(href)\n    }\n  }\n}\n\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nconst DYNAMIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n\nconst STATIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME) * 1000\n\nfunction getPrefetchEntryCacheStatus({\n  kind,\n  prefetchTime,\n  lastUsedTime,\n  staleTime,\n}: PrefetchCacheEntry): PrefetchCacheEntryStatus {\n  if (staleTime !== -1) {\n    // `staleTime` is the value sent by the server during static generation.\n    // When this is available, it takes precedence over any of the heuristics\n    // that follow.\n    //\n    // TODO: When PPR is enabled, the server will *always* return a stale time\n    // when prefetching. We should never use a prefetch entry that hasn't yet\n    // received data from the server. So the only two cases should be 1) we use\n    // the server-generated stale time 2) the unresolved entry is discarded.\n    return Date.now() < prefetchTime + staleTime\n      ? PrefetchCacheEntryStatus.fresh\n      : PrefetchCacheEntryStatus.stale\n  }\n\n  // We will re-use the cache entry data for up to the `dynamic` staletime window.\n  if (Date.now() < (lastUsedTime ?? prefetchTime) + DYNAMIC_STALETIME_MS) {\n    return lastUsedTime\n      ? PrefetchCacheEntryStatus.reusable\n      : PrefetchCacheEntryStatus.fresh\n  }\n\n  // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n  // A stale entry will only re-use the `loading` boundary, not the full data.\n  // This will trigger a \"lazy fetch\" for the full data.\n  if (kind === PrefetchKind.AUTO) {\n    if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n      return PrefetchCacheEntryStatus.stale\n    }\n  }\n\n  // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n  if (kind === PrefetchKind.FULL) {\n    if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n      return PrefetchCacheEntryStatus.reusable\n    }\n  }\n\n  return PrefetchCacheEntryStatus.expired\n}\n"],"names":["fetchServerResponse","PrefetchCacheEntryStatus","PrefetchKind","prefetchQueue","INTERCEPTION_CACHE_KEY_MARKER","createPrefetchCacheKeyImpl","url","includeSearchParams","prefix","pathnameFromUrl","pathname","search","createPrefetchCacheKey","kind","nextUrl","FULL","getExistingCacheEntry","prefetchCache","allowAliasing","TEMPORARY","maybeNextUrl","cacheKeyWithParams","cacheKeyWithoutParams","cacheKeyToUse","existingEntry","get","isAliased","aliased","entryWithoutParams","process","env","NODE_ENV","key","includes","cacheEntry","values","undefined","getOrCreatePrefetchCacheEntry","tree","existingCacheEntry","status","getPrefetchEntryCacheStatus","switchedToFullPrefetch","data","then","prefetchResponse","isFullPrefetch","Array","isArray","flightData","some","isRootRender","seedData","createLazyPrefetchEntry","prefixExistingPrefetchCacheEntry","existingCacheKey","newCacheKey","set","delete","createSeededPrefetchCacheEntry","prefetchCacheKey","couldBeIntercepted","prefetchEntry","treeAtTimeOfPrefetch","Promise","resolve","prefetchTime","Date","now","lastUsedTime","staleTime","fresh","enqueue","flightRouterState","prefetchKind","prerendered","prunePrefetchCache","href","prefetchCacheEntry","expired","DYNAMIC_STALETIME_MS","Number","__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME","STATIC_STALETIME_MS","__NEXT_CLIENT_ROUTER_STATIC_STALETIME","stale","reusable","AUTO"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 667, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 673, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/invalidate-cache-by-router-state.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { FlightRouterState } from '../../../server/app-render/types'\nimport { createRouterCacheKey } from './create-router-cache-key'\n\n/**\n * Invalidate cache one level down from the router state.\n */\nexport function invalidateCacheByRouterState(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  routerState: FlightRouterState\n): void {\n  // Remove segment that we got data for so that it is filled in during rendering of rsc.\n  for (const key in routerState[1]) {\n    const segmentForParallelRoute = routerState[1][key][0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n    const existingParallelRoutesCacheNode =\n      existingCache.parallelRoutes.get(key)\n    if (existingParallelRoutesCacheNode) {\n      let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n      parallelRouteCacheNode.delete(cacheKey)\n      newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n    }\n  }\n}\n"],"names":["createRouterCacheKey","invalidateCacheByRouterState","newCache","existingCache","routerState","key","segmentForParallelRoute","cacheKey","existingParallelRoutesCacheNode","parallelRoutes","get","parallelRouteCacheNode","Map","delete","set"],"mappings":";;;AAEA,SAASA,oBAAoB,QAAQ,4BAA2B;;AAKzD,SAASC,6BACdC,QAAmB,EACnBC,aAAwB,EACxBC,WAA8B;IAE9B,uFAAuF;IACvF,IAAK,MAAMC,OAAOD,WAAW,CAAC,EAAE,CAAE;QAChC,MAAME,0BAA0BF,WAAW,CAAC,EAAE,CAACC,IAAI,CAAC,EAAE;QACtD,MAAME,4OAAWP,uBAAAA,EAAqBM;QACtC,MAAME,kCACJL,cAAcM,cAAc,CAACC,GAAG,CAACL;QACnC,IAAIG,iCAAiC;YACnC,IAAIG,yBAAyB,IAAIC,IAAIJ;YACrCG,uBAAuBE,MAAM,CAACN;YAC9BL,SAASO,cAAc,CAACK,GAAG,CAACT,KAAKM;QACnC;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 691, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 697, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/fill-cache-with-new-subtree-data.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { Segment } from '../../../server/app-render/types'\nimport { invalidateCacheByRouterState } from './invalidate-cache-by-router-state'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport type { PrefetchCacheEntry } from './router-reducer-types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\n\n/**\n * Common logic for filling cache with new sub tree data.\n */\nfunction fillCacheHelper(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData,\n  prefetchEntry: PrefetchCacheEntry | undefined,\n  fillLazyItems: boolean\n): void {\n  const {\n    segmentPath,\n    seedData: cacheNodeSeedData,\n    tree: treePatch,\n    head,\n  } = flightData\n  let newCacheNode = newCache\n  let existingCacheNode = existingCache\n\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n\n    // segmentPath is a repeating tuple of parallelRouteKey and segment\n    // we know we've hit the last entry we've reached our final pair\n    const isLastEntry = i === segmentPath.length - 2\n    const cacheKey = createRouterCacheKey(segment)\n\n    const existingChildSegmentMap =\n      existingCacheNode.parallelRoutes.get(parallelRouteKey)\n\n    if (!existingChildSegmentMap) {\n      // Bailout because the existing cache does not have the path to the leaf node\n      // Will trigger lazy fetch in layout-router because of missing segment\n      continue\n    }\n\n    let childSegmentMap = newCacheNode.parallelRoutes.get(parallelRouteKey)\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n      childSegmentMap = new Map(existingChildSegmentMap)\n      newCacheNode.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n    }\n\n    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)\n    let childCacheNode = childSegmentMap.get(cacheKey)\n\n    if (isLastEntry) {\n      if (\n        cacheNodeSeedData &&\n        (!childCacheNode ||\n          !childCacheNode.lazyData ||\n          childCacheNode === existingChildCacheNode)\n      ) {\n        const incomingSegment = cacheNodeSeedData[0]\n        const rsc = cacheNodeSeedData[1]\n        const loading = cacheNodeSeedData[3]\n\n        childCacheNode = {\n          lazyData: null,\n          // When `fillLazyItems` is false, we only want to fill the RSC data for the layout,\n          // not the page segment.\n          rsc:\n            fillLazyItems || incomingSegment !== PAGE_SEGMENT_KEY ? rsc : null,\n          prefetchRsc: null,\n          head: null,\n          prefetchHead: null,\n          loading,\n          parallelRoutes:\n            fillLazyItems && existingChildCacheNode\n              ? new Map(existingChildCacheNode.parallelRoutes)\n              : new Map(),\n        }\n\n        if (existingChildCacheNode && fillLazyItems) {\n          invalidateCacheByRouterState(\n            childCacheNode,\n            existingChildCacheNode,\n            treePatch\n          )\n        }\n        if (fillLazyItems) {\n          fillLazyItemsTillLeafWithHead(\n            childCacheNode,\n            existingChildCacheNode,\n            treePatch,\n            cacheNodeSeedData,\n            head,\n            prefetchEntry\n          )\n        }\n\n        childSegmentMap.set(cacheKey, childCacheNode)\n      }\n      continue\n    }\n\n    if (!childCacheNode || !existingChildCacheNode) {\n      // Bailout because the existing cache does not have the path to the leaf node\n      // Will trigger lazy fetch in layout-router because of missing segment\n      continue\n    }\n\n    if (childCacheNode === existingChildCacheNode) {\n      childCacheNode = {\n        lazyData: childCacheNode.lazyData,\n        rsc: childCacheNode.rsc,\n        prefetchRsc: childCacheNode.prefetchRsc,\n        head: childCacheNode.head,\n        prefetchHead: childCacheNode.prefetchHead,\n        parallelRoutes: new Map(childCacheNode.parallelRoutes),\n        loading: childCacheNode.loading,\n      } as CacheNode\n      childSegmentMap.set(cacheKey, childCacheNode)\n    }\n\n    // Move deeper into the cache nodes\n    newCacheNode = childCacheNode\n    existingCacheNode = existingChildCacheNode\n  }\n}\n\n/**\n * Fill cache with rsc based on flightDataPath\n */\nexport function fillCacheWithNewSubTreeData(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData,\n  prefetchEntry?: PrefetchCacheEntry\n): void {\n  fillCacheHelper(newCache, existingCache, flightData, prefetchEntry, true)\n}\n\nexport function fillCacheWithNewSubTreeDataButOnlyLoading(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData,\n  prefetchEntry?: PrefetchCacheEntry\n): void {\n  fillCacheHelper(newCache, existingCache, flightData, prefetchEntry, false)\n}\n"],"names":["invalidateCacheByRouterState","fillLazyItemsTillLeafWithHead","createRouterCacheKey","PAGE_SEGMENT_KEY","fillCacheHelper","newCache","existingCache","flightData","prefetchEntry","fillLazyItems","segmentPath","seedData","cacheNodeSeedData","tree","treePatch","head","newCacheNode","existingCacheNode","i","length","parallelRouteKey","segment","isLastEntry","cacheKey","existingChildSegmentMap","parallelRoutes","get","childSegmentMap","Map","set","existingChildCacheNode","childCacheNode","lazyData","incomingSegment","rsc","loading","prefetchRsc","prefetchHead","fillCacheWithNewSubTreeData","fillCacheWithNewSubTreeDataButOnlyLoading"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 785, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 791, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/apply-flight-data.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { fillCacheWithNewSubTreeData } from './fill-cache-with-new-subtree-data'\nimport type { PrefetchCacheEntry } from './router-reducer-types'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\n\nexport function applyFlightData(\n  existingCache: CacheNode,\n  cache: CacheNode,\n  flightData: NormalizedFlightData,\n  prefetchEntry?: PrefetchCacheEntry\n): boolean {\n  // The one before last item is the router state tree patch\n  const { tree: treePatch, seedData, head, isRootRender } = flightData\n\n  // Handles case where prefetch only returns the router tree patch without rendered components.\n  if (seedData === null) {\n    return false\n  }\n\n  if (isRootRender) {\n    const rsc = seedData[1]\n    const loading = seedData[3]\n    cache.loading = loading\n    cache.rsc = rsc\n    // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n    // this path during a navigation, but until PPR is fully implemented\n    // yet it's possible the existing node does have a non-null\n    // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n    // old behavior — no PPR value.\n    cache.prefetchRsc = null\n    fillLazyItemsTillLeafWithHead(\n      cache,\n      existingCache,\n      treePatch,\n      seedData,\n      head,\n      prefetchEntry\n    )\n  } else {\n    // Copy rsc for the root node of the cache.\n    cache.rsc = existingCache.rsc\n    // This is a PPR-only field. Unlike the previous branch, since we're\n    // just cloning the existing cache node, we might as well keep the\n    // PPR value, if it exists.\n    cache.prefetchRsc = existingCache.prefetchRsc\n    cache.parallelRoutes = new Map(existingCache.parallelRoutes)\n    cache.loading = existingCache.loading\n    // Create a copy of the existing cache with the rsc applied.\n    fillCacheWithNewSubTreeData(cache, existingCache, flightData, prefetchEntry)\n  }\n\n  return true\n}\n"],"names":["fillLazyItemsTillLeafWithHead","fillCacheWithNewSubTreeData","applyFlightData","existingCache","cache","flightData","prefetchEntry","tree","treePatch","seedData","head","isRootRender","rsc","loading","prefetchRsc","parallelRoutes","Map"],"mappings":";;;AACA,SAASA,6BAA6B,QAAQ,wCAAuC;AACrF,SAASC,2BAA2B,QAAQ,qCAAoC;;;AAIzE,SAASC,gBACdC,aAAwB,EACxBC,KAAgB,EAChBC,UAAgC,EAChCC,aAAkC;IAElC,0DAA0D;IAC1D,MAAM,EAAEC,MAAMC,SAAS,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,YAAY,EAAE,GAAGN;IAE1D,8FAA8F;IAC9F,IAAII,aAAa,MAAM;QACrB,OAAO;IACT;IAEA,IAAIE,cAAc;QAChB,MAAMC,MAAMH,QAAQ,CAAC,EAAE;QACvB,MAAMI,UAAUJ,QAAQ,CAAC,EAAE;QAC3BL,MAAMS,OAAO,GAAGA;QAChBT,MAAMQ,GAAG,GAAGA;QACZ,kEAAkE;QAClE,oEAAoE;QACpE,2DAA2D;QAC3D,kEAAkE;QAClE,+BAA+B;QAC/BR,MAAMU,WAAW,GAAG;SACpBd,qRAAAA,EACEI,OACAD,eACAK,WACAC,UACAC,MACAJ;IAEJ,OAAO;QACL,2CAA2C;QAC3CF,MAAMQ,GAAG,GAAGT,cAAcS,GAAG;QAC7B,oEAAoE;QACpE,kEAAkE;QAClE,2BAA2B;QAC3BR,MAAMU,WAAW,GAAGX,cAAcW,WAAW;QAC7CV,MAAMW,cAAc,GAAG,IAAIC,IAAIb,cAAcY,cAAc;QAC3DX,MAAMS,OAAO,GAAGV,cAAcU,OAAO;QACrC,4DAA4D;wPAC5DZ,8BAAAA,EAA4BG,OAAOD,eAAeE,YAAYC;IAChE;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 831, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 837, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/refetch-inactive-parallel-segments.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../server/app-render/types'\nimport type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { AppRouterState } from './router-reducer-types'\nimport { applyFlightData } from './apply-flight-data'\nimport { fetchServerResponse } from './fetch-server-response'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\ninterface RefreshInactiveParallelSegments {\n  state: AppRouterState\n  updatedTree: FlightRouterState\n  updatedCache: CacheNode\n  includeNextUrl: boolean\n  canonicalUrl: string\n}\n\n/**\n * Refreshes inactive segments that are still in the current FlightRouterState.\n * A segment is considered \"inactive\" when the server response indicates it didn't match to a page component.\n * This happens during a soft-navigation, where the server will want to patch in the segment\n * with the \"default\" component, but we explicitly ignore the server in this case\n * and keep the existing state for that segment. New data for inactive segments are inherently\n * not part of the server response when we patch the tree, because they were associated with a response\n * from an earlier navigation/request. For each segment, once it becomes \"active\", we encode the URL that provided\n * the data for it. This function traverses parallel routes looking for these markers so that it can re-fetch\n * and patch the new data into the tree.\n */\nexport async function refreshInactiveParallelSegments(\n  options: RefreshInactiveParallelSegments\n) {\n  const fetchedSegments = new Set<string>()\n  await refreshInactiveParallelSegmentsImpl({\n    ...options,\n    rootTree: options.updatedTree,\n    fetchedSegments,\n  })\n}\n\nasync function refreshInactiveParallelSegmentsImpl({\n  state,\n  updatedTree,\n  updatedCache,\n  includeNextUrl,\n  fetchedSegments,\n  rootTree = updatedTree,\n  canonicalUrl,\n}: RefreshInactiveParallelSegments & {\n  fetchedSegments: Set<string>\n  rootTree: FlightRouterState\n}) {\n  const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree\n  const fetchPromises = []\n\n  if (\n    refetchPath &&\n    refetchPath !== canonicalUrl &&\n    refetchMarker === 'refresh' &&\n    // it's possible for the tree to contain multiple segments that contain data at the same URL\n    // we keep track of them so we can dedupe the requests\n    !fetchedSegments.has(refetchPath)\n  ) {\n    fetchedSegments.add(refetchPath) // Mark this URL as fetched\n\n    // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n    // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.\n    const fetchPromise = fetchServerResponse(\n      new URL(refetchPath, location.origin),\n      {\n        // refetch from the root of the updated tree, otherwise it will be scoped to the current segment\n        // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n        flightRouterState: [rootTree[0], rootTree[1], rootTree[2], 'refetch'],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n      }\n    ).then(({ flightData }) => {\n      if (typeof flightData !== 'string') {\n        for (const flightDataPath of flightData) {\n          // we only pass the new cache as this function is called after clearing the router cache\n          // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's\n          // just been created & has been written to, but hasn't been \"committed\" yet.\n          applyFlightData(updatedCache, updatedCache, flightDataPath)\n        }\n      } else {\n        // When flightData is a string, it suggests that the server response should have triggered an MPA navigation\n        // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect\n        // when refreshing on-screen data, so handling this has been ommitted.\n      }\n    })\n\n    fetchPromises.push(fetchPromise)\n  }\n\n  for (const key in parallelRoutes) {\n    const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n      state,\n      updatedTree: parallelRoutes[key],\n      updatedCache,\n      includeNextUrl,\n      fetchedSegments,\n      rootTree,\n      canonicalUrl,\n    })\n\n    fetchPromises.push(parallelFetchPromise)\n  }\n\n  await Promise.all(fetchPromises)\n}\n\n/**\n * Walks the current parallel segments to determine if they are \"active\".\n * An active parallel route will have a `__PAGE__` segment in the FlightRouterState.\n * As opposed to a `__DEFAULT__` segment, which means there was no match for that parallel route.\n * We add a special marker here so that we know how to refresh its data when the router is revalidated.\n */\nexport function addRefreshMarkerToActiveParallelSegments(\n  tree: FlightRouterState,\n  path: string\n) {\n  const [segment, parallelRoutes, , refetchMarker] = tree\n  // a page segment might also contain concatenated search params, so we do a partial match on the key\n  if (segment.includes(PAGE_SEGMENT_KEY) && refetchMarker !== 'refresh') {\n    tree[2] = path\n    tree[3] = 'refresh'\n  }\n\n  for (const key in parallelRoutes) {\n    addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path)\n  }\n}\n"],"names":["applyFlightData","fetchServerResponse","PAGE_SEGMENT_KEY","refreshInactiveParallelSegments","options","fetchedSegments","Set","refreshInactiveParallelSegmentsImpl","rootTree","updatedTree","state","updatedCache","includeNextUrl","canonicalUrl","parallelRoutes","refetchPath","refetchMarker","fetchPromises","has","add","fetchPromise","URL","location","origin","flightRouterState","nextUrl","then","flightData","flightDataPath","push","key","parallelFetchPromise","Promise","all","addRefreshMarkerToActiveParallelSegments","tree","path","segment","includes"],"mappings":";;;;AAGA,SAASA,eAAe,QAAQ,sBAAqB;AACrD,SAASC,mBAAmB,QAAQ,0BAAyB;AAC7D,SAASC,gBAAgB,QAAQ,8BAA6B;;;;AAqBvD,eAAeC,gCACpBC,OAAwC;IAExC,MAAMC,kBAAkB,IAAIC;IAC5B,MAAMC,oCAAoC;QACxC,GAAGH,OAAO;QACVI,UAAUJ,QAAQK,WAAW;QAC7BJ;IACF;AACF;AAEA,eAAeE,oCAAoC,KAWlD;IAXkD,IAAA,EACjDG,KAAK,EACLD,WAAW,EACXE,YAAY,EACZC,cAAc,EACdP,eAAe,EACfG,WAAWC,WAAW,EACtBI,YAAY,EAIb,GAXkD;IAYjD,MAAM,GAAGC,gBAAgBC,aAAaC,cAAc,GAAGP;IACvD,MAAMQ,gBAAgB,EAAE;IAExB,IACEF,eACAA,gBAAgBF,gBAChBG,kBAAkB,aAClB,4FAA4F;IAC5F,sDAAsD;IACtD,CAACX,gBAAgBa,GAAG,CAACH,cACrB;QACAV,gBAAgBc,GAAG,CAACJ,aAAa,2BAA2B;;QAE5D,wHAAwH;QACxH,kIAAkI;QAClI,MAAMK,2OAAenB,sBAAAA,EACnB,IAAIoB,IAAIN,aAAaO,SAASC,MAAM,GACpC;YACE,gGAAgG;YAChG,8HAA8H;YAC9HC,mBAAmB;gBAAChB,QAAQ,CAAC,EAAE;gBAAEA,QAAQ,CAAC,EAAE;gBAAEA,QAAQ,CAAC,EAAE;gBAAE;aAAU;YACrEiB,SAASb,iBAAiBF,MAAMe,OAAO,GAAG;QAC5C,GACAC,IAAI,CAAC,CAAA;gBAAC,EAAEC,UAAU,EAAE,GAAA;YACpB,IAAI,OAAOA,eAAe,UAAU;gBAClC,KAAK,MAAMC,kBAAkBD,WAAY;oBACvC,wFAAwF;oBACxF,4GAA4G;oBAC5G,4EAA4E;4OAC5E3B,kBAAAA,EAAgBW,cAAcA,cAAciB;gBAC9C;YACF,OAAO;YACL,4GAA4G;YAC5G,+GAA+G;YAC/G,sEAAsE;YACxE;QACF;QAEAX,cAAcY,IAAI,CAACT;IACrB;IAEA,IAAK,MAAMU,OAAOhB,eAAgB;QAChC,MAAMiB,uBAAuBxB,oCAAoC;YAC/DG;YACAD,aAAaK,cAAc,CAACgB,IAAI;YAChCnB;YACAC;YACAP;YACAG;YACAK;QACF;QAEAI,cAAcY,IAAI,CAACE;IACrB;IAEA,MAAMC,QAAQC,GAAG,CAAChB;AACpB;AAQO,SAASiB,yCACdC,IAAuB,EACvBC,IAAY;IAEZ,MAAM,CAACC,SAASvB,kBAAkBE,cAAc,GAAGmB;IACnD,oGAAoG;IACpG,IAAIE,QAAQC,QAAQ,yKAACpC,mBAAAA,KAAqBc,kBAAkB,WAAW;QACrEmB,IAAI,CAAC,EAAE,GAAGC;QACVD,IAAI,CAAC,EAAE,GAAG;IACZ;IAEA,IAAK,MAAML,OAAOhB,eAAgB;QAChCoB,yCAAyCpB,cAAc,CAACgB,IAAI,EAAEM;IAChE;AACF","ignoreList":[0]}},
    {"offset": {"line": 918, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 924, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/create-initial-router-state.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { FlightDataPath } from '../../../server/app-render/types'\n\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { extractPathFromFlightRouterState } from './compute-changed-path'\nimport { createSeededPrefetchCacheEntry } from './prefetch-cache-utils'\nimport { PrefetchKind, type PrefetchCacheEntry } from './router-reducer-types'\nimport { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\nimport { getFlightDataPartsFromPath } from '../../flight-data-helpers'\n\nexport interface InitialRouterStateParameters {\n  initialCanonicalUrlParts: string[]\n  initialParallelRoutes: CacheNode['parallelRoutes']\n  initialFlightData: FlightDataPath[]\n  location: Location | null\n  couldBeIntercepted: boolean\n  postponed: boolean\n  prerendered: boolean\n}\n\nexport function createInitialRouterState({\n  initialFlightData,\n  initialCanonicalUrlParts,\n  initialParallelRoutes,\n  location,\n  couldBeIntercepted,\n  postponed,\n  prerendered,\n}: InitialRouterStateParameters) {\n  // When initialized on the server, the canonical URL is provided as an array of parts.\n  // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n  // as a URL that should be crawled.\n  const initialCanonicalUrl = initialCanonicalUrlParts.join('/')\n  const normalizedFlightData = getFlightDataPartsFromPath(initialFlightData[0])\n  const {\n    tree: initialTree,\n    seedData: initialSeedData,\n    head: initialHead,\n  } = normalizedFlightData\n  const isServer = !location\n  // For the SSR render, seed data should always be available (we only send back a `null` response\n  // in the case of a `loading` segment, pre-PPR.)\n  const rsc = initialSeedData?.[1]\n  const loading = initialSeedData?.[3] ?? null\n\n  const cache: CacheNode = {\n    lazyData: null,\n    rsc,\n    prefetchRsc: null,\n    head: null,\n    prefetchHead: null,\n    // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n    parallelRoutes: isServer ? new Map() : initialParallelRoutes,\n    loading,\n  }\n\n  const canonicalUrl =\n    // location.href is read as the initial value for canonicalUrl in the browser\n    // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n    location\n      ? // window.location does not have the same type as URL but has all the fields createHrefFromUrl needs.\n        createHrefFromUrl(location)\n      : initialCanonicalUrl\n\n  addRefreshMarkerToActiveParallelSegments(initialTree, canonicalUrl)\n\n  const prefetchCache = new Map<string, PrefetchCacheEntry>()\n\n  // When the cache hasn't been seeded yet we fill the cache with the head.\n  if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n    fillLazyItemsTillLeafWithHead(\n      cache,\n      undefined,\n      initialTree,\n      initialSeedData,\n      initialHead\n    )\n  }\n\n  const initialState = {\n    tree: initialTree,\n    cache,\n    prefetchCache,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // First render needs to preserve the previous window.history.state\n      // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: {\n      apply: false,\n      onlyHashChange: false,\n      hashFragment: null,\n      segmentPaths: [],\n    },\n    canonicalUrl,\n    nextUrl:\n      // the || operator is intentional, the pathname can be an empty string\n      (extractPathFromFlightRouterState(initialTree) || location?.pathname) ??\n      null,\n  }\n\n  if (process.env.NODE_ENV !== 'development' && location) {\n    // Seed the prefetch cache with this page's data.\n    // This is to prevent needlessly re-prefetching a page that is already reusable,\n    // and will avoid triggering a loading state/data fetch stall when navigating back to the page.\n    // We don't currently do this in development because links aren't prefetched in development\n    // so having a mismatch between prefetch/no prefetch provides inconsistent behavior based on which page\n    // was loaded first.\n    const url = new URL(\n      `${location.pathname}${location.search}`,\n      location.origin\n    )\n\n    createSeededPrefetchCacheEntry({\n      url,\n      data: {\n        flightData: [normalizedFlightData],\n        canonicalUrl: undefined,\n        couldBeIntercepted: !!couldBeIntercepted,\n        prerendered,\n        postponed,\n        // TODO: The initial RSC payload includes both static and dynamic data\n        // in the same response, even if PPR is enabled. So if there's any\n        // dynamic data at all, we can't set a stale time. In the future we may\n        // add a way to split a single Flight stream into static and dynamic\n        // parts. But in the meantime we should at least make this work for\n        // fully static pages.\n        staleTime: -1,\n      },\n      tree: initialState.tree,\n      prefetchCache: initialState.prefetchCache,\n      nextUrl: initialState.nextUrl,\n      kind: prerendered ? PrefetchKind.FULL : PrefetchKind.AUTO,\n    })\n  }\n\n  return initialState\n}\n"],"names":["createHrefFromUrl","fillLazyItemsTillLeafWithHead","extractPathFromFlightRouterState","createSeededPrefetchCacheEntry","PrefetchKind","addRefreshMarkerToActiveParallelSegments","getFlightDataPartsFromPath","createInitialRouterState","initialFlightData","initialCanonicalUrlParts","initialParallelRoutes","location","couldBeIntercepted","postponed","prerendered","initialCanonicalUrl","join","normalizedFlightData","tree","initialTree","seedData","initialSeedData","head","initialHead","isServer","rsc","loading","cache","lazyData","prefetchRsc","prefetchHead","parallelRoutes","Map","canonicalUrl","prefetchCache","size","undefined","initialState","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","onlyHashChange","hashFragment","segmentPaths","nextUrl","pathname","process","env","NODE_ENV","url","URL","search","origin","data","flightData","staleTime","kind","FULL","AUTO"],"mappings":";;;AAGA,SAASA,iBAAiB,QAAQ,yBAAwB;AAC1D,SAASC,6BAA6B,QAAQ,wCAAuC;AACrF,SAASC,gCAAgC,QAAQ,yBAAwB;AACzE,SAASC,8BAA8B,QAAQ,yBAAwB;AACvE,SAASC,YAAY,QAAiC,yBAAwB;AAC9E,SAASC,wCAAwC,QAAQ,uCAAsC;AAC/F,SAASC,0BAA0B,QAAQ,4BAA2B;;;;;;;;AAY/D,SAASC,yBAAyB,KAQV;IARU,IAAA,EACvCC,iBAAiB,EACjBC,wBAAwB,EACxBC,qBAAqB,EACrBC,QAAQ,EACRC,kBAAkB,EAClBC,SAAS,EACTC,WAAW,EACkB,GARU;IASvC,sFAAsF;IACtF,kGAAkG;IAClG,mCAAmC;IACnC,MAAMC,sBAAsBN,yBAAyBO,IAAI,CAAC;IAC1D,MAAMC,wBAAuBX,mNAAAA,EAA2BE,iBAAiB,CAAC,EAAE;IAC5E,MAAM,EACJU,MAAMC,WAAW,EACjBC,UAAUC,eAAe,EACzBC,MAAMC,WAAW,EAClB,GAAGN;IACJ,MAAMO,WAAW,CAACb;IAClB,gGAAgG;IAChG,gDAAgD;IAChD,MAAMc,MAAMJ,mBAAAA,OAAAA,KAAAA,IAAAA,eAAiB,CAAC,EAAE;QAChBA;IAAhB,MAAMK,UAAUL,CAAAA,oBAAAA,mBAAAA,OAAAA,KAAAA,IAAAA,eAAiB,CAAC,EAAE,KAAA,OAApBA,oBAAwB;IAExC,MAAMM,QAAmB;QACvBC,UAAU;QACVH;QACAI,aAAa;QACbP,MAAM;QACNQ,cAAc;QACd,oJAAoJ;QACpJC,gBAAgBP,WAAW,IAAIQ,QAAQtB;QACvCgB;IACF;IAEA,MAAMO,eACJ,AACA,6EAD6E,qEACqE;IAClJtB,YAEIX,iPAAAA,EAAkBW,YAClBI;gPAENV,2CAAAA,EAAyCc,aAAac;IAEtD,MAAMC,gBAAgB,IAAIF;IAE1B,yEAAyE;IACzE,IAAItB,0BAA0B,QAAQA,sBAAsByB,IAAI,KAAK,GAAG;8PACtElC,gCAAAA,EACE0B,OACAS,WACAjB,aACAE,iBACAE;IAEJ;QAqBI,AACCrB,sEADqE;IAnB1E,MAAMmC,eAAe;QACnBnB,MAAMC;QACNQ;QACAO;QACAI,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,mEAAmE;YACnE,gFAAgF;YAChFC,4BAA4B;QAC9B;QACAC,mBAAmB;YACjBC,OAAO;YACPC,gBAAgB;YAChBC,cAAc;YACdC,cAAc,EAAE;QAClB;QACAb;QACAc,SAEE,CAAC7C,kOAAAA,mCAAAA,EAAiCiB,gBAAAA,CAAgBR,YAAAA,OAAAA,KAAAA,IAAAA,SAAUqC,QAAQ,CAAA,KAAA,OAAnE9C,OACD;IACJ;IAEA,IAAI+C,QAAQC,GAAG,CAACC,QAAQ,KAAK,UAA2B,OAAVxC;;IAiC9C;IAEA,OAAO0B;AACT","ignoreList":[0]}},
    {"offset": {"line": 999, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1005, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { FlightSegmentPath } from '../../../server/app-render/types'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\n\n/**\n * Fill cache up to the end of the flightSegmentPath, invalidating anything below it.\n */\nexport function invalidateCacheBelowFlightSegmentPath(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightSegmentPath: FlightSegmentPath\n): void {\n  const isLastEntry = flightSegmentPath.length <= 2\n  const [parallelRouteKey, segment] = flightSegmentPath\n\n  const cacheKey = createRouterCacheKey(segment)\n\n  const existingChildSegmentMap =\n    existingCache.parallelRoutes.get(parallelRouteKey)\n\n  if (!existingChildSegmentMap) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return\n  }\n\n  let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey)\n  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n    childSegmentMap = new Map(existingChildSegmentMap)\n    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n  }\n\n  // In case of last entry don't copy further down.\n  if (isLastEntry) {\n    childSegmentMap.delete(cacheKey)\n    return\n  }\n\n  const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)\n  let childCacheNode = childSegmentMap.get(cacheKey)\n\n  if (!childCacheNode || !existingChildCacheNode) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return\n  }\n\n  if (childCacheNode === existingChildCacheNode) {\n    childCacheNode = {\n      lazyData: childCacheNode.lazyData,\n      rsc: childCacheNode.rsc,\n      prefetchRsc: childCacheNode.prefetchRsc,\n      head: childCacheNode.head,\n      prefetchHead: childCacheNode.prefetchHead,\n      parallelRoutes: new Map(childCacheNode.parallelRoutes),\n    } as CacheNode\n    childSegmentMap.set(cacheKey, childCacheNode)\n  }\n\n  invalidateCacheBelowFlightSegmentPath(\n    childCacheNode,\n    existingChildCacheNode,\n    getNextFlightSegmentPath(flightSegmentPath)\n  )\n}\n"],"names":["createRouterCacheKey","getNextFlightSegmentPath","invalidateCacheBelowFlightSegmentPath","newCache","existingCache","flightSegmentPath","isLastEntry","length","parallelRouteKey","segment","cacheKey","existingChildSegmentMap","parallelRoutes","get","childSegmentMap","Map","set","delete","existingChildCacheNode","childCacheNode","lazyData","rsc","prefetchRsc","head","prefetchHead"],"mappings":";;;AAEA,SAASA,oBAAoB,QAAQ,4BAA2B;AAChE,SAASC,wBAAwB,QAAQ,4BAA2B;;;AAK7D,SAASC,sCACdC,QAAmB,EACnBC,aAAwB,EACxBC,iBAAoC;IAEpC,MAAMC,cAAcD,kBAAkBE,MAAM,IAAI;IAChD,MAAM,CAACC,kBAAkBC,QAAQ,GAAGJ;IAEpC,MAAMK,WAAWV,wPAAAA,EAAqBS;IAEtC,MAAME,0BACJP,cAAcQ,cAAc,CAACC,GAAG,CAACL;IAEnC,IAAI,CAACG,yBAAyB;QAC5B,6EAA6E;QAC7E,sEAAsE;QACtE;IACF;IAEA,IAAIG,kBAAkBX,SAASS,cAAc,CAACC,GAAG,CAACL;IAClD,IAAI,CAACM,mBAAmBA,oBAAoBH,yBAAyB;QACnEG,kBAAkB,IAAIC,IAAIJ;QAC1BR,SAASS,cAAc,CAACI,GAAG,CAACR,kBAAkBM;IAChD;IAEA,iDAAiD;IACjD,IAAIR,aAAa;QACfQ,gBAAgBG,MAAM,CAACP;QACvB;IACF;IAEA,MAAMQ,yBAAyBP,wBAAwBE,GAAG,CAACH;IAC3D,IAAIS,iBAAiBL,gBAAgBD,GAAG,CAACH;IAEzC,IAAI,CAACS,kBAAkB,CAACD,wBAAwB;QAC9C,6EAA6E;QAC7E,sEAAsE;QACtE;IACF;IAEA,IAAIC,mBAAmBD,wBAAwB;QAC7CC,iBAAiB;YACfC,UAAUD,eAAeC,QAAQ;YACjCC,KAAKF,eAAeE,GAAG;YACvBC,aAAaH,eAAeG,WAAW;YACvCC,MAAMJ,eAAeI,IAAI;YACzBC,cAAcL,eAAeK,YAAY;YACzCZ,gBAAgB,IAAIG,IAAII,eAAeP,cAAc;QACvD;QACAE,gBAAgBE,GAAG,CAACN,UAAUS;IAChC;IAEAjB,sCACEiB,gBACAD,+MACAjB,2BAAAA,EAAyBI;AAE7B","ignoreList":[0]}},
    {"offset": {"line": 1052, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1058, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/apply-router-state-patch-to-tree.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../server/app-render/types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\nimport { matchSegment } from '../match-segments'\nimport { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\n\n/**\n * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.\n */\nfunction applyPatch(\n  initialTree: FlightRouterState,\n  patchTree: FlightRouterState\n): FlightRouterState {\n  const [initialSegment, initialParallelRoutes] = initialTree\n  const [patchSegment, patchParallelRoutes] = patchTree\n\n  // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree\n  // this is because the __DEFAULT__ segment is used as a placeholder on navigation\n  if (\n    patchSegment === DEFAULT_SEGMENT_KEY &&\n    initialSegment !== DEFAULT_SEGMENT_KEY\n  ) {\n    return initialTree\n  }\n\n  if (matchSegment(initialSegment, patchSegment)) {\n    const newParallelRoutes: FlightRouterState[1] = {}\n    for (const key in initialParallelRoutes) {\n      const isInPatchTreeParallelRoutes =\n        typeof patchParallelRoutes[key] !== 'undefined'\n      if (isInPatchTreeParallelRoutes) {\n        newParallelRoutes[key] = applyPatch(\n          initialParallelRoutes[key],\n          patchParallelRoutes[key]\n        )\n      } else {\n        newParallelRoutes[key] = initialParallelRoutes[key]\n      }\n    }\n\n    for (const key in patchParallelRoutes) {\n      if (newParallelRoutes[key]) {\n        continue\n      }\n\n      newParallelRoutes[key] = patchParallelRoutes[key]\n    }\n\n    const tree: FlightRouterState = [initialSegment, newParallelRoutes]\n\n    // Copy over the existing tree\n    if (initialTree[2]) {\n      tree[2] = initialTree[2]\n    }\n\n    if (initialTree[3]) {\n      tree[3] = initialTree[3]\n    }\n\n    if (initialTree[4]) {\n      tree[4] = initialTree[4]\n    }\n\n    return tree\n  }\n\n  return patchTree\n}\n\n/**\n * Apply the router state from the Flight response, but skip patching default segments.\n * Useful for patching the router cache when navigating, where we persist the existing default segment if there isn't a new one.\n * Creates a new router state tree.\n */\nexport function applyRouterStatePatchToTree(\n  flightSegmentPath: FlightSegmentPath,\n  flightRouterState: FlightRouterState,\n  treePatch: FlightRouterState,\n  path: string\n): FlightRouterState | null {\n  const [segment, parallelRoutes, url, refetch, isRootLayout] =\n    flightRouterState\n\n  // Root refresh\n  if (flightSegmentPath.length === 1) {\n    const tree: FlightRouterState = applyPatch(flightRouterState, treePatch)\n\n    addRefreshMarkerToActiveParallelSegments(tree, path)\n\n    return tree\n  }\n\n  const [currentSegment, parallelRouteKey] = flightSegmentPath\n\n  // Tree path returned from the server should always match up with the current tree in the browser\n  if (!matchSegment(currentSegment, segment)) {\n    return null\n  }\n\n  const lastSegment = flightSegmentPath.length === 2\n\n  let parallelRoutePatch\n  if (lastSegment) {\n    parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch)\n  } else {\n    parallelRoutePatch = applyRouterStatePatchToTree(\n      getNextFlightSegmentPath(flightSegmentPath),\n      parallelRoutes[parallelRouteKey],\n      treePatch,\n      path\n    )\n\n    if (parallelRoutePatch === null) {\n      return null\n    }\n  }\n\n  const tree: FlightRouterState = [\n    flightSegmentPath[0],\n    {\n      ...parallelRoutes,\n      [parallelRouteKey]: parallelRoutePatch,\n    },\n    url,\n    refetch,\n  ]\n\n  // Current segment is the root layout\n  if (isRootLayout) {\n    tree[4] = true\n  }\n\n  addRefreshMarkerToActiveParallelSegments(tree, path)\n\n  return tree\n}\n"],"names":["DEFAULT_SEGMENT_KEY","getNextFlightSegmentPath","matchSegment","addRefreshMarkerToActiveParallelSegments","applyPatch","initialTree","patchTree","initialSegment","initialParallelRoutes","patchSegment","patchParallelRoutes","newParallelRoutes","key","isInPatchTreeParallelRoutes","tree","applyRouterStatePatchToTree","flightSegmentPath","flightRouterState","treePatch","path","segment","parallelRoutes","url","refetch","isRootLayout","length","currentSegment","parallelRouteKey","lastSegment","parallelRoutePatch"],"mappings":";;;AAIA,SAASA,mBAAmB,QAAQ,8BAA6B;AACjE,SAASC,wBAAwB,QAAQ,4BAA2B;AACpE,SAASC,YAAY,QAAQ,oBAAmB;AAChD,SAASC,wCAAwC,QAAQ,uCAAsC;;;;;AAE/F;;CAEC,GACD,SAASC,WACPC,WAA8B,EAC9BC,SAA4B;IAE5B,MAAM,CAACC,gBAAgBC,sBAAsB,GAAGH;IAChD,MAAM,CAACI,cAAcC,oBAAoB,GAAGJ;IAE5C,kGAAkG;IAClG,iFAAiF;IACjF,IACEG,iBAAiBT,8LAAAA,IACjBO,2LAAmBP,sBAAAA,EACnB;QACA,OAAOK;IACT;IAEA,iMAAIH,eAAAA,EAAaK,gBAAgBE,eAAe;QAC9C,MAAME,oBAA0C,CAAC;QACjD,IAAK,MAAMC,OAAOJ,sBAAuB;YACvC,MAAMK,8BACJ,OAAOH,mBAAmB,CAACE,IAAI,KAAK;YACtC,IAAIC,6BAA6B;gBAC/BF,iBAAiB,CAACC,IAAI,GAAGR,WACvBI,qBAAqB,CAACI,IAAI,EAC1BF,mBAAmB,CAACE,IAAI;YAE5B,OAAO;gBACLD,iBAAiB,CAACC,IAAI,GAAGJ,qBAAqB,CAACI,IAAI;YACrD;QACF;QAEA,IAAK,MAAMA,OAAOF,oBAAqB;YACrC,IAAIC,iBAAiB,CAACC,IAAI,EAAE;gBAC1B;YACF;YAEAD,iBAAiB,CAACC,IAAI,GAAGF,mBAAmB,CAACE,IAAI;QACnD;QAEA,MAAME,OAA0B;YAACP;YAAgBI;SAAkB;QAEnE,8BAA8B;QAC9B,IAAIN,WAAW,CAAC,EAAE,EAAE;YAClBS,IAAI,CAAC,EAAE,GAAGT,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBS,IAAI,CAAC,EAAE,GAAGT,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBS,IAAI,CAAC,EAAE,GAAGT,WAAW,CAAC,EAAE;QAC1B;QAEA,OAAOS;IACT;IAEA,OAAOR;AACT;AAOO,SAASS,4BACdC,iBAAoC,EACpCC,iBAAoC,EACpCC,SAA4B,EAC5BC,IAAY;IAEZ,MAAM,CAACC,SAASC,gBAAgBC,KAAKC,SAASC,aAAa,GACzDP;IAEF,eAAe;IACf,IAAID,kBAAkBS,MAAM,KAAK,GAAG;QAClC,MAAMX,OAA0BV,WAAWa,mBAAmBC;oPAE9Df,2CAAAA,EAAyCW,MAAMK;QAE/C,OAAOL;IACT;IAEA,MAAM,CAACY,gBAAgBC,iBAAiB,GAAGX;IAE3C,iGAAiG;IACjG,IAAI,8LAACd,eAAAA,EAAawB,gBAAgBN,UAAU;QAC1C,OAAO;IACT;IAEA,MAAMQ,cAAcZ,kBAAkBS,MAAM,KAAK;IAEjD,IAAII;IACJ,IAAID,aAAa;QACfC,qBAAqBzB,WAAWiB,cAAc,CAACM,iBAAiB,EAAET;IACpE,OAAO;QACLW,qBAAqBd,mNACnBd,2BAAAA,EAAyBe,oBACzBK,cAAc,CAACM,iBAAiB,EAChCT,WACAC;QAGF,IAAIU,uBAAuB,MAAM;YAC/B,OAAO;QACT;IACF;IAEA,MAAMf,OAA0B;QAC9BE,iBAAiB,CAAC,EAAE;QACpB;YACE,GAAGK,cAAc;YACjB,CAACM,iBAAiB,EAAEE;QACtB;QACAP;QACAC;KACD;IAED,qCAAqC;IACrC,IAAIC,cAAc;QAChBV,IAAI,CAAC,EAAE,GAAG;IACZ;gPAEAX,2CAAAA,EAAyCW,MAAMK;IAE/C,OAAOL;AACT","ignoreList":[0]}},
    {"offset": {"line": 1152, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1158, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/should-hard-navigate.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  FlightDataPath,\n  Segment,\n} from '../../../server/app-render/types'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\nimport { matchSegment } from '../match-segments'\n\n// TODO-APP: flightSegmentPath will be empty in case of static response, needs to be handled.\nexport function shouldHardNavigate(\n  flightSegmentPath: FlightDataPath,\n  flightRouterState: FlightRouterState\n): boolean {\n  const [segment, parallelRoutes] = flightRouterState\n  // TODO-APP: Check if `as` can be replaced.\n  const [currentSegment, parallelRouteKey] = flightSegmentPath as [\n    Segment,\n    string,\n  ]\n\n  // Check if current segment matches the existing segment.\n  if (!matchSegment(currentSegment, segment)) {\n    // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n    if (Array.isArray(currentSegment)) {\n      return true\n    }\n\n    // If the existing segment did not match soft navigation is triggered.\n    return false\n  }\n  const lastSegment = flightSegmentPath.length <= 2\n\n  if (lastSegment) {\n    return false\n  }\n\n  return shouldHardNavigate(\n    getNextFlightSegmentPath(flightSegmentPath),\n    parallelRoutes[parallelRouteKey]\n  )\n}\n"],"names":["getNextFlightSegmentPath","matchSegment","shouldHardNavigate","flightSegmentPath","flightRouterState","segment","parallelRoutes","currentSegment","parallelRouteKey","Array","isArray","lastSegment","length"],"mappings":";;;AAKA,SAASA,wBAAwB,QAAQ,4BAA2B;AACpE,SAASC,YAAY,QAAQ,oBAAmB;;;AAGzC,SAASC,mBACdC,iBAAiC,EACjCC,iBAAoC;IAEpC,MAAM,CAACC,SAASC,eAAe,GAAGF;IAClC,2CAA2C;IAC3C,MAAM,CAACG,gBAAgBC,iBAAiB,GAAGL;IAK3C,yDAAyD;IACzD,IAAI,8LAACF,eAAAA,EAAaM,gBAAgBF,UAAU;QAC1C,kGAAkG;QAClG,IAAII,MAAMC,OAAO,CAACH,iBAAiB;YACjC,OAAO;QACT;QAEA,sEAAsE;QACtE,OAAO;IACT;IACA,MAAMI,cAAcR,kBAAkBS,MAAM,IAAI;IAEhD,IAAID,aAAa;QACf,OAAO;IACT;IAEA,OAAOT,0MACLF,2BAAAA,EAAyBG,oBACzBG,cAAc,CAACE,iBAAiB;AAEpC","ignoreList":[0]}},
    {"offset": {"line": 1184, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1190, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/is-navigating-to-new-root-layout.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../server/app-render/types'\n\nexport function isNavigatingToNewRootLayout(\n  currentTree: FlightRouterState,\n  nextTree: FlightRouterState\n): boolean {\n  // Compare segments\n  const currentTreeSegment = currentTree[0]\n  const nextTreeSegment = nextTree[0]\n\n  // If any segment is different before we find the root layout, the root layout has changed.\n  // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n  // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n  if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n    // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n    // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n    if (\n      currentTreeSegment[0] !== nextTreeSegment[0] ||\n      currentTreeSegment[2] !== nextTreeSegment[2]\n    ) {\n      return true\n    }\n  } else if (currentTreeSegment !== nextTreeSegment) {\n    return true\n  }\n\n  // Current tree root layout found\n  if (currentTree[4]) {\n    // If the next tree doesn't have the root layout flag, it must have changed.\n    return !nextTree[4]\n  }\n  // Current tree didn't have its root layout here, must have changed.\n  if (nextTree[4]) {\n    return true\n  }\n  // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n  // But it's not possible to be more than one parallelRoutes before the root layout is found\n  // TODO-APP: change to traverse all parallel routes\n  const currentTreeChild = Object.values(currentTree[1])[0]\n  const nextTreeChild = Object.values(nextTree[1])[0]\n  if (!currentTreeChild || !nextTreeChild) return true\n  return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild)\n}\n"],"names":["isNavigatingToNewRootLayout","currentTree","nextTree","currentTreeSegment","nextTreeSegment","Array","isArray","currentTreeChild","Object","values","nextTreeChild"],"mappings":";;;AAEO,SAASA,4BACdC,WAA8B,EAC9BC,QAA2B;IAE3B,mBAAmB;IACnB,MAAMC,qBAAqBF,WAAW,CAAC,EAAE;IACzC,MAAMG,kBAAkBF,QAAQ,CAAC,EAAE;IAEnC,2FAA2F;IAC3F,4DAA4D;IAC5D,uIAAuI;IACvI,IAAIG,MAAMC,OAAO,CAACH,uBAAuBE,MAAMC,OAAO,CAACF,kBAAkB;QACvE,sHAAsH;QACtH,uGAAuG;QACvG,IACED,kBAAkB,CAAC,EAAE,KAAKC,eAAe,CAAC,EAAE,IAC5CD,kBAAkB,CAAC,EAAE,KAAKC,eAAe,CAAC,EAAE,EAC5C;YACA,OAAO;QACT;IACF,OAAO,IAAID,uBAAuBC,iBAAiB;QACjD,OAAO;IACT;IAEA,iCAAiC;IACjC,IAAIH,WAAW,CAAC,EAAE,EAAE;QAClB,4EAA4E;QAC5E,OAAO,CAACC,QAAQ,CAAC,EAAE;IACrB;IACA,oEAAoE;IACpE,IAAIA,QAAQ,CAAC,EAAE,EAAE;QACf,OAAO;IACT;IACA,4GAA4G;IAC5G,2FAA2F;IAC3F,mDAAmD;IACnD,MAAMK,mBAAmBC,OAAOC,MAAM,CAACR,WAAW,CAAC,EAAE,CAAC,CAAC,EAAE;IACzD,MAAMS,gBAAgBF,OAAOC,MAAM,CAACP,QAAQ,CAAC,EAAE,CAAC,CAAC,EAAE;IACnD,IAAI,CAACK,oBAAoB,CAACG,eAAe,OAAO;IAChD,OAAOV,4BAA4BO,kBAAkBG;AACvD","ignoreList":[0]}},
    {"offset": {"line": 1226, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1232, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/handle-mutable.ts"],"sourcesContent":["import { computeChangedPath } from './compute-changed-path'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n} from './router-reducer-types'\n\nfunction isNotUndefined<T>(value: T): value is Exclude<T, undefined> {\n  return typeof value !== 'undefined'\n}\n\nexport function handleMutable(\n  state: ReadonlyReducerState,\n  mutable: Mutable\n): ReducerState {\n  // shouldScroll is true by default, can override to false.\n  const shouldScroll = mutable.shouldScroll ?? true\n\n  let nextUrl = state.nextUrl\n\n  if (isNotUndefined(mutable.patchedTree)) {\n    // If we received a patched tree, we need to compute the changed path.\n    const changedPath = computeChangedPath(state.tree, mutable.patchedTree)\n    if (changedPath) {\n      // If the tree changed, we need to update the nextUrl\n      nextUrl = changedPath\n    } else if (!nextUrl) {\n      // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n      nextUrl = state.canonicalUrl\n    }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n  }\n\n  return {\n    // Set href.\n    canonicalUrl: isNotUndefined(mutable.canonicalUrl)\n      ? mutable.canonicalUrl === state.canonicalUrl\n        ? state.canonicalUrl\n        : mutable.canonicalUrl\n      : state.canonicalUrl,\n    pushRef: {\n      pendingPush: isNotUndefined(mutable.pendingPush)\n        ? mutable.pendingPush\n        : state.pushRef.pendingPush,\n      mpaNavigation: isNotUndefined(mutable.mpaNavigation)\n        ? mutable.mpaNavigation\n        : state.pushRef.mpaNavigation,\n      preserveCustomHistoryState: isNotUndefined(\n        mutable.preserveCustomHistoryState\n      )\n        ? mutable.preserveCustomHistoryState\n        : state.pushRef.preserveCustomHistoryState,\n    },\n    // All navigation requires scroll and focus management to trigger.\n    focusAndScrollRef: {\n      apply: shouldScroll\n        ? isNotUndefined(mutable?.scrollableSegments)\n          ? true\n          : state.focusAndScrollRef.apply\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          false,\n      onlyHashChange: mutable.onlyHashChange || false,\n      hashFragment: shouldScroll\n        ? // Empty hash should trigger default behavior of scrolling layout into view.\n          // #top is handled in layout-router.\n          mutable.hashFragment && mutable.hashFragment !== ''\n          ? // Remove leading # and decode hash to make non-latin hashes work.\n            decodeURIComponent(mutable.hashFragment.slice(1))\n          : state.focusAndScrollRef.hashFragment\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          null,\n      segmentPaths: shouldScroll\n        ? mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          [],\n    },\n    // Apply cache.\n    cache: mutable.cache ? mutable.cache : state.cache,\n    prefetchCache: mutable.prefetchCache\n      ? mutable.prefetchCache\n      : state.prefetchCache,\n    // Apply patched router state.\n    tree: isNotUndefined(mutable.patchedTree)\n      ? mutable.patchedTree\n      : state.tree,\n    nextUrl,\n  }\n}\n"],"names":["computeChangedPath","isNotUndefined","value","handleMutable","state","mutable","shouldScroll","nextUrl","patchedTree","changedPath","tree","canonicalUrl","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","scrollableSegments","onlyHashChange","hashFragment","decodeURIComponent","slice","segmentPaths","cache","prefetchCache"],"mappings":";;;AAAA,SAASA,kBAAkB,QAAQ,yBAAwB;;AAO3D,SAASC,eAAkBC,KAAQ;IACjC,OAAO,OAAOA,UAAU;AAC1B;AAEO,SAASC,cACdC,KAA2B,EAC3BC,OAAgB;QAGKA;IADrB,0DAA0D;IAC1D,MAAMC,eAAeD,CAAAA,wBAAAA,QAAQC,YAAY,KAAA,OAApBD,wBAAwB;IAE7C,IAAIE,UAAUH,MAAMG,OAAO;IAE3B,IAAIN,eAAeI,QAAQG,WAAW,GAAG;QACvC,sEAAsE;QACtE,MAAMC,kBAAcT,4OAAAA,EAAmBI,MAAMM,IAAI,EAAEL,QAAQG,WAAW;QACtE,IAAIC,aAAa;YACf,qDAAqD;YACrDF,UAAUE;QACZ,OAAO,IAAI,CAACF,SAAS;YACnB,6HAA6H;YAC7HA,UAAUH,MAAMO,YAAY;QAC9B;IACA,0EAA0E;IAC5E;QAyCQN;IAvCR,OAAO;QACL,YAAY;QACZM,cAAcV,eAAeI,QAAQM,YAAY,IAC7CN,QAAQM,YAAY,KAAKP,MAAMO,YAAY,GACzCP,MAAMO,YAAY,GAClBN,QAAQM,YAAY,GACtBP,MAAMO,YAAY;QACtBC,SAAS;YACPC,aAAaZ,eAAeI,QAAQQ,WAAW,IAC3CR,QAAQQ,WAAW,GACnBT,MAAMQ,OAAO,CAACC,WAAW;YAC7BC,eAAeb,eAAeI,QAAQS,aAAa,IAC/CT,QAAQS,aAAa,GACrBV,MAAMQ,OAAO,CAACE,aAAa;YAC/BC,4BAA4Bd,eAC1BI,QAAQU,0BAA0B,IAEhCV,QAAQU,0BAA0B,GAClCX,MAAMQ,OAAO,CAACG,0BAA0B;QAC9C;QACA,kEAAkE;QAClEC,mBAAmB;YACjBC,OAAOX,eACHL,eAAeI,WAAAA,OAAAA,KAAAA,IAAAA,QAASa,kBAAkB,IACxC,OACAd,MAAMY,iBAAiB,CAACC,KAAK,GAE/B;YACJE,gBAAgBd,QAAQc,cAAc,IAAI;YAC1CC,cAAcd,eAEV,AACAD,QAAQe,YAAY,IAAIf,QAAQe,IADI,QACQ,KAAK,KAE/CC,mBAAmBhB,QAAQe,YAAY,CAACE,KAAK,CAAC,MAC9ClB,MAAMY,iBAAiB,CAACI,YAAY,GAEtC;YACJG,cAAcjB,eACVD,CAAAA,8BAAAA,WAAAA,OAAAA,KAAAA,IAAAA,QAASa,kBAAkB,KAAA,OAA3Bb,8BAA+BD,MAAMY,iBAAiB,CAACO,YAAY,GAEnE,EAAE;QACR;QACA,eAAe;QACfC,OAAOnB,QAAQmB,KAAK,GAAGnB,QAAQmB,KAAK,GAAGpB,MAAMoB,KAAK;QAClDC,eAAepB,QAAQoB,aAAa,GAChCpB,QAAQoB,aAAa,GACrBrB,MAAMqB,aAAa;QACvB,8BAA8B;QAC9Bf,MAAMT,eAAeI,QAAQG,WAAW,IACpCH,QAAQG,WAAW,GACnBJ,MAAMM,IAAI;QACdH;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1281, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1287, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/ppr-navigations.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../../../server/app-render/types'\nimport type {\n  CacheNode,\n  ChildSegmentMap,\n  ReadyCacheNode,\n} from '../../../shared/lib/app-router-context.shared-runtime'\nimport { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\nexport type Task = {\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // The CacheNode that corresponds to the tree that this Task represents. If\n  // `children` is null (i.e. if this is a terminal task node), then `node`\n  // represents a brand new Cache Node tree, which way or may not need to be\n  // filled with dynamic data from the server.\n  node: CacheNode | null\n  // Whether anything in this tree contains dynamic holes that need to be filled\n  // by the server.\n  needsDynamicRequest: boolean\n  children: Map<string, Task> | null\n}\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched — due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function updateCacheNodeOnNavigation(\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: React.ReactNode | null,\n  isPrefetchHeadPartial: boolean\n): Task | null {\n  // Diff the old and new trees to reuse the shared layouts.\n  const oldRouterStateChildren = oldRouterState[1]\n  const newRouterStateChildren = newRouterState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null\n\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n\n  // Clone the current set of segment children, even if they aren't active in\n  // the new tree.\n  // TODO: We currently retain all the inactive segments indefinitely, until\n  // there's an explicit refresh, or a parent layout is lazily refreshed. We\n  // rely on this for popstate navigations, which update the Router State Tree\n  // but do not eagerly perform a data fetch, because they expect the segment\n  // data to already be in the Cache Node tree. For highly static sites that\n  // are mostly read-only, this may happen only rarely, causing memory to\n  // leak. We should figure out a better model for the lifetime of inactive\n  // segments, so we can maintain instant back/forward navigations without\n  // leaking memory indefinitely.\n  const prefetchParallelRoutes = new Map(oldParallelRoutes)\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server — for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  // Most navigations require a request to fetch additional data from the\n  // server, either because the data was not already prefetched, or because the\n  // target route contains dynamic data that cannot be prefetched.\n  //\n  // However, if the target route is fully static, and it's already completely\n  // loaded into the segment cache, then we can skip the server request.\n  //\n  // This starts off as `false`, and is set to `true` if any of the child\n  // routes requires a dynamic request.\n  let needsDynamicRequest = false\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    const newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldRouterStateChild: FlightRouterState | void =\n      oldRouterStateChildren[parallelRouteKey]\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const newSegmentChild = newRouterStateChild[0]\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n\n    const oldSegmentChild =\n      oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined\n\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    let taskChild: Task | null\n    if (newSegmentChild === DEFAULT_SEGMENT_KEY) {\n      // This is another kind of leaf segment — a default route.\n      //\n      // Default routes have special behavior. When there's no matching segment\n      // for a parallel route, Next.js preserves the currently active segment\n      // during a client navigation — but not for initial render. The server\n      // leaves it to the client to account for this. So we need to handle\n      // it here.\n      if (oldRouterStateChild !== undefined) {\n        // Reuse the existing Router State for this segment. We spawn a \"task\"\n        // just to keep track of the updated router state; unlike most, it's\n        // already fulfilled and won't be affected by the dynamic response.\n        taskChild = spawnReusedTask(oldRouterStateChild)\n      } else {\n        // There's no currently active segment. Switch to the \"create\" path.\n        taskChild = createCacheNodeOnNavigation(\n          newRouterStateChild,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          isPrefetchHeadPartial\n        )\n      }\n    } else if (\n      oldSegmentChild !== undefined &&\n      matchSegment(newSegmentChild, oldSegmentChild)\n    ) {\n      if (\n        oldCacheNodeChild !== undefined &&\n        oldRouterStateChild !== undefined\n      ) {\n        // This segment exists in both the old and new trees. Recursively update\n        // the children.\n        taskChild = updateCacheNodeOnNavigation(\n          oldCacheNodeChild,\n          oldRouterStateChild,\n          newRouterStateChild,\n          prefetchDataChild,\n          prefetchHead,\n          isPrefetchHeadPartial\n        )\n      } else {\n        // Either there's no existing Cache Node for this segment, or this\n        // segment doesn't exist in the old Router State tree. Switch to the\n        // \"create\" path.\n        taskChild = createCacheNodeOnNavigation(\n          newRouterStateChild,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          isPrefetchHeadPartial\n        )\n      }\n    } else {\n      // This is a new tree. Switch to the \"create\" path.\n      taskChild = createCacheNodeOnNavigation(\n        newRouterStateChild,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead,\n        isPrefetchHeadPartial\n      )\n    }\n\n    if (taskChild !== null) {\n      // Something changed in the child tree. Keep track of the child task.\n      if (taskChildren === null) {\n        taskChildren = new Map()\n      }\n      taskChildren.set(parallelRouteKey, taskChild)\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n        prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n\n      if (taskChild.needsDynamicRequest) {\n        needsDynamicRequest = true\n      }\n\n      // The child tree's route state may be different from the prefetched\n      // route sent by the server. We need to clone it as we traverse back up\n      // the tree.\n      patchedRouterStateChildren[parallelRouteKey] = taskChild.route\n    } else {\n      // The child didn't change. We can use the prefetched router state.\n      patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild\n    }\n  }\n\n  if (taskChildren === null) {\n    // No new tasks were spawned.\n    return null\n  }\n\n  const newCacheNode: ReadyCacheNode = {\n    lazyData: null,\n    rsc: oldCacheNode.rsc,\n    // We intentionally aren't updating the prefetchRsc field, since this node\n    // is already part of the current tree, because it would be weird for\n    // prefetch data to be newer than the final data. It probably won't ever be\n    // observable anyway, but it could happen if the segment is unmounted then\n    // mounted again, because LayoutRouter will momentarily switch to rendering\n    // prefetchRsc, via useDeferredValue.\n    prefetchRsc: oldCacheNode.prefetchRsc,\n    head: oldCacheNode.head,\n    prefetchHead: oldCacheNode.prefetchHead,\n    loading: oldCacheNode.loading,\n\n    // Everything is cloned except for the children, which we computed above.\n    parallelRoutes: prefetchParallelRoutes,\n  }\n\n  return {\n    // Return a cloned copy of the router state with updated children.\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    needsDynamicRequest,\n    children: taskChildren,\n  }\n}\n\nfunction createCacheNodeOnNavigation(\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  possiblyPartialPrefetchHead: React.ReactNode | null,\n  isPrefetchHeadPartial: boolean\n): Task {\n  // Same traversal as updateCacheNodeNavigation, but we switch to this path\n  // once we reach the part of the tree that was not in the previous route. We\n  // don't need to diff against the old tree, we just need to create a new one.\n  if (prefetchData === null) {\n    // There's no prefetch for this segment. Everything from this point will be\n    // requested from the server, even if there are static children below it.\n    // Create a terminal task node that will later be fulfilled by\n    // server response.\n    return spawnPendingTask(\n      routerState,\n      null,\n      possiblyPartialPrefetchHead,\n      isPrefetchHeadPartial\n    )\n  }\n\n  const routerStateChildren = routerState[1]\n  const isPrefetchRscPartial = prefetchData[4]\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const isLeafSegment = Object.keys(routerStateChildren).length === 0\n\n  // If prefetch data is available for a segment, and it's fully static (i.e.\n  // does not contain any dynamic holes), we don't need to request it from\n  // the server.\n  if (\n    // Check if the segment data is partial\n    isPrefetchRscPartial ||\n    // Check if the head is partial (only relevant if this is a leaf segment)\n    (isPrefetchHeadPartial && isLeafSegment)\n  ) {\n    // We only have partial data from this segment. Like missing segments, we\n    // must request the full data from the server.\n    return spawnPendingTask(\n      routerState,\n      prefetchData,\n      possiblyPartialPrefetchHead,\n      isPrefetchHeadPartial\n    )\n  }\n\n  // The prefetched segment is fully static, so we don't need to request a new\n  // one from the server. Keep traversing down the tree until we reach something\n  // that requires a dynamic request.\n  const prefetchDataChildren = prefetchData[2]\n  const taskChildren = new Map()\n  const cacheNodeChildren = new Map()\n  let needsDynamicRequest = false\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const taskChild = createCacheNodeOnNavigation(\n      routerStateChild,\n      prefetchDataChild,\n      possiblyPartialPrefetchHead,\n      isPrefetchHeadPartial\n    )\n    taskChildren.set(parallelRouteKey, taskChild)\n    if (taskChild.needsDynamicRequest) {\n      needsDynamicRequest = true\n    }\n    const newCacheNodeChild = taskChild.node\n    if (newCacheNodeChild !== null) {\n      const newSegmentMapChild: ChildSegmentMap = new Map()\n      newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n      cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild)\n    }\n  }\n\n  const rsc = prefetchData[1]\n  const loading = prefetchData[3]\n  return {\n    route: routerState,\n    node: {\n      lazyData: null,\n      // Since this is a fully static segment, we don't need to use the\n      // `prefetchRsc` field.\n      rsc,\n      prefetchRsc: null,\n      head: isLeafSegment ? possiblyPartialPrefetchHead : null,\n      prefetchHead: null,\n      loading,\n      parallelRoutes: cacheNodeChildren,\n    },\n    needsDynamicRequest,\n    children: taskChildren,\n  }\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction spawnPendingTask(\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: React.ReactNode | null,\n  isPrefetchHeadPartial: boolean\n): Task {\n  // Create a task that will later be fulfilled by data from the server.\n  const newTask: Task = {\n    route: routerState,\n\n    // Corresponds to the part of the route that will be rendered on the server.\n    node: createPendingCacheNode(\n      routerState,\n      prefetchData,\n      prefetchHead,\n      isPrefetchHeadPartial\n    ),\n    // Set this to true to indicate that this tree is missing data. This will\n    // be propagated to all the parent tasks.\n    needsDynamicRequest: true,\n    children: null,\n  }\n  return newTask\n}\n\nfunction spawnReusedTask(reusedRouterState: FlightRouterState): Task {\n  // Create a task that reuses an existing segment, e.g. when reusing\n  // the current active segment in place of a default route.\n  return {\n    route: reusedRouterState,\n    node: null,\n    needsDynamicRequest: false,\n    children: null,\n  }\n}\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for — everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function listenForDynamicRequest(\n  task: Task,\n  responsePromise: Promise<FetchServerResponseResult>\n) {\n  responsePromise.then(\n    ({ flightData }: FetchServerResponseResult) => {\n      if (typeof flightData === 'string') {\n        // Happens when navigating to page in `pages` from `app`. We shouldn't\n        // get here because should have already handled this during\n        // the prefetch.\n        return\n      }\n      for (const normalizedFlightData of flightData) {\n        const {\n          segmentPath,\n          tree: serverRouterState,\n          seedData: dynamicData,\n          head: dynamicHead,\n        } = normalizedFlightData\n\n        if (!dynamicData) {\n          // This shouldn't happen. PPR should always send back a response.\n          // However, `FlightDataPath` is a shared type and the pre-PPR handling of\n          // this might return null.\n          continue\n        }\n\n        writeDynamicDataIntoPendingTask(\n          task,\n          segmentPath,\n          serverRouterState,\n          dynamicData,\n          dynamicHead\n        )\n      }\n\n      // Now that we've exhausted all the data we received from the server, if\n      // there are any remaining pending tasks in the tree, abort them now.\n      // If there's any missing data, it will trigger a lazy fetch.\n      abortTask(task, null)\n    },\n    (error: any) => {\n      // This will trigger an error during render\n      abortTask(task, error)\n    }\n  )\n}\n\nfunction writeDynamicDataIntoPendingTask(\n  rootTask: Task,\n  segmentPath: FlightSegmentPath,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: React.ReactNode\n) {\n  // The data sent by the server represents only a subtree of the app. We need\n  // to find the part of the task tree that matches the server response, and\n  // fulfill it using the dynamic data.\n  //\n  // segmentPath represents the parent path of subtree. It's a repeating pattern\n  // of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // Iterate through the path and finish any tasks that match this payload.\n  let task = rootTask\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n    const taskChildren = task.children\n    if (taskChildren !== null) {\n      const taskChild = taskChildren.get(parallelRouteKey)\n      if (taskChild !== undefined) {\n        const taskSegment = taskChild.route[0]\n        if (matchSegment(segment, taskSegment)) {\n          // Found a match for this task. Keep traversing down the task tree.\n          task = taskChild\n          continue\n        }\n      }\n    }\n    // We didn't find a child task that matches the server data. Exit. We won't\n    // abort the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    return\n  }\n\n  finishTaskUsingDynamicDataPayload(\n    task,\n    serverRouterState,\n    dynamicData,\n    dynamicHead\n  )\n}\n\nfunction finishTaskUsingDynamicDataPayload(\n  task: Task,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: React.ReactNode\n) {\n  if (!task.needsDynamicRequest) {\n    // Everything in this subtree is already complete. Bail out.\n    return\n  }\n\n  // dynamicData may represent a larger subtree than the task. Before we can\n  // finish the task, we need to line them up.\n  const taskChildren = task.children\n  const taskNode = task.node\n  if (taskChildren === null) {\n    // We've reached the leaf node of the pending task. The server data tree\n    // lines up the pending Cache Node tree. We can now switch to the\n    // normal algorithm.\n    if (taskNode !== null) {\n      finishPendingCacheNode(\n        taskNode,\n        task.route,\n        serverRouterState,\n        dynamicData,\n        dynamicHead\n      )\n      // Set this to false to indicate that this task is now complete.\n      task.needsDynamicRequest = false\n    }\n    return\n  }\n  // The server returned more data than we need to finish the task. Skip over\n  // the extra segments until we reach the leaf task node.\n  const serverChildren = serverRouterState[1]\n  const dynamicDataChildren = dynamicData[2]\n\n  for (const parallelRouteKey in serverRouterState) {\n    const serverRouterStateChild: FlightRouterState =\n      serverChildren[parallelRouteKey]\n    const dynamicDataChild: CacheNodeSeedData | null | void =\n      dynamicDataChildren[parallelRouteKey]\n\n    const taskChild = taskChildren.get(parallelRouteKey)\n    if (taskChild !== undefined) {\n      const taskSegment = taskChild.route[0]\n      if (\n        matchSegment(serverRouterStateChild[0], taskSegment) &&\n        dynamicDataChild !== null &&\n        dynamicDataChild !== undefined\n      ) {\n        // Found a match for this task. Keep traversing down the task tree.\n        return finishTaskUsingDynamicDataPayload(\n          taskChild,\n          serverRouterStateChild,\n          dynamicDataChild,\n          dynamicHead\n        )\n      }\n    }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n  }\n}\n\nfunction createPendingCacheNode(\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: React.ReactNode | null,\n  isPrefetchHeadPartial: boolean\n): ReadyCacheNode {\n  const routerStateChildren = routerState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null\n\n  const parallelRoutes = new Map()\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const prefetchDataChild: CacheNodeSeedData | null | void =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n    const newCacheNodeChild = createPendingCacheNode(\n      routerStateChild,\n      prefetchDataChild === undefined ? null : prefetchDataChild,\n      prefetchHead,\n      isPrefetchHeadPartial\n    )\n\n    const newSegmentMapChild: ChildSegmentMap = new Map()\n    newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n    parallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n  }\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const isLeafSegment = parallelRoutes.size === 0\n  const maybePrefetchRsc = prefetchData !== null ? prefetchData[1] : null\n  const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null\n  return {\n    lazyData: null,\n    parallelRoutes: parallelRoutes,\n\n    prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n    prefetchHead: isLeafSegment ? prefetchHead : null,\n\n    // TODO: Technically, a loading boundary could contain dynamic data. We must\n    // have separate `loading` and `prefetchLoading` fields to handle this, like\n    // we do for the segment data and head.\n    loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,\n\n    // Create a deferred promise. This will be fulfilled once the dynamic\n    // response is received from the server.\n    rsc: createDeferredRsc() as React.ReactNode,\n    head: isLeafSegment ? (createDeferredRsc() as React.ReactNode) : null,\n  }\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  taskState: FlightRouterState,\n  serverState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: React.ReactNode\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety — it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n  const taskStateChildren = taskState[1]\n  const serverStateChildren = serverState[1]\n  const dataChildren = dynamicData[2]\n\n  // The router state that we traverse the tree with (taskState) is the same one\n  // that we used to construct the pending Cache Node tree. That way we're sure\n  // to resolve all the pending promises.\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in taskStateChildren) {\n    const taskStateChild: FlightRouterState =\n      taskStateChildren[parallelRouteKey]\n    const serverStateChild: FlightRouterState | void =\n      serverStateChildren[parallelRouteKey]\n    const dataChild: CacheNodeSeedData | null | void =\n      dataChildren[parallelRouteKey]\n\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    const taskSegmentChild = taskStateChild[0]\n    const taskSegmentKeyChild = createRouterCacheKey(taskSegmentChild)\n\n    const cacheNodeChild =\n      segmentMapChild !== undefined\n        ? segmentMapChild.get(taskSegmentKeyChild)\n        : undefined\n\n    if (cacheNodeChild !== undefined) {\n      if (\n        serverStateChild !== undefined &&\n        matchSegment(taskSegmentChild, serverStateChild[0])\n      ) {\n        if (dataChild !== undefined && dataChild !== null) {\n          // This is the happy path. Recursively update all the children.\n          finishPendingCacheNode(\n            cacheNodeChild,\n            taskStateChild,\n            serverStateChild,\n            dataChild,\n            dynamicHead\n          )\n        } else {\n          // The server never returned data for this segment. Trigger a lazy\n          // fetch during render. This shouldn't happen because the Route Tree\n          // and the Seed Data tree sent by the server should always be the same\n          // shape when part of the same server response.\n          abortPendingCacheNode(taskStateChild, cacheNodeChild, null)\n        }\n      } else {\n        // The server never returned data for this segment. Trigger a lazy\n        // fetch during render.\n        abortPendingCacheNode(taskStateChild, cacheNodeChild, null)\n      }\n    } else {\n      // The server response matches what was expected to receive, but there's\n      // no matching Cache Node in the task tree. This is a bug in the\n      // implementation because we should have created a node for every\n      // segment in the tree that's associated with this task.\n    }\n  }\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[1]\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead)\n  }\n}\n\nexport function abortTask(task: Task, error: any): void {\n  const cacheNode = task.node\n  if (cacheNode === null) {\n    // This indicates the task is already complete.\n    return\n  }\n\n  const taskChildren = task.children\n  if (taskChildren === null) {\n    // Reached the leaf task node. This is the root of a pending cache\n    // node tree.\n    abortPendingCacheNode(task.route, cacheNode, error)\n  } else {\n    // This is an intermediate task node. Keep traversing until we reach a\n    // task node with no children. That will be the root of the cache node tree\n    // that needs to be resolved.\n    for (const taskChild of taskChildren.values()) {\n      abortTask(taskChild, error)\n    }\n  }\n\n  // Set this to false to indicate that this task is now complete.\n  task.needsDynamicRequest = false\n}\n\nfunction abortPendingCacheNode(\n  routerState: FlightRouterState,\n  cacheNode: CacheNode,\n  error: any\n): void {\n  // For every pending segment in the tree, resolve its `rsc` promise to `null`\n  // to trigger a lazy fetch during render.\n  //\n  // Or, if an error object is provided, it will error instead.\n  const routerStateChildren = routerState[1]\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    if (segmentMapChild === undefined) {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n      continue\n    }\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const cacheNodeChild = segmentMapChild.get(segmentKeyChild)\n    if (cacheNodeChild !== undefined) {\n      abortPendingCacheNode(routerStateChild, cacheNodeChild, error)\n    } else {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n    }\n  }\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error)\n    }\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null)\n  }\n}\n\nexport function updateCacheNodeOnPopstateRestoration(\n  oldCacheNode: CacheNode,\n  routerState: FlightRouterState\n) {\n  // A popstate navigation reads data from the local cache. It does not issue\n  // new network requests (unless the cache entries have been evicted). So, we\n  // update the cache to drop the prefetch data for any segment whose dynamic\n  // data was already received. This prevents an unnecessary flash back to PPR\n  // state during a back/forward navigation.\n  //\n  // This function clones the entire cache node tree and sets the `prefetchRsc`\n  // field to `null` to prevent it from being rendered. We can't mutate the node\n  // in place because this is a concurrent data structure.\n\n  const routerStateChildren = routerState[1]\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n  const newParallelRoutes = new Map(oldParallelRoutes)\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    if (oldSegmentMapChild !== undefined) {\n      const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild)\n      if (oldCacheNodeChild !== undefined) {\n        const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(\n          oldCacheNodeChild,\n          routerStateChild\n        )\n        const newSegmentMapChild = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  // Only show prefetched data if the dynamic data is still pending.\n  //\n  // Tehnically, what we're actually checking is whether the dynamic network\n  // response was received. But since it's a streaming response, this does not\n  // mean that all the dynamic data has fully streamed in. It just means that\n  // _some_ of the dynamic data was received. But as a heuristic, we assume that\n  // the rest dynamic data will stream in quickly, so it's still better to skip\n  // the prefetch state.\n  const rsc = oldCacheNode.rsc\n  const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending'\n\n  return {\n    lazyData: null,\n    rsc,\n    head: oldCacheNode.head,\n\n    prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : null,\n    prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n    loading: oldCacheNode.loading,\n\n    // These are the cloned children we computed above\n    parallelRoutes: newParallelRoutes,\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc = Promise<React.ReactNode> & {\n  status: 'pending'\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype FulfilledDeferredRsc = Promise<React.ReactNode> & {\n  status: 'fulfilled'\n  value: React.ReactNode\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype RejectedDeferredRsc = Promise<React.ReactNode> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype DeferredRsc =\n  | PendingDeferredRsc\n  | FulfilledDeferredRsc\n  | RejectedDeferredRsc\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value: any): value is DeferredRsc {\n  return value && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc(): PendingDeferredRsc {\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<React.ReactNode>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: React.ReactNode) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  return pendingRsc\n}\n"],"names":["DEFAULT_SEGMENT_KEY","matchSegment","createRouterCacheKey","updateCacheNodeOnNavigation","oldCacheNode","oldRouterState","newRouterState","prefetchData","prefetchHead","isPrefetchHeadPartial","oldRouterStateChildren","newRouterStateChildren","prefetchDataChildren","oldParallelRoutes","parallelRoutes","prefetchParallelRoutes","Map","patchedRouterStateChildren","taskChildren","needsDynamicRequest","parallelRouteKey","newRouterStateChild","oldRouterStateChild","oldSegmentMapChild","get","prefetchDataChild","newSegmentChild","newSegmentKeyChild","oldSegmentChild","undefined","oldCacheNodeChild","taskChild","spawnReusedTask","createCacheNodeOnNavigation","set","newCacheNodeChild","node","newSegmentMapChild","route","newCacheNode","lazyData","rsc","prefetchRsc","head","loading","patchRouterStateWithNewChildren","children","routerState","possiblyPartialPrefetchHead","spawnPendingTask","routerStateChildren","isPrefetchRscPartial","isLeafSegment","Object","keys","length","cacheNodeChildren","routerStateChild","segmentChild","segmentKeyChild","baseRouterState","newChildren","clone","newTask","createPendingCacheNode","reusedRouterState","listenForDynamicRequest","task","responsePromise","then","flightData","normalizedFlightData","segmentPath","tree","serverRouterState","seedData","dynamicData","dynamicHead","writeDynamicDataIntoPendingTask","abortTask","error","rootTask","i","segment","taskSegment","finishTaskUsingDynamicDataPayload","taskNode","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","size","maybePrefetchRsc","maybePrefetchLoading","createDeferredRsc","cacheNode","taskState","serverState","taskStateChildren","serverStateChildren","dataChildren","taskStateChild","serverStateChild","dataChild","segmentMapChild","taskSegmentChild","taskSegmentKeyChild","cacheNodeChild","abortPendingCacheNode","dynamicSegmentData","isDeferredRsc","resolve","values","reject","updateCacheNodeOnPopstateRestoration","newParallelRoutes","shouldUsePrefetch","status","DEFERRED","Symbol","value","tag","pendingRsc","Promise","res","rej","fulfilledRsc","rejectedRsc","reason"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1896, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1902, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/clear-cache-node-data-for-segment-path.ts"],"sourcesContent":["import type { FlightSegmentPath } from '../../../server/app-render/types'\nimport type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\nimport { createRouterCacheKey } from './create-router-cache-key'\n\n/**\n * This will clear the CacheNode data for a particular segment path. This will cause a lazy-fetch in layout router to fill in new data.\n */\nexport function clearCacheNodeDataForSegmentPath(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightSegmentPath: FlightSegmentPath\n): void {\n  const isLastEntry = flightSegmentPath.length <= 2\n\n  const [parallelRouteKey, segment] = flightSegmentPath\n  const cacheKey = createRouterCacheKey(segment)\n\n  const existingChildSegmentMap =\n    existingCache.parallelRoutes.get(parallelRouteKey)\n\n  let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey)\n\n  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n    childSegmentMap = new Map(existingChildSegmentMap)\n    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n  }\n\n  const existingChildCacheNode = existingChildSegmentMap?.get(cacheKey)\n  let childCacheNode = childSegmentMap.get(cacheKey)\n\n  // In case of last segment start off the fetch at this level and don't copy further down.\n  if (isLastEntry) {\n    if (\n      !childCacheNode ||\n      !childCacheNode.lazyData ||\n      childCacheNode === existingChildCacheNode\n    ) {\n      childSegmentMap.set(cacheKey, {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n      })\n    }\n    return\n  }\n\n  if (!childCacheNode || !existingChildCacheNode) {\n    // Start fetch in the place where the existing cache doesn't have the data yet.\n    if (!childCacheNode) {\n      childSegmentMap.set(cacheKey, {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n      })\n    }\n    return\n  }\n\n  if (childCacheNode === existingChildCacheNode) {\n    childCacheNode = {\n      lazyData: childCacheNode.lazyData,\n      rsc: childCacheNode.rsc,\n      prefetchRsc: childCacheNode.prefetchRsc,\n      head: childCacheNode.head,\n      prefetchHead: childCacheNode.prefetchHead,\n      parallelRoutes: new Map(childCacheNode.parallelRoutes),\n      loading: childCacheNode.loading,\n    } as CacheNode\n    childSegmentMap.set(cacheKey, childCacheNode)\n  }\n\n  return clearCacheNodeDataForSegmentPath(\n    childCacheNode,\n    existingChildCacheNode,\n    getNextFlightSegmentPath(flightSegmentPath)\n  )\n}\n"],"names":["getNextFlightSegmentPath","createRouterCacheKey","clearCacheNodeDataForSegmentPath","newCache","existingCache","flightSegmentPath","isLastEntry","length","parallelRouteKey","segment","cacheKey","existingChildSegmentMap","parallelRoutes","get","childSegmentMap","Map","set","existingChildCacheNode","childCacheNode","lazyData","rsc","prefetchRsc","head","prefetchHead","loading"],"mappings":";;;AAEA,SAASA,wBAAwB,QAAQ,4BAA2B;AACpE,SAASC,oBAAoB,QAAQ,4BAA2B;;;AAKzD,SAASC,iCACdC,QAAmB,EACnBC,aAAwB,EACxBC,iBAAoC;IAEpC,MAAMC,cAAcD,kBAAkBE,MAAM,IAAI;IAEhD,MAAM,CAACC,kBAAkBC,QAAQ,GAAGJ;IACpC,MAAMK,4OAAWT,uBAAAA,EAAqBQ;IAEtC,MAAME,0BACJP,cAAcQ,cAAc,CAACC,GAAG,CAACL;IAEnC,IAAIM,kBAAkBX,SAASS,cAAc,CAACC,GAAG,CAACL;IAElD,IAAI,CAACM,mBAAmBA,oBAAoBH,yBAAyB;QACnEG,kBAAkB,IAAIC,IAAIJ;QAC1BR,SAASS,cAAc,CAACI,GAAG,CAACR,kBAAkBM;IAChD;IAEA,MAAMG,yBAAyBN,2BAAAA,OAAAA,KAAAA,IAAAA,wBAAyBE,GAAG,CAACH;IAC5D,IAAIQ,iBAAiBJ,gBAAgBD,GAAG,CAACH;IAEzC,yFAAyF;IACzF,IAAIJ,aAAa;QACf,IACE,CAACY,kBACD,CAACA,eAAeC,QAAQ,IACxBD,mBAAmBD,wBACnB;YACAH,gBAAgBE,GAAG,CAACN,UAAU;gBAC5BS,UAAU;gBACVC,KAAK;gBACLC,aAAa;gBACbC,MAAM;gBACNC,cAAc;gBACdX,gBAAgB,IAAIG;gBACpBS,SAAS;YACX;QACF;QACA;IACF;IAEA,IAAI,CAACN,kBAAkB,CAACD,wBAAwB;QAC9C,+EAA+E;QAC/E,IAAI,CAACC,gBAAgB;YACnBJ,gBAAgBE,GAAG,CAACN,UAAU;gBAC5BS,UAAU;gBACVC,KAAK;gBACLC,aAAa;gBACbC,MAAM;gBACNC,cAAc;gBACdX,gBAAgB,IAAIG;gBACpBS,SAAS;YACX;QACF;QACA;IACF;IAEA,IAAIN,mBAAmBD,wBAAwB;QAC7CC,iBAAiB;YACfC,UAAUD,eAAeC,QAAQ;YACjCC,KAAKF,eAAeE,GAAG;YACvBC,aAAaH,eAAeG,WAAW;YACvCC,MAAMJ,eAAeI,IAAI;YACzBC,cAAcL,eAAeK,YAAY;YACzCX,gBAAgB,IAAIG,IAAIG,eAAeN,cAAc;YACrDY,SAASN,eAAeM,OAAO;QACjC;QACAV,gBAAgBE,GAAG,CAACN,UAAUQ;IAChC;IAEA,OAAOhB,iCACLgB,gBACAD,+MACAjB,2BAAAA,EAAyBK;AAE7B","ignoreList":[0]}},
    {"offset": {"line": 1965, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1971, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/aliased-prefetch-navigations.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n} from '../../../server/app-render/types'\nimport type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport {\n  addSearchParamsIfPageSegment,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\nimport { createEmptyCacheNode } from '../app-router'\nimport { applyRouterStatePatchToTree } from './apply-router-state-patch-to-tree'\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport { fillCacheWithNewSubTreeDataButOnlyLoading } from './fill-cache-with-new-subtree-data'\nimport { handleMutable } from './handle-mutable'\nimport type { Mutable, ReadonlyReducerState } from './router-reducer-types'\n\n/**\n * This is a stop-gap until per-segment caching is implemented. It leverages the `aliased` flag that is added\n * to prefetch entries when it's determined that the loading state from that entry should be used for this navigation.\n * This function takes the aliased entry and only applies the loading state to the updated cache node.\n * We should remove this once per-segment fetching is implemented as ideally the prefetch cache will contain a\n * more granular segment map and so the router will be able to simply re-use the loading segment for the new navigation.\n */\nexport function handleAliasedPrefetchEntry(\n  state: ReadonlyReducerState,\n  flightData: NormalizedFlightData[],\n  url: URL,\n  mutable: Mutable\n) {\n  let currentTree = state.tree\n  let currentCache = state.cache\n  const href = createHrefFromUrl(url)\n  let applied\n\n  for (const normalizedFlightData of flightData) {\n    // If the segment doesn't have a loading component, we don't need to do anything.\n    if (!hasLoadingComponentInSeedData(normalizedFlightData.seedData)) {\n      continue\n    }\n\n    let treePatch = normalizedFlightData.tree\n    // Segments are keyed by searchParams (e.g. __PAGE__?{\"foo\":\"bar\"}). We might return a less specific, param-less entry,\n    // so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.\n    // We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set\n    treePatch = addSearchParamsToPageSegments(\n      treePatch,\n      Object.fromEntries(url.searchParams)\n    )\n\n    const { seedData, isRootRender, pathToSegment } = normalizedFlightData\n    // TODO-APP: remove ''\n    const flightSegmentPathWithLeadingEmpty = ['', ...pathToSegment]\n\n    // Segments are keyed by searchParams (e.g. __PAGE__?{\"foo\":\"bar\"}). We might return a less specific, param-less entry,\n    // so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.\n    // We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set\n    treePatch = addSearchParamsToPageSegments(\n      treePatch,\n      Object.fromEntries(url.searchParams)\n    )\n\n    let newTree = applyRouterStatePatchToTree(\n      flightSegmentPathWithLeadingEmpty,\n      currentTree,\n      treePatch,\n      href\n    )\n\n    const newCache = createEmptyCacheNode()\n\n    // The prefetch cache entry was aliased -- this signals that we only fill in the cache with the\n    // loading state and not the actual parallel route seed data.\n    if (isRootRender && seedData) {\n      // Fill in the cache with the new loading / rsc data\n      const rsc = seedData[1]\n      const loading = seedData[3]\n      newCache.loading = loading\n      newCache.rsc = rsc\n\n      // Construct a new tree and apply the aliased loading state for each parallel route\n      fillNewTreeWithOnlyLoadingSegments(\n        newCache,\n        currentCache,\n        treePatch,\n        seedData\n      )\n    } else {\n      // Copy rsc for the root node of the cache.\n      newCache.rsc = currentCache.rsc\n      newCache.prefetchRsc = currentCache.prefetchRsc\n      newCache.loading = currentCache.loading\n      newCache.parallelRoutes = new Map(currentCache.parallelRoutes)\n\n      // copy the loading state only into the leaf node (the part that changed)\n      fillCacheWithNewSubTreeDataButOnlyLoading(\n        newCache,\n        currentCache,\n        normalizedFlightData\n      )\n    }\n\n    // If we don't have an updated tree, there's no reason to update the cache, as the tree\n    // dictates what cache nodes to render.\n    if (newTree) {\n      currentTree = newTree\n      currentCache = newCache\n      applied = true\n    }\n  }\n\n  if (!applied) {\n    return false\n  }\n\n  mutable.patchedTree = currentTree\n  mutable.cache = currentCache\n  mutable.canonicalUrl = href\n  mutable.hashFragment = url.hash\n\n  return handleMutable(state, mutable)\n}\n\nfunction hasLoadingComponentInSeedData(seedData: CacheNodeSeedData | null) {\n  if (!seedData) return false\n\n  const parallelRoutes = seedData[2]\n  const loading = seedData[3]\n\n  if (loading) {\n    return true\n  }\n\n  for (const key in parallelRoutes) {\n    if (hasLoadingComponentInSeedData(parallelRoutes[key])) {\n      return true\n    }\n  }\n\n  return false\n}\n\nfunction fillNewTreeWithOnlyLoadingSegments(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  routerState: FlightRouterState,\n  cacheNodeSeedData: CacheNodeSeedData | null\n) {\n  const isLastSegment = Object.keys(routerState[1]).length === 0\n  if (isLastSegment) {\n    return\n  }\n\n  for (const key in routerState[1]) {\n    const parallelRouteState = routerState[1][key]\n    const segmentForParallelRoute = parallelRouteState[0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n\n    const parallelSeedData =\n      cacheNodeSeedData !== null && cacheNodeSeedData[2][key] !== undefined\n        ? cacheNodeSeedData[2][key]\n        : null\n\n    let newCacheNode: CacheNode\n    if (parallelSeedData !== null) {\n      // New data was sent from the server.\n      const rsc = parallelSeedData[1]\n      const loading = parallelSeedData[3]\n      newCacheNode = {\n        lazyData: null,\n        // copy the layout but null the page segment as that's not meant to be used\n        rsc: segmentForParallelRoute.includes(PAGE_SEGMENT_KEY) ? null : rsc,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading,\n      }\n    } else {\n      // No data available for this node. This will trigger a lazy fetch\n      // during render.\n      newCacheNode = {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n      }\n    }\n\n    const existingParallelRoutes = newCache.parallelRoutes.get(key)\n    if (existingParallelRoutes) {\n      existingParallelRoutes.set(cacheKey, newCacheNode)\n    } else {\n      newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]))\n    }\n\n    fillNewTreeWithOnlyLoadingSegments(\n      newCacheNode,\n      existingCache,\n      parallelRouteState,\n      parallelSeedData\n    )\n  }\n}\n\n/**\n * Add search params to the page segments in the flight router state\n * Page segments that are associated with search params have a page segment key\n * followed by a query string. This function will add those params to the page segment.\n * This is useful if we return an aliased prefetch entry (ie, won't have search params)\n * but the canonical router URL has search params.\n */\nexport function addSearchParamsToPageSegments(\n  flightRouterState: FlightRouterState,\n  searchParams: Record<string, string | string[] | undefined>\n): FlightRouterState {\n  const [segment, parallelRoutes, ...rest] = flightRouterState\n\n  // If it's a page segment, modify the segment by adding search params\n  if (segment.includes(PAGE_SEGMENT_KEY)) {\n    const newSegment = addSearchParamsIfPageSegment(segment, searchParams)\n    return [newSegment, parallelRoutes, ...rest]\n  }\n\n  // Otherwise, recurse through the parallel routes and return a new tree\n  const updatedParallelRoutes: { [key: string]: FlightRouterState } = {}\n\n  for (const [key, parallelRoute] of Object.entries(parallelRoutes)) {\n    updatedParallelRoutes[key] = addSearchParamsToPageSegments(\n      parallelRoute,\n      searchParams\n    )\n  }\n\n  return [segment, updatedParallelRoutes, ...rest]\n}\n"],"names":["addSearchParamsIfPageSegment","PAGE_SEGMENT_KEY","createEmptyCacheNode","applyRouterStatePatchToTree","createHrefFromUrl","createRouterCacheKey","fillCacheWithNewSubTreeDataButOnlyLoading","handleMutable","handleAliasedPrefetchEntry","state","flightData","url","mutable","currentTree","tree","currentCache","cache","href","applied","normalizedFlightData","hasLoadingComponentInSeedData","seedData","treePatch","addSearchParamsToPageSegments","Object","fromEntries","searchParams","isRootRender","pathToSegment","flightSegmentPathWithLeadingEmpty","newTree","newCache","rsc","loading","fillNewTreeWithOnlyLoadingSegments","prefetchRsc","parallelRoutes","Map","patchedTree","canonicalUrl","hashFragment","hash","key","existingCache","routerState","cacheNodeSeedData","isLastSegment","keys","length","parallelRouteState","segmentForParallelRoute","cacheKey","parallelSeedData","undefined","newCacheNode","lazyData","includes","head","prefetchHead","existingParallelRoutes","get","set","flightRouterState","segment","rest","newSegment","updatedParallelRoutes","parallelRoute","entries"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2140, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2146, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/navigate-reducer.ts"],"sourcesContent":["import type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../../server/app-render/types'\nimport { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { invalidateCacheBelowFlightSegmentPath } from '../invalidate-cache-below-flight-segmentpath'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { shouldHardNavigate } from '../should-hard-navigate'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport {\n  PrefetchCacheEntryStatus,\n  type Mutable,\n  type NavigateAction,\n  type ReadonlyReducerState,\n  type ReducerState,\n} from '../router-reducer-types'\nimport { handleMutable } from '../handle-mutable'\nimport { applyFlightData } from '../apply-flight-data'\nimport { prefetchQueue } from './prefetch-reducer'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\nimport {\n  listenForDynamicRequest,\n  updateCacheNodeOnNavigation,\n} from '../ppr-navigations'\nimport {\n  getOrCreatePrefetchCacheEntry,\n  prunePrefetchCache,\n} from '../prefetch-cache-utils'\nimport { clearCacheNodeDataForSegmentPath } from '../clear-cache-node-data-for-segment-path'\nimport { handleAliasedPrefetchEntry } from '../aliased-prefetch-navigations'\nimport {\n  navigate as navigateUsingSegmentCache,\n  NavigationResultTag,\n  type NavigationResult,\n} from '../../segment-cache/navigation'\n\nexport function handleExternalUrl(\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  url: string,\n  pendingPush: boolean\n) {\n  mutable.mpaNavigation = true\n  mutable.canonicalUrl = url\n  mutable.pendingPush = pendingPush\n  mutable.scrollableSegments = undefined\n\n  return handleMutable(state, mutable)\n}\n\nfunction generateSegmentsFromPatch(\n  flightRouterPatch: FlightRouterState\n): FlightSegmentPath[] {\n  const segments: FlightSegmentPath[] = []\n  const [segment, parallelRoutes] = flightRouterPatch\n\n  if (Object.keys(parallelRoutes).length === 0) {\n    return [[segment]]\n  }\n\n  for (const [parallelRouteKey, parallelRoute] of Object.entries(\n    parallelRoutes\n  )) {\n    for (const childSegment of generateSegmentsFromPatch(parallelRoute)) {\n      // If the segment is empty, it means we are at the root of the tree\n      if (segment === '') {\n        segments.push([parallelRouteKey, ...childSegment])\n      } else {\n        segments.push([segment, parallelRouteKey, ...childSegment])\n      }\n    }\n  }\n\n  return segments\n}\n\nfunction triggerLazyFetchForLeafSegments(\n  newCache: CacheNode,\n  currentCache: CacheNode,\n  flightSegmentPath: FlightSegmentPath,\n  treePatch: FlightRouterState\n) {\n  let appliedPatch = false\n\n  newCache.rsc = currentCache.rsc\n  newCache.prefetchRsc = currentCache.prefetchRsc\n  newCache.loading = currentCache.loading\n  newCache.parallelRoutes = new Map(currentCache.parallelRoutes)\n\n  const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map(\n    (segment) => [...flightSegmentPath, ...segment]\n  )\n\n  for (const segmentPaths of segmentPathsToFill) {\n    clearCacheNodeDataForSegmentPath(newCache, currentCache, segmentPaths)\n\n    appliedPatch = true\n  }\n\n  return appliedPatch\n}\n\nfunction handleNavigationResult(\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  pendingPush: boolean,\n  result: NavigationResult\n): ReducerState {\n  switch (result.tag) {\n    case NavigationResultTag.MPA: {\n      // Perform an MPA navigation.\n      const newUrl = result.data\n      return handleExternalUrl(state, mutable, newUrl, pendingPush)\n    }\n    case NavigationResultTag.NoOp:\n      // The server responded with no change to the current page.\n      return handleMutable(state, mutable)\n    case NavigationResultTag.Success: {\n      // Received a new result.\n      mutable.cache = result.data.cacheNode\n      mutable.patchedTree = result.data.flightRouterState\n      mutable.canonicalUrl = result.data.canonicalUrl\n      // TODO: Not yet implemented\n      // mutable.scrollableSegments = scrollableSegments\n      // mutable.hashFragment = hash\n      // mutable.shouldScroll = shouldScroll\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Async: {\n      return result.data.then(\n        (asyncResult) =>\n          handleNavigationResult(state, mutable, pendingPush, asyncResult),\n        // If the navigation failed, return the current state.\n        // TODO: This matches the current behavior but we need to do something\n        // better here if the network fails.\n        () => {\n          return state\n        }\n      )\n    }\n    default:\n      const _exhaustiveCheck: never = result\n      return state\n  }\n}\n\nexport function navigateReducer(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll, allowAliasing } =\n    action\n  const mutable: Mutable = {}\n  const { hash } = url\n  const href = createHrefFromUrl(url)\n  const pendingPush = navigateType === 'push'\n  // we want to prune the prefetch cache on every navigation to avoid it growing too large\n  prunePrefetchCache(state.prefetchCache)\n\n  mutable.preserveCustomHistoryState = false\n  mutable.pendingPush = pendingPush\n\n  if (isExternalUrl) {\n    return handleExternalUrl(state, mutable, url.toString(), pendingPush)\n  }\n\n  // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n  // which will trigger an MPA navigation.\n  if (document.getElementById('__next-page-redirect')) {\n    return handleExternalUrl(state, mutable, href, pendingPush)\n  }\n\n  if (process.env.__NEXT_PPR && process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n    // (Very Early Experimental Feature) Segment Cache\n    //\n    // Bypass the normal prefetch cache and use the new per-segment cache\n    // implementation instead. This is only supported if PPR is enabled, too.\n    //\n    // Temporary glue code between the router reducer and the new navigation\n    // implementation. Eventually we'll rewrite the router reducer to a\n    // state machine.\n    // TODO: Currently this always returns an async result, but in the future\n    // it will return a sync result if the navigation was prefetched. Hence\n    // a result type that's more complicated than you might expect.\n    const result = navigateUsingSegmentCache(\n      url,\n      state.cache,\n      state.tree,\n      state.nextUrl\n    )\n    return handleNavigationResult(state, mutable, pendingPush, result)\n  }\n\n  const prefetchValues = getOrCreatePrefetchCacheEntry({\n    url,\n    nextUrl: state.nextUrl,\n    tree: state.tree,\n    prefetchCache: state.prefetchCache,\n    allowAliasing,\n  })\n  const { treeAtTimeOfPrefetch, data } = prefetchValues\n\n  prefetchQueue.bump(data)\n\n  return data.then(\n    ({ flightData, canonicalUrl: canonicalUrlOverride, postponed }) => {\n      let isFirstRead = false\n      // we only want to mark this once\n      if (!prefetchValues.lastUsedTime) {\n        // important: we should only mark the cache node as dirty after we unsuspend from the call above\n        prefetchValues.lastUsedTime = Date.now()\n        isFirstRead = true\n      }\n\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(state, mutable, flightData, pendingPush)\n      }\n\n      const updatedCanonicalUrl = canonicalUrlOverride\n        ? createHrefFromUrl(canonicalUrlOverride)\n        : href\n\n      const onlyHashChange =\n        !!hash &&\n        state.canonicalUrl.split('#', 1)[0] ===\n          updatedCanonicalUrl.split('#', 1)[0]\n\n      // If only the hash has changed, the server hasn't sent us any new data. We can just update\n      // the mutable properties responsible for URL and scroll handling and return early.\n      if (onlyHashChange) {\n        mutable.onlyHashChange = true\n        mutable.canonicalUrl = updatedCanonicalUrl\n        mutable.shouldScroll = shouldScroll\n        mutable.hashFragment = hash\n        mutable.scrollableSegments = []\n        return handleMutable(state, mutable)\n      }\n\n      if (prefetchValues.aliased) {\n        const result = handleAliasedPrefetchEntry(\n          state,\n          flightData,\n          url,\n          mutable\n        )\n\n        // We didn't return new router state because we didn't apply the aliased entry for some reason.\n        // We'll re-invoke the navigation handler but ensure that we don't attempt to use the aliased entry. This\n        // will create an on-demand prefetch entry.\n        if (result === false) {\n          return navigateReducer(state, { ...action, allowAliasing: false })\n        }\n\n        return result\n      }\n\n      let currentTree = state.tree\n      let currentCache = state.cache\n      let scrollableSegments: FlightSegmentPath[] = []\n      for (const normalizedFlightData of flightData) {\n        const {\n          pathToSegment: flightSegmentPath,\n          seedData,\n          head,\n          isHeadPartial,\n          isRootRender,\n        } = normalizedFlightData\n        let treePatch = normalizedFlightData.tree\n\n        // TODO-APP: remove ''\n        const flightSegmentPathWithLeadingEmpty = ['', ...flightSegmentPath]\n\n        // Create new tree based on the flightSegmentPath and router state patch\n        let newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          flightSegmentPathWithLeadingEmpty,\n          currentTree,\n          treePatch,\n          href\n        )\n\n        // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n        // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n        if (newTree === null) {\n          newTree = applyRouterStatePatchToTree(\n            // TODO-APP: remove ''\n            flightSegmentPathWithLeadingEmpty,\n            treeAtTimeOfPrefetch,\n            treePatch,\n            href\n          )\n        }\n\n        if (newTree !== null) {\n          if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n            return handleExternalUrl(state, mutable, href, pendingPush)\n          }\n\n          if (\n            // This is just a paranoid check. When a route is PPRed, the server\n            // will send back a static response that's rendered from\n            // the root. If for some reason it doesn't, we fall back to the\n            // non-PPR implementation.\n            // TODO: We should get rid of the else branch and do all navigations\n            // via updateCacheNodeOnNavigation. The current structure is just\n            // an incremental step.\n            seedData &&\n            isRootRender &&\n            postponed\n          ) {\n            const task = updateCacheNodeOnNavigation(\n              currentCache,\n              currentTree,\n              treePatch,\n              seedData,\n              head,\n              isHeadPartial\n            )\n\n            if (task !== null) {\n              // Use the tree computed by updateCacheNodeOnNavigation instead\n              // of the one computed by applyRouterStatePatchToTree.\n              // TODO: We should remove applyRouterStatePatchToTree\n              // from the PPR path entirely.\n              const patchedRouterState: FlightRouterState = task.route\n              newTree = patchedRouterState\n\n              const newCache = task.node\n              if (newCache !== null) {\n                // We've created a new Cache Node tree that contains a prefetched\n                // version of the next page. This can be rendered instantly.\n                mutable.cache = newCache\n              }\n              if (task.needsDynamicRequest) {\n                // The prefetched tree has dynamic holes in it. We initiate a\n                // dynamic request to fill them in.\n                //\n                // Do not block on the result. We'll immediately render the Cache\n                // Node tree and suspend on the dynamic parts. When the request\n                // comes in, we'll fill in missing data and ping React to\n                // re-render. Unlike the lazy fetching model in the non-PPR\n                // implementation, this is modeled as a single React update +\n                // streaming, rather than multiple top-level updates. (However,\n                // even in the new model, we'll still need to sometimes update the\n                // root multiple times per navigation, like if the server sends us\n                // a different response than we expected. For now, we revert back\n                // to the lazy fetching mechanism in that case.)\n                const dynamicRequest = fetchServerResponse(url, {\n                  flightRouterState: currentTree,\n                  nextUrl: state.nextUrl,\n                })\n\n                listenForDynamicRequest(task, dynamicRequest)\n                // We store the dynamic request on the `lazyData` property of the CacheNode\n                // because we're not going to await the dynamic request here. Since we're not blocking\n                // on the dynamic request, `layout-router` will\n                // task.node.lazyData = dynamicRequest\n              } else {\n                // The prefetched tree does not contain dynamic holes — it's\n                // fully static. We can skip the dynamic request.\n              }\n            } else {\n              // Nothing changed, so reuse the old cache.\n              // TODO: What if the head changed but not any of the segment data?\n              // Is that possible? If so, we should clone the whole tree and\n              // update the head.\n              newTree = treePatch\n            }\n          } else {\n            // The static response does not include any dynamic holes, so\n            // there's no need to do a second request.\n            // TODO: As an incremental step this just reverts back to the\n            // non-PPR implementation. We can simplify this branch further,\n            // given that PPR prefetches are always static and return the whole\n            // tree. Or in the meantime we could factor it out into a\n            // separate function.\n            const cache: CacheNode = createEmptyCacheNode()\n            let applied = false\n\n            if (\n              prefetchValues.status === PrefetchCacheEntryStatus.stale &&\n              !isFirstRead\n            ) {\n              // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n              // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n              // while copying over the `loading` for the segment that contains the page data.\n              // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n\n              // We skip this branch if only the hash fragment has changed, as we don't want to trigger a lazy fetch in that case\n              applied = triggerLazyFetchForLeafSegments(\n                cache,\n                currentCache,\n                flightSegmentPath,\n                treePatch\n              )\n              // since we re-used the stale cache's loading state & refreshed the data,\n              // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n              prefetchValues.lastUsedTime = Date.now()\n            } else {\n              applied = applyFlightData(\n                currentCache,\n                cache,\n                normalizedFlightData,\n                prefetchValues\n              )\n            }\n\n            const hardNavigate = shouldHardNavigate(\n              // TODO-APP: remove ''\n              flightSegmentPathWithLeadingEmpty,\n              currentTree\n            )\n\n            if (hardNavigate) {\n              // Copy rsc for the root node of the cache.\n              cache.rsc = currentCache.rsc\n              cache.prefetchRsc = currentCache.prefetchRsc\n\n              invalidateCacheBelowFlightSegmentPath(\n                cache,\n                currentCache,\n                flightSegmentPath\n              )\n              // Ensure the existing cache value is used when the cache was not invalidated.\n              mutable.cache = cache\n            } else if (applied) {\n              mutable.cache = cache\n              // If we applied the cache, we update the \"current cache\" value so any other\n              // segments in the FlightDataPath will be able to reference the updated cache.\n              currentCache = cache\n            }\n          }\n\n          currentTree = newTree\n\n          for (const subSegment of generateSegmentsFromPatch(treePatch)) {\n            const scrollableSegmentPath = [...flightSegmentPath, ...subSegment]\n            // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n            if (\n              scrollableSegmentPath[scrollableSegmentPath.length - 1] !==\n              DEFAULT_SEGMENT_KEY\n            ) {\n              scrollableSegments.push(scrollableSegmentPath)\n            }\n          }\n        }\n      }\n\n      mutable.patchedTree = currentTree\n      mutable.canonicalUrl = updatedCanonicalUrl\n      mutable.scrollableSegments = scrollableSegments\n      mutable.hashFragment = hash\n      mutable.shouldScroll = shouldScroll\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n"],"names":["fetchServerResponse","createHrefFromUrl","invalidateCacheBelowFlightSegmentPath","applyRouterStatePatchToTree","shouldHardNavigate","isNavigatingToNewRootLayout","PrefetchCacheEntryStatus","handleMutable","applyFlightData","prefetchQueue","createEmptyCacheNode","DEFAULT_SEGMENT_KEY","listenForDynamicRequest","updateCacheNodeOnNavigation","getOrCreatePrefetchCacheEntry","prunePrefetchCache","clearCacheNodeDataForSegmentPath","handleAliasedPrefetchEntry","navigate","navigateUsingSegmentCache","NavigationResultTag","handleExternalUrl","state","mutable","url","pendingPush","mpaNavigation","canonicalUrl","scrollableSegments","undefined","generateSegmentsFromPatch","flightRouterPatch","segments","segment","parallelRoutes","Object","keys","length","parallelRouteKey","parallelRoute","entries","childSegment","push","triggerLazyFetchForLeafSegments","newCache","currentCache","flightSegmentPath","treePatch","appliedPatch","rsc","prefetchRsc","loading","Map","segmentPathsToFill","map","segmentPaths","handleNavigationResult","result","tag","MPA","newUrl","data","NoOp","Success","cache","cacheNode","patchedTree","flightRouterState","Async","then","asyncResult","_exhaustiveCheck","navigateReducer","action","isExternalUrl","navigateType","shouldScroll","allowAliasing","hash","href","prefetchCache","preserveCustomHistoryState","toString","document","getElementById","process","env","__NEXT_PPR","__NEXT_CLIENT_SEGMENT_CACHE","tree","nextUrl","prefetchValues","treeAtTimeOfPrefetch","bump","flightData","canonicalUrlOverride","postponed","isFirstRead","lastUsedTime","Date","now","updatedCanonicalUrl","onlyHashChange","split","hashFragment","aliased","currentTree","normalizedFlightData","pathToSegment","seedData","head","isHeadPartial","isRootRender","flightSegmentPathWithLeadingEmpty","newTree","task","patchedRouterState","route","node","needsDynamicRequest","dynamicRequest","applied","status","stale","hardNavigate","subSegment","scrollableSegmentPath"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2476, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2482, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/server-patch-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  ServerPatchAction,\n  ReducerState,\n  ReadonlyReducerState,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyFlightData } from '../apply-flight-data'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { createEmptyCacheNode } from '../../app-router'\n\nexport function serverPatchReducer(\n  state: ReadonlyReducerState,\n  action: ServerPatchAction\n): ReducerState {\n  const {\n    serverResponse: { flightData, canonicalUrl: canonicalUrlOverride },\n  } = action\n\n  const mutable: Mutable = {}\n\n  mutable.preserveCustomHistoryState = false\n\n  // Handle case when navigating to page in `pages` from `app`\n  if (typeof flightData === 'string') {\n    return handleExternalUrl(\n      state,\n      mutable,\n      flightData,\n      state.pushRef.pendingPush\n    )\n  }\n\n  let currentTree = state.tree\n  let currentCache = state.cache\n\n  for (const normalizedFlightData of flightData) {\n    const { segmentPath: flightSegmentPath, tree: treePatch } =\n      normalizedFlightData\n\n    const newTree = applyRouterStatePatchToTree(\n      // TODO-APP: remove ''\n      ['', ...flightSegmentPath],\n      currentTree,\n      treePatch,\n      state.canonicalUrl\n    )\n\n    // `applyRouterStatePatchToTree` returns `null` when it determined that the server response is not applicable to the current tree.\n    // In other words, the server responded with a tree that doesn't match what the client is currently rendering.\n    // This can happen if the server patch action took longer to resolve than a subsequent navigation which would have changed the tree.\n    // Previously this case triggered an MPA navigation but it should be safe to simply discard the server response rather than forcing\n    // the entire page to reload.\n    if (newTree === null) {\n      return state\n    }\n\n    if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n      return handleExternalUrl(\n        state,\n        mutable,\n        state.canonicalUrl,\n        state.pushRef.pendingPush\n      )\n    }\n\n    const canonicalUrlOverrideHref = canonicalUrlOverride\n      ? createHrefFromUrl(canonicalUrlOverride)\n      : undefined\n\n    if (canonicalUrlOverrideHref) {\n      mutable.canonicalUrl = canonicalUrlOverrideHref\n    }\n\n    const cache: CacheNode = createEmptyCacheNode()\n    applyFlightData(currentCache, cache, normalizedFlightData)\n\n    mutable.patchedTree = newTree\n    mutable.cache = cache\n\n    currentCache = cache\n    currentTree = newTree\n  }\n\n  return handleMutable(state, mutable)\n}\n"],"names":["createHrefFromUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleExternalUrl","applyFlightData","handleMutable","createEmptyCacheNode","serverPatchReducer","state","action","serverResponse","flightData","canonicalUrl","canonicalUrlOverride","mutable","preserveCustomHistoryState","pushRef","pendingPush","currentTree","tree","currentCache","cache","normalizedFlightData","segmentPath","flightSegmentPath","treePatch","newTree","canonicalUrlOverrideHref","undefined","patchedTree"],"mappings":";;;AAAA,SAASA,iBAAiB,QAAQ,0BAAyB;AAC3D,SAASC,2BAA2B,QAAQ,sCAAqC;AACjF,SAASC,2BAA2B,QAAQ,sCAAqC;AAOjF,SAASC,iBAAiB,QAAQ,qBAAoB;AACtD,SAASC,eAAe,QAAQ,uBAAsB;AACtD,SAASC,aAAa,QAAQ,oBAAmB;AAEjD,SAASC,oBAAoB,QAAQ,mBAAkB;;;;;;;;AAEhD,SAASC,mBACdC,KAA2B,EAC3BC,MAAyB;IAEzB,MAAM,EACJC,gBAAgB,EAAEC,UAAU,EAAEC,cAAcC,oBAAoB,EAAE,EACnE,GAAGJ;IAEJ,MAAMK,UAAmB,CAAC;IAE1BA,QAAQC,0BAA0B,GAAG;IAErC,4DAA4D;IAC5D,IAAI,OAAOJ,eAAe,UAAU;QAClC,uOAAOR,oBAAAA,EACLK,OACAM,SACAH,YACAH,MAAMQ,OAAO,CAACC,WAAW;IAE7B;IAEA,IAAIC,cAAcV,MAAMW,IAAI;IAC5B,IAAIC,eAAeZ,MAAMa,KAAK;IAE9B,KAAK,MAAMC,wBAAwBX,WAAY;QAC7C,MAAM,EAAEY,aAAaC,iBAAiB,EAAEL,MAAMM,SAAS,EAAE,GACvDH;QAEF,MAAMI,WAAUzB,6QAAAA,CACd,CACA,qBADsB;YACrB;eAAOuB;SAAkB,EAC1BN,aACAO,WACAjB,MAAMI,YAAY;QAGpB,kIAAkI;QAClI,8GAA8G;QAC9G,oIAAoI;QACpI,mIAAmI;QACnI,6BAA6B;QAC7B,IAAIc,YAAY,MAAM;YACpB,OAAOlB;QACT;QAEA,IAAIN,8QAAAA,EAA4BgB,aAAaQ,UAAU;YACrD,uOAAOvB,oBAAAA,EACLK,OACAM,SACAN,MAAMI,YAAY,EAClBJ,MAAMQ,OAAO,CAACC,WAAW;QAE7B;QAEA,MAAMU,2BAA2Bd,qPAC7Bb,oBAAAA,EAAkBa,wBAClBe;QAEJ,IAAID,0BAA0B;YAC5Bb,QAAQF,YAAY,GAAGe;QACzB;QAEA,MAAMN,iMAAmBf,uBAAAA;gOACzBF,kBAAAA,EAAgBgB,cAAcC,OAAOC;QAErCR,QAAQe,WAAW,GAAGH;QACtBZ,QAAQO,KAAK,GAAGA;QAEhBD,eAAeC;QACfH,cAAcQ;IAChB;IAEA,yNAAOrB,gBAAAA,EAAcG,OAAOM;AAC9B","ignoreList":[0]}},
    {"offset": {"line": 2539, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2545, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/restore-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  RestoreAction,\n} from '../router-reducer-types'\nimport { extractPathFromFlightRouterState } from '../compute-changed-path'\nimport { updateCacheNodeOnPopstateRestoration } from '../ppr-navigations'\n\nexport function restoreReducer(\n  state: ReadonlyReducerState,\n  action: RestoreAction\n): ReducerState {\n  const { url, tree } = action\n  const href = createHrefFromUrl(url)\n  // This action is used to restore the router state from the history state.\n  // However, it's possible that the history state no longer contains the `FlightRouterState`.\n  // We will copy over the internal state on pushState/replaceState events, but if a history entry\n  // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n  // the history state will not contain the `FlightRouterState`.\n  // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n  const treeToRestore = tree || state.tree\n\n  const oldCache = state.cache\n  const newCache = process.env.__NEXT_PPR\n    ? // When PPR is enabled, we update the cache to drop the prefetch\n      // data for any segment whose dynamic data was already received. This\n      // prevents an unnecessary flash back to PPR state during a\n      // back/forward navigation.\n      updateCacheNodeOnPopstateRestoration(oldCache, treeToRestore)\n    : oldCache\n\n  return {\n    // Set canonical url\n    canonicalUrl: href,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // Ensures that the custom history state that was set is preserved when applying this update.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache: newCache,\n    prefetchCache: state.prefetchCache,\n    // Restore provided tree\n    tree: treeToRestore,\n    nextUrl: extractPathFromFlightRouterState(treeToRestore) ?? url.pathname,\n  }\n}\n"],"names":["createHrefFromUrl","extractPathFromFlightRouterState","updateCacheNodeOnPopstateRestoration","restoreReducer","state","action","url","tree","href","treeToRestore","oldCache","cache","newCache","process","env","__NEXT_PPR","canonicalUrl","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","prefetchCache","nextUrl","pathname"],"mappings":";;;AAAA,SAASA,iBAAiB,QAAQ,0BAAyB;AAM3D,SAASC,gCAAgC,QAAQ,0BAAyB;AAC1E,SAASC,oCAAoC,QAAQ,qBAAoB;;;;AAElE,SAASC,eACdC,KAA2B,EAC3BC,MAAqB;IAErB,MAAM,EAAEC,GAAG,EAAEC,IAAI,EAAE,GAAGF;IACtB,MAAMG,qOAAOR,oBAAAA,EAAkBM;IAC/B,0EAA0E;IAC1E,4FAA4F;IAC5F,gGAAgG;IAChG,6FAA6F;IAC7F,8DAA8D;IAC9D,yGAAyG;IACzG,MAAMG,gBAAgBF,QAAQH,MAAMG,IAAI;IAExC,MAAMG,WAAWN,MAAMO,KAAK;IAC5B,MAAMC,WAAWC,QAAQC,GAAG,CAACC,UAAU,GAEnC,oDAIAL,iBAJqE;QAoB9DT;IAdX,OAAO;QACL,oBAAoB;QACpBe,cAAcR;QACdS,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,6FAA6F;YAC7FC,4BAA4B;QAC9B;QACAC,mBAAmBjB,MAAMiB,iBAAiB;QAC1CV,OAAOC;QACPU,eAAelB,MAAMkB,aAAa;QAClC,wBAAwB;QACxBf,MAAME;QACNc,SAAStB,CAAAA,+PAAAA,mCAAAA,EAAiCQ,cAAAA,KAAAA,OAAjCR,oCAAmDK,IAAIkB,QAAQ;IAC1E;AACF","ignoreList":[0]}},
    {"offset": {"line": 2584, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2590, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/handle-segment-mismatch.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../server/app-render/types'\nimport { handleExternalUrl } from './reducers/navigate-reducer'\nimport type {\n  ReadonlyReducerState,\n  ReducerActions,\n} from './router-reducer-types'\n\n/**\n * Handles the case where the client router attempted to patch the tree but, due to a mismatch, the patch failed.\n * This will perform an MPA navigation to return the router to a valid state.\n */\nexport function handleSegmentMismatch(\n  state: ReadonlyReducerState,\n  action: ReducerActions,\n  treePatch: FlightRouterState\n) {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(\n      'Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.\\n\\n' +\n        'Reason: Segment mismatch\\n' +\n        `Last Action: ${action.type}\\n\\n` +\n        `Current Tree: ${JSON.stringify(state.tree)}\\n\\n` +\n        `Tree Patch Payload: ${JSON.stringify(treePatch)}`\n    )\n  }\n\n  return handleExternalUrl(state, {}, state.canonicalUrl, true)\n}\n"],"names":["handleExternalUrl","handleSegmentMismatch","state","action","treePatch","process","env","NODE_ENV","console","warn","type","JSON","stringify","tree","canonicalUrl"],"mappings":";;;AACA,SAASA,iBAAiB,QAAQ,8BAA6B;;AAUxD,SAASC,sBACdC,KAA2B,EAC3BC,MAAsB,EACtBC,SAA4B;IAE5B,IAAIC,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAe;QAC1CC,QAAQC,IAAI,CACV,sJACE,+BACA,CAAC,kBAAeN,OAAOO,IAAI,GAAC,MAAI,IAChC,CAAC,mBAAgBC,KAAKC,SAAS,CAACV,MAAMW,IAAI,IAAE,MAAI,IAChD,CAAC,yBAAsBF,KAAKC,SAAS,CAACR,UAAW;IAEvD;IAEA,uOAAOJ,oBAAAA,EAAkBE,OAAO,CAAC,GAAGA,MAAMY,YAAY,EAAE;AAC1D","ignoreList":[0]}},
    {"offset": {"line": 2601, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2607, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../../server/app-render/types'\nimport { isInterceptionRouteAppPath } from '../../../../server/lib/interception-routes'\n\nexport function hasInterceptionRouteInCurrentTree([\n  segment,\n  parallelRoutes,\n]: FlightRouterState): boolean {\n  // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n  if (Array.isArray(segment) && (segment[2] === 'di' || segment[2] === 'ci')) {\n    return true\n  }\n\n  // If segment is not an array, apply the existing string-based check\n  if (typeof segment === 'string' && isInterceptionRouteAppPath(segment)) {\n    return true\n  }\n\n  // Iterate through parallelRoutes if they exist\n  if (parallelRoutes) {\n    for (const key in parallelRoutes) {\n      if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n"],"names":["isInterceptionRouteAppPath","hasInterceptionRouteInCurrentTree","segment","parallelRoutes","Array","isArray","key"],"mappings":";;;AACA,SAASA,0BAA0B,QAAQ,6CAA4C;;AAEhF,SAASC,kCAAkC,KAG9B;IAH8B,IAAA,CAChDC,SACAC,eACkB,GAH8B;IAIhD,wGAAwG;IACxG,IAAIC,MAAMC,OAAO,CAACH,YAAaA,CAAAA,OAAO,CAAC,EAAE,KAAK,QAAQA,OAAO,CAAC,EAAE,KAAK,IAAG,GAAI;QAC1E,OAAO;IACT;IAEA,oEAAoE;IACpE,IAAI,OAAOA,YAAY,aAAYF,uNAAAA,EAA2BE,UAAU;QACtE,OAAO;IACT;IAEA,+CAA+C;IAC/C,IAAIC,gBAAgB;QAClB,IAAK,MAAMG,OAAOH,eAAgB;YAChC,IAAIF,kCAAkCE,cAAc,CAACG,IAAI,GAAG;gBAC1D,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 2632, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2638, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/refresh-reducer.ts"],"sourcesContent":["import { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n  RefreshAction,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\n\nexport function refreshReducer(\n  state: ReadonlyReducerState,\n  action: RefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  cache.lazyData = fetchServerResponse(new URL(href, origin), {\n    flightRouterState: [\n      currentTree[0],\n      currentTree[1],\n      currentTree[2],\n      'refetch',\n    ],\n    nextUrl: includeNextUrl ? state.nextUrl : null,\n  })\n\n  return cache.lazyData.then(\n    async ({ flightData, canonicalUrl: canonicalUrlOverride }) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      for (const normalizedFlightData of flightData) {\n        const {\n          tree: treePatch,\n          seedData: cacheNodeSeedData,\n          head,\n          isRootRender,\n        } = normalizedFlightData\n\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        const canonicalUrlOverrideHref = canonicalUrlOverride\n          ? createHrefFromUrl(canonicalUrlOverride)\n          : undefined\n\n        if (canonicalUrlOverride) {\n          mutable.canonicalUrl = canonicalUrlOverrideHref\n        }\n\n        // Handles case where prefetch only returns the router tree patch without rendered components.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[1]\n          const loading = cacheNodeSeedData[3]\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          cache.loading = loading\n          fillLazyItemsTillLeafWithHead(\n            cache,\n            // Existing cache is not passed in as `router.refresh()` has to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head\n          )\n          mutable.prefetchCache = new Map()\n        }\n\n        await refreshInactiveParallelSegments({\n          state,\n          updatedTree: newTree,\n          updatedCache: cache,\n          includeNextUrl,\n          canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n        })\n\n        mutable.cache = cache\n        mutable.patchedTree = newTree\n\n        currentTree = newTree\n      }\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n"],"names":["fetchServerResponse","createHrefFromUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleExternalUrl","handleMutable","fillLazyItemsTillLeafWithHead","createEmptyCacheNode","handleSegmentMismatch","hasInterceptionRouteInCurrentTree","refreshInactiveParallelSegments","refreshReducer","state","action","origin","mutable","href","canonicalUrl","currentTree","tree","preserveCustomHistoryState","cache","includeNextUrl","lazyData","URL","flightRouterState","nextUrl","then","flightData","canonicalUrlOverride","pushRef","pendingPush","normalizedFlightData","treePatch","seedData","cacheNodeSeedData","head","isRootRender","console","log","newTree","canonicalUrlOverrideHref","undefined","rsc","loading","prefetchRsc","prefetchCache","Map","updatedTree","updatedCache","patchedTree"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2736, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2742, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/hmr-refresh-reducer.ts"],"sourcesContent":["import { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  HmrRefreshAction,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport { applyFlightData } from '../apply-flight-data'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\n\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(\n  state: ReadonlyReducerState,\n  action: HmrRefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  cache.lazyData = fetchServerResponse(new URL(href, origin), {\n    flightRouterState: [state.tree[0], state.tree[1], state.tree[2], 'refetch'],\n    nextUrl: includeNextUrl ? state.nextUrl : null,\n    isHmrRefresh: true,\n  })\n\n  return cache.lazyData.then(\n    ({ flightData, canonicalUrl: canonicalUrlOverride }) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      let currentTree = state.tree\n      let currentCache = state.cache\n\n      for (const normalizedFlightData of flightData) {\n        const { tree: treePatch, isRootRender } = normalizedFlightData\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        const canonicalUrlOverrideHref = canonicalUrlOverride\n          ? createHrefFromUrl(canonicalUrlOverride)\n          : undefined\n\n        if (canonicalUrlOverride) {\n          mutable.canonicalUrl = canonicalUrlOverrideHref\n        }\n        const applied = applyFlightData(\n          currentCache,\n          cache,\n          normalizedFlightData\n        )\n\n        if (applied) {\n          mutable.cache = cache\n          currentCache = cache\n        }\n\n        mutable.patchedTree = newTree\n        mutable.canonicalUrl = href\n\n        currentTree = newTree\n      }\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n\nfunction hmrRefreshReducerNoop(\n  state: ReadonlyReducerState,\n  _action: HmrRefreshAction\n): ReducerState {\n  return state\n}\n\nexport const hmrRefreshReducer =\n  process.env.NODE_ENV === 'production'\n    ? hmrRefreshReducerNoop\n    : hmrRefreshReducerImpl\n"],"names":["fetchServerResponse","createHrefFromUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleExternalUrl","handleMutable","applyFlightData","createEmptyCacheNode","handleSegmentMismatch","hasInterceptionRouteInCurrentTree","hmrRefreshReducerImpl","state","action","origin","mutable","href","canonicalUrl","preserveCustomHistoryState","cache","includeNextUrl","tree","lazyData","URL","flightRouterState","nextUrl","isHmrRefresh","then","flightData","canonicalUrlOverride","pushRef","pendingPush","currentTree","currentCache","normalizedFlightData","treePatch","isRootRender","console","log","newTree","canonicalUrlOverrideHref","undefined","applied","patchedTree","hmrRefreshReducerNoop","_action","hmrRefreshReducer","process","env","NODE_ENV"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2833, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2839, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/server-reference-info.ts"],"sourcesContent":["export interface ServerReferenceInfo {\n  type: 'server-action' | 'use-cache'\n  usedArgs: [boolean, boolean, boolean, boolean, boolean, boolean]\n  hasRestArgs: boolean\n}\n\n/**\n * Extracts info about the server reference for the given server reference ID by\n * parsing the first byte of the hex-encoded ID.\n *\n * ```\n * Bit positions: [7]      [6] [5] [4] [3] [2] [1]  [0]\n * Bits:          typeBit  argMask                  restArgs\n * ```\n *\n * If the `typeBit` is `1` the server reference represents a `\"use cache\"`\n * function, otherwise a server action.\n *\n * The `argMask` encodes whether the function uses the argument at the\n * respective position.\n *\n * The `restArgs` bit indicates whether the function uses a rest parameter. It's\n * also set to 1 if the function has more than 6 args.\n *\n * @param id hex-encoded server reference ID\n */\nexport function extractInfoFromServerReferenceId(\n  id: string\n): ServerReferenceInfo {\n  const infoByte = parseInt(id.slice(0, 2), 16)\n  const typeBit = (infoByte >> 7) & 0x1\n  const argMask = (infoByte >> 1) & 0x3f\n  const restArgs = infoByte & 0x1\n  const usedArgs = Array(6)\n\n  for (let index = 0; index < 6; index++) {\n    const bitPosition = 5 - index\n    const bit = (argMask >> bitPosition) & 0x1\n    usedArgs[index] = bit === 1\n  }\n\n  return {\n    type: typeBit === 1 ? 'use-cache' : 'server-action',\n    usedArgs: usedArgs as [\n      boolean,\n      boolean,\n      boolean,\n      boolean,\n      boolean,\n      boolean,\n    ],\n    hasRestArgs: restArgs === 1,\n  }\n}\n\n/**\n * Creates a sparse array containing only the used arguments based on the\n * provided action info.\n */\nexport function omitUnusedArgs(\n  args: unknown[],\n  info: ServerReferenceInfo\n): unknown[] {\n  const filteredArgs = new Array(args.length)\n\n  for (let index = 0; index < args.length; index++) {\n    if (\n      (index < 6 && info.usedArgs[index]) ||\n      // This assumes that the server reference info byte has the restArgs bit\n      // set to 1 if there are more than 6 args.\n      (index >= 6 && info.hasRestArgs)\n    ) {\n      filteredArgs[index] = args[index]\n    }\n  }\n\n  return filteredArgs\n}\n"],"names":["extractInfoFromServerReferenceId","id","infoByte","parseInt","slice","typeBit","argMask","restArgs","usedArgs","Array","index","bitPosition","bit","type","hasRestArgs","omitUnusedArgs","args","info","filteredArgs","length"],"mappings":"AAMA;;;;;;;;;;;;;;;;;;;CAmBC,GACD;;;;AAAO,SAASA,iCACdC,EAAU;IAEV,MAAMC,WAAWC,SAASF,GAAGG,KAAK,CAAC,GAAG,IAAI;IAC1C,MAAMC,UAAWH,YAAY,IAAK;IAClC,MAAMI,UAAWJ,YAAY,IAAK;IAClC,MAAMK,WAAWL,WAAW;IAC5B,MAAMM,WAAWC,MAAM;IAEvB,IAAK,IAAIC,QAAQ,GAAGA,QAAQ,GAAGA,QAAS;QACtC,MAAMC,cAAc,IAAID;QACxB,MAAME,MAAON,WAAWK,cAAe;QACvCH,QAAQ,CAACE,MAAM,GAAGE,QAAQ;IAC5B;IAEA,OAAO;QACLC,MAAMR,YAAY,IAAI,cAAc;QACpCG,UAAUA;QAQVM,aAAaP,aAAa;IAC5B;AACF;AAMO,SAASQ,eACdC,IAAe,EACfC,IAAyB;IAEzB,MAAMC,eAAe,IAAIT,MAAMO,KAAKG,MAAM;IAE1C,IAAK,IAAIT,QAAQ,GAAGA,QAAQM,KAAKG,MAAM,EAAET,QAAS;QAChD,IACGA,QAAQ,KAAKO,KAAKT,QAAQ,CAACE,MAAM,IAClC,wEAAwE;QACxE,0CAA0C;QACzCA,SAAS,KAAKO,KAAKH,WAAW,EAC/B;YACAI,YAAY,CAACR,MAAM,GAAGM,IAAI,CAACN,MAAM;QACnC;IACF;IAEA,OAAOQ;AACT","ignoreList":[0]}},
    {"offset": {"line": 2890, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2896, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/server-action-reducer.ts"],"sourcesContent":["import type {\n  ActionFlightResponse,\n  ActionResult,\n} from '../../../../server/app-render/types'\nimport { callServer } from '../../../app-call-server'\nimport { findSourceMapURL } from '../../../app-find-source-map-url'\nimport {\n  ACTION_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n} from '../../app-router-headers'\n\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromFetch } from 'react-server-dom-webpack/client'\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { encodeReply } from 'react-server-dom-webpack/client'\nconst { createFromFetch, createTemporaryReferenceSet, encodeReply } = (\n  !!process.env.NEXT_RUNTIME\n    ? // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client.edge')\n    : // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client')\n) as typeof import('react-server-dom-webpack/client')\n\nimport {\n  PrefetchKind,\n  type ReadonlyReducerState,\n  type ReducerState,\n  type ServerActionAction,\n  type ServerActionMutable,\n} from '../router-reducer-types'\nimport { assignLocation } from '../../../assign-location'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { handleMutable } from '../handle-mutable'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\nimport {\n  normalizeFlightData,\n  type NormalizedFlightData,\n} from '../../../flight-data-helpers'\nimport { getRedirectError } from '../../redirect'\nimport { RedirectType } from '../../redirect-error'\nimport { createSeededPrefetchCacheEntry } from '../prefetch-cache-utils'\nimport { removeBasePath } from '../../../remove-base-path'\nimport { hasBasePath } from '../../../has-base-path'\nimport {\n  extractInfoFromServerReferenceId,\n  omitUnusedArgs,\n} from './server-reference-info'\n\ntype FetchServerActionResult = {\n  redirectLocation: URL | undefined\n  redirectType: RedirectType | undefined\n  actionResult?: ActionResult\n  actionFlightData?: NormalizedFlightData[] | string\n  isPrerender: boolean\n  revalidatedParts: {\n    tag: boolean\n    cookie: boolean\n    paths: string[]\n  }\n}\n\nasync function fetchServerAction(\n  state: ReadonlyReducerState,\n  nextUrl: ReadonlyReducerState['nextUrl'],\n  { actionId, actionArgs }: ServerActionAction\n): Promise<FetchServerActionResult> {\n  const temporaryReferences = createTemporaryReferenceSet()\n  const info = extractInfoFromServerReferenceId(actionId)\n\n  // TODO: Currently, we're only omitting unused args for the experimental \"use\n  // cache\" functions. Once the server reference info byte feature is stable, we\n  // should apply this to server actions as well.\n  const usedArgs =\n    info.type === 'use-cache' ? omitUnusedArgs(actionArgs, info) : actionArgs\n\n  const body = await encodeReply(usedArgs, { temporaryReferences })\n\n  const res = await fetch('', {\n    method: 'POST',\n    headers: {\n      Accept: RSC_CONTENT_TYPE_HEADER,\n      [ACTION_HEADER]: actionId,\n      [NEXT_ROUTER_STATE_TREE_HEADER]: encodeURIComponent(\n        JSON.stringify(state.tree)\n      ),\n      ...(process.env.NEXT_DEPLOYMENT_ID\n        ? {\n            'x-deployment-id': process.env.NEXT_DEPLOYMENT_ID,\n          }\n        : {}),\n      ...(nextUrl\n        ? {\n            [NEXT_URL]: nextUrl,\n          }\n        : {}),\n    },\n    body,\n  })\n\n  const redirectHeader = res.headers.get('x-action-redirect')\n  const [location, _redirectType] = redirectHeader?.split(';') || []\n  let redirectType: RedirectType | undefined\n  switch (_redirectType) {\n    case 'push':\n      redirectType = RedirectType.push\n      break\n    case 'replace':\n      redirectType = RedirectType.replace\n      break\n    default:\n      redirectType = undefined\n  }\n\n  const isPrerender = !!res.headers.get(NEXT_IS_PRERENDER_HEADER)\n  let revalidatedParts: FetchServerActionResult['revalidatedParts']\n  try {\n    const revalidatedHeader = JSON.parse(\n      res.headers.get('x-action-revalidated') || '[[],0,0]'\n    )\n    revalidatedParts = {\n      paths: revalidatedHeader[0] || [],\n      tag: !!revalidatedHeader[1],\n      cookie: revalidatedHeader[2],\n    }\n  } catch (e) {\n    revalidatedParts = {\n      paths: [],\n      tag: false,\n      cookie: false,\n    }\n  }\n\n  const redirectLocation = location\n    ? assignLocation(\n        location,\n        new URL(state.canonicalUrl, window.location.href)\n      )\n    : undefined\n\n  const contentType = res.headers.get('content-type')\n\n  if (contentType?.startsWith(RSC_CONTENT_TYPE_HEADER)) {\n    const response: ActionFlightResponse = await createFromFetch(\n      Promise.resolve(res),\n      { callServer, findSourceMapURL, temporaryReferences }\n    )\n\n    if (location) {\n      // if it was a redirection, then result is just a regular RSC payload\n      return {\n        actionFlightData: normalizeFlightData(response.f),\n        redirectLocation,\n        redirectType,\n        revalidatedParts,\n        isPrerender,\n      }\n    }\n\n    return {\n      actionResult: response.a,\n      actionFlightData: normalizeFlightData(response.f),\n      redirectLocation,\n      redirectType,\n      revalidatedParts,\n      isPrerender,\n    }\n  }\n\n  // Handle invalid server action responses\n  if (res.status >= 400) {\n    // The server can respond with a text/plain error message, but we'll fallback to something generic\n    // if there isn't one.\n    const error =\n      contentType === 'text/plain'\n        ? await res.text()\n        : 'An unexpected response was received from the server.'\n\n    throw new Error(error)\n  }\n\n  return {\n    redirectLocation,\n    redirectType,\n    revalidatedParts,\n    isPrerender,\n  }\n}\n\n/*\n * This reducer is responsible for calling the server action and processing any side-effects from the server action.\n * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.\n */\nexport function serverActionReducer(\n  state: ReadonlyReducerState,\n  action: ServerActionAction\n): ReducerState {\n  const { resolve, reject } = action\n  const mutable: ServerActionMutable = {}\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n  // If the route has been intercepted, the action should be as well.\n  // Otherwise the server action might be intercepted with the wrong action id\n  // (ie, one that corresponds with the intercepted route)\n  const nextUrl =\n    state.nextUrl && hasInterceptionRouteInCurrentTree(state.tree)\n      ? state.nextUrl\n      : null\n\n  return fetchServerAction(state, nextUrl, action).then(\n    async ({\n      actionResult,\n      actionFlightData: flightData,\n      redirectLocation,\n      redirectType,\n      isPrerender,\n      revalidatedParts,\n    }) => {\n      let redirectHref: string | undefined\n\n      // honor the redirect type instead of defaulting to push in case of server actions.\n      if (redirectLocation) {\n        if (redirectType === RedirectType.replace) {\n          state.pushRef.pendingPush = false\n          mutable.pendingPush = false\n        } else {\n          state.pushRef.pendingPush = true\n          mutable.pendingPush = true\n        }\n\n        redirectHref = createHrefFromUrl(redirectLocation, false)\n        mutable.canonicalUrl = redirectHref\n      }\n\n      if (!flightData) {\n        resolve(actionResult)\n\n        // If there is a redirect but no flight data we need to do a mpaNavigation.\n        if (redirectLocation) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectLocation.href,\n            state.pushRef.pendingPush\n          )\n        }\n        return state\n      }\n\n      if (typeof flightData === 'string') {\n        // Handle case when navigating to page in `pages` from `app`\n        resolve(actionResult)\n\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      const actionRevalidated =\n        revalidatedParts.paths.length > 0 ||\n        revalidatedParts.tag ||\n        revalidatedParts.cookie\n\n      for (const normalizedFlightData of flightData) {\n        const {\n          tree: treePatch,\n          seedData: cacheNodeSeedData,\n          head,\n          isRootRender,\n        } = normalizedFlightData\n\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('SERVER ACTION APPLY FAILED')\n          resolve(actionResult)\n\n          return state\n        }\n\n        // Given the path can only have two items the items are only the router state and rsc for the root.\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          redirectHref ? redirectHref : state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          resolve(actionResult)\n\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          resolve(actionResult)\n\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectHref || state.canonicalUrl,\n            state.pushRef.pendingPush\n          )\n        }\n\n        // The server sent back RSC data for the server action, so we need to apply it to the cache.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[1]\n          const cache: CacheNode = createEmptyCacheNode()\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          cache.loading = cacheNodeSeedData[3]\n          fillLazyItemsTillLeafWithHead(\n            cache,\n            // Existing cache is not passed in as server actions have to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head\n          )\n\n          mutable.cache = cache\n          mutable.prefetchCache = new Map()\n\n          if (actionRevalidated) {\n            await refreshInactiveParallelSegments({\n              state,\n              updatedTree: newTree,\n              updatedCache: cache,\n              includeNextUrl: Boolean(nextUrl),\n              canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n            })\n          }\n        }\n\n        mutable.patchedTree = newTree\n        currentTree = newTree\n      }\n\n      if (redirectLocation && redirectHref) {\n        // Because the RedirectBoundary will trigger a navigation, we need to seed the prefetch cache\n        // with the FlightData that we got from the server action for the target page, so that it's\n        // available when the page is navigated to and doesn't need to be re-fetched.\n        // We only do this if the server action didn't revalidate any data, as in that case the\n        // client cache will be cleared and the data will be re-fetched anyway.\n        if (!actionRevalidated) {\n          createSeededPrefetchCacheEntry({\n            url: redirectLocation,\n            data: {\n              flightData,\n              canonicalUrl: undefined,\n              couldBeIntercepted: false,\n              prerendered: false,\n              postponed: false,\n              // TODO: We should be able to set this if the server action\n              // returned a fully static response.\n              staleTime: -1,\n            },\n            tree: state.tree,\n            prefetchCache: state.prefetchCache,\n            nextUrl: state.nextUrl,\n            kind: isPrerender ? PrefetchKind.FULL : PrefetchKind.AUTO,\n          })\n          mutable.prefetchCache = state.prefetchCache\n        }\n\n        // If the action triggered a redirect, the action promise promise will be rejected with\n        // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n        // action result to resolve the promise with. This will effectively reset the state of\n        // the component that called the action as the error boundary will remount the tree.\n        // The status code doesn't matter here as the action handler will have already sent\n        // a response with the correct status code.\n        reject(\n          getRedirectError(\n            hasBasePath(redirectHref)\n              ? removeBasePath(redirectHref)\n              : redirectHref,\n            redirectType || RedirectType.push\n          )\n        )\n      } else {\n        resolve(actionResult)\n      }\n\n      return handleMutable(state, mutable)\n    },\n    (e: any) => {\n      // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n      reject(e)\n\n      return state\n    }\n  )\n}\n"],"names":["callServer","findSourceMapURL","ACTION_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","RSC_CONTENT_TYPE_HEADER","createFromFetch","createTemporaryReferenceSet","encodeReply","process","env","NEXT_RUNTIME","require","PrefetchKind","assignLocation","createHrefFromUrl","handleExternalUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleMutable","fillLazyItemsTillLeafWithHead","createEmptyCacheNode","hasInterceptionRouteInCurrentTree","handleSegmentMismatch","refreshInactiveParallelSegments","normalizeFlightData","getRedirectError","RedirectType","createSeededPrefetchCacheEntry","removeBasePath","hasBasePath","extractInfoFromServerReferenceId","omitUnusedArgs","fetchServerAction","state","nextUrl","actionId","actionArgs","temporaryReferences","info","usedArgs","type","body","res","fetch","method","headers","Accept","encodeURIComponent","JSON","stringify","tree","NEXT_DEPLOYMENT_ID","redirectHeader","get","location","_redirectType","split","redirectType","push","replace","undefined","isPrerender","revalidatedParts","revalidatedHeader","parse","paths","tag","cookie","e","redirectLocation","URL","canonicalUrl","window","href","contentType","startsWith","response","Promise","resolve","actionFlightData","f","actionResult","a","status","error","text","Error","serverActionReducer","action","reject","mutable","currentTree","preserveCustomHistoryState","then","flightData","redirectHref","pushRef","pendingPush","actionRevalidated","length","normalizedFlightData","treePatch","seedData","cacheNodeSeedData","head","isRootRender","console","log","newTree","rsc","cache","prefetchRsc","loading","prefetchCache","Map","updatedTree","updatedCache","includeNextUrl","Boolean","patchedTree","url","data","couldBeIntercepted","prerendered","postponed","staleTime","kind","FULL","AUTO"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3167, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3173, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/router-reducer.ts"],"sourcesContent":["import {\n  ACTION_NAVIGATE,\n  ACTION_SERVER_PATCH,\n  ACTION_RESTORE,\n  ACTION_REFRESH,\n  ACTION_PREFETCH,\n  ACTION_HMR_REFRESH,\n  ACTION_SERVER_ACTION,\n} from './router-reducer-types'\nimport type {\n  ReducerActions,\n  ReducerState,\n  ReadonlyReducerState,\n} from './router-reducer-types'\nimport { navigateReducer } from './reducers/navigate-reducer'\nimport { serverPatchReducer } from './reducers/server-patch-reducer'\nimport { restoreReducer } from './reducers/restore-reducer'\nimport { refreshReducer } from './reducers/refresh-reducer'\nimport { prefetchReducer } from './reducers/prefetch-reducer'\nimport { hmrRefreshReducer } from './reducers/hmr-refresh-reducer'\nimport { serverActionReducer } from './reducers/server-action-reducer'\n\n/**\n * Reducer that handles the app-router state updates.\n */\nfunction clientReducer(\n  state: ReadonlyReducerState,\n  action: ReducerActions\n): ReducerState {\n  switch (action.type) {\n    case ACTION_NAVIGATE: {\n      return navigateReducer(state, action)\n    }\n    case ACTION_SERVER_PATCH: {\n      return serverPatchReducer(state, action)\n    }\n    case ACTION_RESTORE: {\n      return restoreReducer(state, action)\n    }\n    case ACTION_REFRESH: {\n      return refreshReducer(state, action)\n    }\n    case ACTION_HMR_REFRESH: {\n      return hmrRefreshReducer(state, action)\n    }\n    case ACTION_PREFETCH: {\n      return prefetchReducer(state, action)\n    }\n    case ACTION_SERVER_ACTION: {\n      return serverActionReducer(state, action)\n    }\n    // This case should never be hit as dispatch is strongly typed.\n    default:\n      throw new Error('Unknown action')\n  }\n}\n\nfunction serverReducer(\n  state: ReadonlyReducerState,\n  _action: ReducerActions\n): ReducerState {\n  return state\n}\n\n// we don't run the client reducer on the server, so we use a noop function for better tree shaking\nexport const reducer =\n  typeof window === 'undefined' ? serverReducer : clientReducer\n"],"names":["ACTION_NAVIGATE","ACTION_SERVER_PATCH","ACTION_RESTORE","ACTION_REFRESH","ACTION_PREFETCH","ACTION_HMR_REFRESH","ACTION_SERVER_ACTION","navigateReducer","serverPatchReducer","restoreReducer","refreshReducer","prefetchReducer","hmrRefreshReducer","serverActionReducer","clientReducer","state","action","type","Error","serverReducer","_action","reducer","window"],"mappings":";;;AAAA,SACEA,eAAe,EACfC,mBAAmB,EACnBC,cAAc,EACdC,cAAc,EACdC,eAAe,EACfC,kBAAkB,EAClBC,oBAAoB,QACf,yBAAwB;AAM/B,SAASC,eAAe,QAAQ,8BAA6B;AAC7D,SAASC,kBAAkB,QAAQ,kCAAiC;AACpE,SAASC,cAAc,QAAQ,6BAA4B;AAC3D,SAASC,cAAc,QAAQ,6BAA4B;AAC3D,SAASC,eAAe,QAAQ,8BAA6B;AAC7D,SAASC,iBAAiB,QAAQ,iCAAgC;AAClE,SAASC,mBAAmB,QAAQ,mCAAkC;;;;;;;;;AAEtE;;CAEC,GACD,SAASC,cACPC,KAA2B,EAC3BC,MAAsB;IAEtB,OAAQA,OAAOC,IAAI;QACjB,4NAAKjB,kBAAAA;YAAiB;gBACpB,QAAOO,iPAAAA,EAAgBQ,OAAOC;YAChC;QACA,4NAAKf,sBAAAA;YAAqB;gBACxB,8OAAOO,qBAAAA,EAAmBO,OAAOC;YACnC;QACA,4NAAKd,iBAAAA;YAAgB;gBACnB,sOAAOO,iBAAAA,EAAeM,OAAOC;YAC/B;QACA,4NAAKb,iBAAAA;YAAgB;gBACnB,sOAAOO,iBAAAA,EAAeK,OAAOC;YAC/B;QACA,KAAKX,4OAAAA;YAAoB;gBACvB,6OAAOO,oBAAAA,EAAkBG,OAAOC;YAClC;QACA,4NAAKZ,kBAAAA;YAAiB;gBACpB,uOAAOO,kBAAAA,EAAgBI,OAAOC;YAChC;QACA,4NAAKV,uBAAAA;YAAsB;gBACzB,QAAOO,6PAAAA,EAAoBE,OAAOC;YACpC;QACA,+DAA+D;QAC/D;YACE,MAAM,IAAIE,MAAM;IACpB;AACF;AAEA,SAASC,cACPJ,KAA2B,EAC3BK,OAAuB;IAEvB,OAAOL;AACT;AAGO,MAAMM,UACX,OAAOC,WAAW,qBAAcH,gBAAgBL,cAAa","ignoreList":[0]}},
    {"offset": {"line": 3233, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3239, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/router-reducer-types.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../server/app-render/types'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_PREFETCH = 'prefetch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  previousTree,\n  serverResponse,\n}: {\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\nexport type RouterNavigate = (\n  href: string,\n  navigateType: 'push' | 'replace',\n  shouldScroll: boolean\n) => void\n\nexport interface Mutable {\n  mpaNavigation?: boolean\n  patchedTree?: FlightRouterState\n  canonicalUrl?: string\n  scrollableSegments?: FlightSegmentPath[]\n  pendingPush?: boolean\n  cache?: CacheNode\n  prefetchCache?: AppRouterState['prefetchCache']\n  hashFragment?: string\n  shouldScroll?: boolean\n  preserveCustomHistoryState?: boolean\n  onlyHashChange?: boolean\n}\n\nexport interface ServerActionMutable extends Mutable {\n  inFlightServerAction?: Promise<any> | null\n}\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n  origin: Location['origin']\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n  origin: Location['origin']\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n  allowAliasing: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  tree: FlightRouterState | undefined\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n * - Only triggered in layout-router.\n * - Creates a new cache and router state with the Flight data applied.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  serverResponse: FetchServerResponseResult\n  previousTree: FlightRouterState\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n * - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n  TEMPORARY = 'temporary',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\nexport interface PrefetchAction {\n  type: typeof ACTION_PREFETCH\n  url: URL\n  kind: PrefetchKind\n}\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\nexport type PrefetchCacheEntry = {\n  treeAtTimeOfPrefetch: FlightRouterState\n  data: Promise<FetchServerResponseResult>\n  kind: PrefetchKind\n  prefetchTime: number\n  staleTime: number\n  lastUsedTime: number | null\n  key: string\n  status: PrefetchCacheEntryStatus\n  url: URL\n}\n\nexport enum PrefetchCacheEntryStatus {\n  fresh = 'fresh',\n  reusable = 'reusable',\n  expired = 'expired',\n  stale = 'stale',\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   * Prefetched data is stored separately in `prefetchCache`, that is applied during ACTION_NAVIGATE.\n   */\n  cache: CacheNode\n  /**\n   * Cache that holds prefetched Flight responses keyed by url.\n   */\n  prefetchCache: Map<string, PrefetchCacheEntry>\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState = Promise<AppRouterState> | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | PrefetchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n"],"names":["ACTION_REFRESH","ACTION_NAVIGATE","ACTION_RESTORE","ACTION_SERVER_PATCH","ACTION_PREFETCH","ACTION_HMR_REFRESH","ACTION_SERVER_ACTION","PrefetchKind","PrefetchCacheEntryStatus"],"mappings":";;;;;;;;;;;AAOO,MAAMA,iBAAiB,UAAS;AAChC,MAAMC,kBAAkB,WAAU;AAClC,MAAMC,iBAAiB,UAAS;AAChC,MAAMC,sBAAsB,eAAc;AAC1C,MAAMC,kBAAkB,WAAU;AAClC,MAAMC,qBAAqB,cAAa;AACxC,MAAMC,uBAAuB,gBAAe;AAyI5C,IAAKC,eAAAA,WAAAA,GAAAA,SAAAA,YAAAA;;;;WAAAA;MAIX;AA4DM,IAAKC,2BAAAA,WAAAA,GAAAA,SAAAA,wBAAAA;;;;;WAAAA;MAKX","ignoreList":[0]}},
    {"offset": {"line": 3270, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3276, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/create-href-from-url.ts"],"sourcesContent":["export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n"],"names":["createHrefFromUrl","url","includeHash","pathname","search","hash"],"mappings":";;;AAAO,SAASA,kBACdC,GAA8C,EAC9CC,WAA2B;IAA3BA,IAAAA,gBAAAA,KAAAA,GAAAA,cAAuB;IAEvB,OAAOD,IAAIE,QAAQ,GAAGF,IAAIG,MAAM,GAAIF,CAAAA,cAAcD,IAAII,IAAI,GAAG,EAAC;AAChE","ignoreList":[0]}},
    {"offset": {"line": 3283, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3289, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/get-segment-value.ts"],"sourcesContent":["import type { Segment } from '../../../../server/app-render/types'\n\nexport function getSegmentValue(segment: Segment) {\n  return Array.isArray(segment) ? segment[1] : segment\n}\n"],"names":["getSegmentValue","segment","Array","isArray"],"mappings":";;;AAEO,SAASA,gBAAgBC,OAAgB;IAC9C,OAAOC,MAAMC,OAAO,CAACF,WAAWA,OAAO,CAAC,EAAE,GAAGA;AAC/C","ignoreList":[0]}},
    {"offset": {"line": 3295, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3301, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/create-router-cache-key.ts"],"sourcesContent":["import type { Segment } from '../../../server/app-render/types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\nexport function createRouterCacheKey(\n  segment: Segment,\n  withoutSearchParameters: boolean = false\n) {\n  // if the segment is an array, it means it's a dynamic segment\n  // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n  if (Array.isArray(segment)) {\n    return `${segment[0]}|${segment[1]}|${segment[2]}`\n  }\n\n  // Page segments might have search parameters, ie __PAGE__?foo=bar\n  // When `withoutSearchParameters` is true, we only want to return the page segment\n  if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\n    return PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n"],"names":["PAGE_SEGMENT_KEY","createRouterCacheKey","segment","withoutSearchParameters","Array","isArray","startsWith"],"mappings":";;;AACA,SAASA,gBAAgB,QAAQ,8BAA6B;;AAEvD,SAASC,qBACdC,OAAgB,EAChBC,uBAAwC;IAAxCA,IAAAA,4BAAAA,KAAAA,GAAAA,0BAAmC;IAEnC,8DAA8D;IAC9D,uGAAuG;IACvG,IAAIC,MAAMC,OAAO,CAACH,UAAU;QAC1B,OAAUA,OAAO,CAAC,EAAE,GAAC,MAAGA,OAAO,CAAC,EAAE,GAAC,MAAGA,OAAO,CAAC,EAAE;IAClD;IAEA,kEAAkE;IAClE,kFAAkF;IAClF,IAAIC,2BAA2BD,QAAQI,UAAU,yKAACN,mBAAAA,GAAmB;QACnE,+KAAOA,mBAAAA;IACT;IAEA,OAAOE;AACT","ignoreList":[0]}},
    {"offset": {"line": 3320, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3326, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/find-head-in-cache.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../../server/app-render/types'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { createRouterCacheKey } from '../create-router-cache-key'\n\nexport function findHeadInCache(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1]\n): [CacheNode, string] | null {\n  return findHeadInCacheImpl(cache, parallelRoutes, '')\n}\n\nfunction findHeadInCacheImpl(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1],\n  keyPrefix: string\n): [CacheNode, string] | null {\n  const isLastItem = Object.keys(parallelRoutes).length === 0\n  if (isLastItem) {\n    // Returns the entire Cache Node of the segment whose head we will render.\n    return [cache, keyPrefix]\n  }\n  for (const key in parallelRoutes) {\n    const [segment, childParallelRoutes] = parallelRoutes[key]\n    const childSegmentMap = cache.parallelRoutes.get(key)\n    if (!childSegmentMap) {\n      continue\n    }\n\n    const cacheKey = createRouterCacheKey(segment)\n\n    const cacheNode = childSegmentMap.get(cacheKey)\n    if (!cacheNode) {\n      continue\n    }\n\n    const item = findHeadInCacheImpl(\n      cacheNode,\n      childParallelRoutes,\n      keyPrefix + '/' + cacheKey\n    )\n    if (item) {\n      return item\n    }\n  }\n\n  return null\n}\n"],"names":["createRouterCacheKey","findHeadInCache","cache","parallelRoutes","findHeadInCacheImpl","keyPrefix","isLastItem","Object","keys","length","key","segment","childParallelRoutes","childSegmentMap","get","cacheKey","cacheNode","item"],"mappings":";;;AAEA,SAASA,oBAAoB,QAAQ,6BAA4B;;AAE1D,SAASC,gBACdC,KAAgB,EAChBC,cAAoC;IAEpC,OAAOC,oBAAoBF,OAAOC,gBAAgB;AACpD;AAEA,SAASC,oBACPF,KAAgB,EAChBC,cAAoC,EACpCE,SAAiB;IAEjB,MAAMC,aAAaC,OAAOC,IAAI,CAACL,gBAAgBM,MAAM,KAAK;IAC1D,IAAIH,YAAY;QACd,0EAA0E;QAC1E,OAAO;YAACJ;YAAOG;SAAU;IAC3B;IACA,IAAK,MAAMK,OAAOP,eAAgB;QAChC,MAAM,CAACQ,SAASC,oBAAoB,GAAGT,cAAc,CAACO,IAAI;QAC1D,MAAMG,kBAAkBX,MAAMC,cAAc,CAACW,GAAG,CAACJ;QACjD,IAAI,CAACG,iBAAiB;YACpB;QACF;QAEA,MAAME,4OAAWf,uBAAAA,EAAqBW;QAEtC,MAAMK,YAAYH,gBAAgBC,GAAG,CAACC;QACtC,IAAI,CAACC,WAAW;YACd;QACF;QAEA,MAAMC,OAAOb,oBACXY,WACAJ,qBACAP,YAAY,MAAMU;QAEpB,IAAIE,MAAM;YACR,OAAOA;QACT;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 3361, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3367, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/compute-changed-path.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  Segment,\n} from '../../../server/app-render/types'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../../server/lib/interception-routes'\nimport type { Params } from '../../../server/request/params'\nimport {\n  isGroupSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\n\nconst removeLeadingSlash = (segment: string): string => {\n  return segment[0] === '/' ? segment.slice(1) : segment\n}\n\nconst segmentToPathname = (segment: Segment): string => {\n  if (typeof segment === 'string') {\n    // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n    // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n    if (segment === 'children') return ''\n\n    return segment\n  }\n\n  return segment[1]\n}\n\nfunction normalizeSegments(segments: string[]): string {\n  return (\n    segments.reduce((acc, segment) => {\n      segment = removeLeadingSlash(segment)\n      if (segment === '' || isGroupSegment(segment)) {\n        return acc\n      }\n\n      return `${acc}/${segment}`\n    }, '') || '/'\n  )\n}\n\nexport function extractPathFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): string | undefined {\n  const segment = Array.isArray(flightRouterState[0])\n    ? flightRouterState[0][1]\n    : flightRouterState[0]\n\n  if (\n    segment === DEFAULT_SEGMENT_KEY ||\n    INTERCEPTION_ROUTE_MARKERS.some((m) => segment.startsWith(m))\n  )\n    return undefined\n\n  if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''\n\n  const segments = [segmentToPathname(segment)]\n  const parallelRoutes = flightRouterState[1] ?? {}\n\n  const childrenPath = parallelRoutes.children\n    ? extractPathFromFlightRouterState(parallelRoutes.children)\n    : undefined\n\n  if (childrenPath !== undefined) {\n    segments.push(childrenPath)\n  } else {\n    for (const [key, value] of Object.entries(parallelRoutes)) {\n      if (key === 'children') continue\n\n      const childPath = extractPathFromFlightRouterState(value)\n\n      if (childPath !== undefined) {\n        segments.push(childPath)\n      }\n    }\n  }\n\n  return normalizeSegments(segments)\n}\n\nfunction computeChangedPathImpl(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const [segmentA, parallelRoutesA] = treeA\n  const [segmentB, parallelRoutesB] = treeB\n\n  const normalizedSegmentA = segmentToPathname(segmentA)\n  const normalizedSegmentB = segmentToPathname(segmentB)\n\n  if (\n    INTERCEPTION_ROUTE_MARKERS.some(\n      (m) =>\n        normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)\n    )\n  ) {\n    return ''\n  }\n\n  if (!matchSegment(segmentA, segmentB)) {\n    // once we find where the tree changed, we compute the rest of the path by traversing the tree\n    return extractPathFromFlightRouterState(treeB) ?? ''\n  }\n\n  for (const parallelRouterKey in parallelRoutesA) {\n    if (parallelRoutesB[parallelRouterKey]) {\n      const changedPath = computeChangedPathImpl(\n        parallelRoutesA[parallelRouterKey],\n        parallelRoutesB[parallelRouterKey]\n      )\n      if (changedPath !== null) {\n        return `${segmentToPathname(segmentB)}/${changedPath}`\n      }\n    }\n  }\n\n  return null\n}\n\nexport function computeChangedPath(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const changedPath = computeChangedPathImpl(treeA, treeB)\n\n  if (changedPath == null || changedPath === '/') {\n    return changedPath\n  }\n\n  // lightweight normalization to remove route groups\n  return normalizeSegments(changedPath.split('/'))\n}\n\n/**\n * Recursively extracts dynamic parameters from FlightRouterState.\n */\nexport function getSelectedParams(\n  currentTree: FlightRouterState,\n  params: Params = {}\n): Params {\n  const parallelRoutes = currentTree[1]\n\n  for (const parallelRoute of Object.values(parallelRoutes)) {\n    const segment = parallelRoute[0]\n    const isDynamicParameter = Array.isArray(segment)\n    const segmentValue = isDynamicParameter ? segment[1] : segment\n    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue\n\n    // Ensure catchAll and optional catchall are turned into an array\n    const isCatchAll =\n      isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc')\n\n    if (isCatchAll) {\n      params[segment[0]] = segment[1].split('/')\n    } else if (isDynamicParameter) {\n      params[segment[0]] = segment[1]\n    }\n\n    params = getSelectedParams(parallelRoute, params)\n  }\n\n  return params\n}\n"],"names":["INTERCEPTION_ROUTE_MARKERS","isGroupSegment","DEFAULT_SEGMENT_KEY","PAGE_SEGMENT_KEY","matchSegment","removeLeadingSlash","segment","slice","segmentToPathname","normalizeSegments","segments","reduce","acc","extractPathFromFlightRouterState","flightRouterState","Array","isArray","some","m","startsWith","undefined","parallelRoutes","childrenPath","children","push","key","value","Object","entries","childPath","computeChangedPathImpl","treeA","treeB","segmentA","parallelRoutesA","segmentB","parallelRoutesB","normalizedSegmentA","normalizedSegmentB","parallelRouterKey","changedPath","computeChangedPath","split","getSelectedParams","currentTree","params","parallelRoute","values","isDynamicParameter","segmentValue","isCatchAll"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3472, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3478, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/fetch-server-response.ts"],"sourcesContent":["'use client'\n\n// @ts-ignore\n// eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromReadableStream } from 'react-server-dom-webpack/client'\nconst { createFromReadableStream } = (\n  !!process.env.NEXT_RUNTIME\n    ? // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client.edge')\n    : // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client')\n) as typeof import('react-server-dom-webpack/client')\n\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../server/app-render/types'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_URL,\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n} from '../app-router-headers'\nimport { callServer } from '../../app-call-server'\nimport { findSourceMapURL } from '../../app-find-source-map-url'\nimport { PrefetchKind } from './router-reducer-types'\nimport { hexHash } from '../../../shared/lib/hash'\nimport {\n  normalizeFlightData,\n  type NormalizedFlightData,\n} from '../../flight-data-helpers'\nimport { getAppBuildId } from '../../app-build-id'\n\nexport interface FetchServerResponseOptions {\n  readonly flightRouterState: FlightRouterState\n  readonly nextUrl: string | null\n  readonly prefetchKind?: PrefetchKind\n  readonly isHmrRefresh?: boolean\n}\n\nexport type FetchServerResponseResult = {\n  flightData: NormalizedFlightData[] | string\n  canonicalUrl: URL | undefined\n  couldBeIntercepted: boolean\n  prerendered: boolean\n  postponed: boolean\n  staleTime: number\n}\n\nexport type RequestHeaders = {\n  [RSC_HEADER]?: '1'\n  [NEXT_ROUTER_STATE_TREE_HEADER]?: string\n  [NEXT_URL]?: string\n  [NEXT_ROUTER_PREFETCH_HEADER]?: '1'\n  [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string\n  'x-deployment-id'?: string\n  [NEXT_HMR_REFRESH_HEADER]?: '1'\n  // A header that is only added in test mode to assert on fetch priority\n  'Next-Test-Fetch-Priority'?: RequestInit['priority']\n}\n\nexport function urlToUrlWithoutFlightMarker(url: string): URL {\n  const urlWithoutFlightParameters = new URL(url, location.origin)\n  urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY)\n  if (process.env.NODE_ENV === 'production') {\n    if (\n      process.env.__NEXT_CONFIG_OUTPUT === 'export' &&\n      urlWithoutFlightParameters.pathname.endsWith('.txt')\n    ) {\n      const { pathname } = urlWithoutFlightParameters\n      const length = pathname.endsWith('/index.txt') ? 10 : 4\n      // Slice off `/index.txt` or `.txt` from the end of the pathname\n      urlWithoutFlightParameters.pathname = pathname.slice(0, -length)\n    }\n  }\n  return urlWithoutFlightParameters\n}\n\nfunction doMpaNavigation(url: string): FetchServerResponseResult {\n  return {\n    flightData: urlToUrlWithoutFlightMarker(url).toString(),\n    canonicalUrl: undefined,\n    couldBeIntercepted: false,\n    prerendered: false,\n    postponed: false,\n    staleTime: -1,\n  }\n}\n\n/**\n * Fetch the flight data for the provided url. Takes in the current router state\n * to decide what to render server-side.\n */\nexport async function fetchServerResponse(\n  url: URL,\n  options: FetchServerResponseOptions\n): Promise<FetchServerResponseResult> {\n  const { flightRouterState, nextUrl, prefetchKind } = options\n\n  const headers: RequestHeaders = {\n    // Enable flight response\n    [RSC_HEADER]: '1',\n    // Provide the current router state\n    [NEXT_ROUTER_STATE_TREE_HEADER]: encodeURIComponent(\n      JSON.stringify(flightRouterState)\n    ),\n  }\n\n  /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */\n  if (prefetchKind === PrefetchKind.AUTO) {\n    headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n  }\n\n  if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n    headers[NEXT_HMR_REFRESH_HEADER] = '1'\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  try {\n    // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n    // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n    // Otherwise, all other prefetches are sent with a \"low\" priority.\n    // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n    const fetchPriority = prefetchKind\n      ? prefetchKind === PrefetchKind.TEMPORARY\n        ? 'high'\n        : 'low'\n      : 'auto'\n\n    const res = await createFetch(url, headers, fetchPriority)\n\n    const responseUrl = urlToUrlWithoutFlightMarker(res.url)\n    const canonicalUrl = res.redirected ? responseUrl : undefined\n\n    const contentType = res.headers.get('content-type') || ''\n    const interception = !!res.headers.get('vary')?.includes(NEXT_URL)\n    const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)\n    const staleTimeHeader = res.headers.get(NEXT_ROUTER_STALE_TIME_HEADER)\n    const staleTime =\n      staleTimeHeader !== null ? parseInt(staleTimeHeader, 10) : -1\n    let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        if (!isFlightResponse) {\n          isFlightResponse = contentType.startsWith('text/plain')\n        }\n      }\n    }\n\n    // If fetch returns something different than flight response handle it like a mpa navigation\n    // If the fetch was not 200, we also handle it like a mpa navigation\n    if (!isFlightResponse || !res.ok || !res.body) {\n      // in case the original URL came with a hash, preserve it before redirecting to the new URL\n      if (url.hash) {\n        responseUrl.hash = url.hash\n      }\n\n      return doMpaNavigation(responseUrl.toString())\n    }\n\n    // We may navigate to a page that requires a different Webpack runtime.\n    // In prod, every page will have the same Webpack runtime.\n    // In dev, the Webpack runtime is minimal for each page.\n    // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n    if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n      await require('../react-dev-overlay/app/hot-reloader-client').waitForWebpackRuntimeHotUpdate()\n    }\n\n    // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n    const flightStream = postponed\n      ? createUnclosingPrefetchStream(res.body)\n      : res.body\n    const response = await (createFromNextReadableStream(\n      flightStream\n    ) as Promise<NavigationFlightResponse>)\n\n    if (getAppBuildId() !== response.b) {\n      return doMpaNavigation(res.url)\n    }\n\n    return {\n      flightData: normalizeFlightData(response.f),\n      canonicalUrl: canonicalUrl,\n      couldBeIntercepted: interception,\n      prerendered: response.S,\n      postponed,\n      staleTime,\n    }\n  } catch (err) {\n    console.error(\n      `Failed to fetch RSC payload for ${url}. Falling back to browser navigation.`,\n      err\n    )\n    // If fetch fails handle it like a mpa navigation\n    // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n    // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n    return {\n      flightData: url.toString(),\n      canonicalUrl: undefined,\n      couldBeIntercepted: false,\n      prerendered: false,\n      postponed: false,\n      staleTime: -1,\n    }\n  }\n}\n\nexport function createFetch(\n  url: URL,\n  headers: RequestHeaders,\n  fetchPriority: 'auto' | 'high' | 'low' | null\n) {\n  const fetchUrl = new URL(url)\n\n  if (process.env.NODE_ENV === 'production') {\n    if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n      if (fetchUrl.pathname.endsWith('/')) {\n        fetchUrl.pathname += 'index.txt'\n      } else {\n        fetchUrl.pathname += '.txt'\n      }\n    }\n  }\n\n  // This is used to cache bust CDNs that don't support custom headers. The\n  // result is stored in a search param.\n  // TODO: Given that we have to use a search param anyway, we might as well\n  // _only_ use a search param and not bother with the custom headers.\n  // Add unique cache query to avoid caching conflicts on CDN which don't respect the Vary header\n  const uniqueCacheQuery = hexHash(\n    [\n      headers[NEXT_ROUTER_PREFETCH_HEADER] || '0',\n      headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] || '0',\n      headers[NEXT_ROUTER_STATE_TREE_HEADER],\n      headers[NEXT_URL],\n    ].join(',')\n  )\n\n  fetchUrl.searchParams.set(NEXT_RSC_UNION_QUERY, uniqueCacheQuery)\n\n  if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n    headers['Next-Test-Fetch-Priority'] = fetchPriority\n  }\n\n  if (process.env.NEXT_DEPLOYMENT_ID) {\n    headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID\n  }\n\n  return fetch(fetchUrl, {\n    // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n    credentials: 'same-origin',\n    headers,\n    priority: fetchPriority || undefined,\n  })\n}\n\nexport function createFromNextReadableStream(\n  flightStream: ReadableStream<Uint8Array>\n): Promise<unknown> {\n  return createFromReadableStream(flightStream, {\n    callServer,\n    findSourceMapURL,\n  })\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n"],"names":["createFromReadableStream","process","env","NEXT_RUNTIME","require","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_RSC_UNION_QUERY","NEXT_URL","RSC_HEADER","RSC_CONTENT_TYPE_HEADER","NEXT_HMR_REFRESH_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","callServer","findSourceMapURL","PrefetchKind","hexHash","normalizeFlightData","getAppBuildId","urlToUrlWithoutFlightMarker","url","urlWithoutFlightParameters","URL","location","origin","searchParams","delete","NODE_ENV","__NEXT_CONFIG_OUTPUT","pathname","endsWith","length","slice","doMpaNavigation","flightData","toString","canonicalUrl","undefined","couldBeIntercepted","prerendered","postponed","staleTime","fetchServerResponse","options","flightRouterState","nextUrl","prefetchKind","headers","encodeURIComponent","JSON","stringify","AUTO","isHmrRefresh","res","fetchPriority","TEMPORARY","createFetch","responseUrl","redirected","contentType","get","interception","includes","staleTimeHeader","parseInt","isFlightResponse","startsWith","ok","body","hash","TURBOPACK","waitForWebpackRuntimeHotUpdate","flightStream","createUnclosingPrefetchStream","response","createFromNextReadableStream","b","f","S","err","console","error","fetchUrl","uniqueCacheQuery","join","set","__NEXT_TEST_MODE","NEXT_DEPLOYMENT_ID","fetch","credentials","priority","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","value","read","enqueue"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3673, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3679, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  CacheNodeSeedData,\n} from '../../../server/app-render/types'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport {\n  PrefetchCacheEntryStatus,\n  type PrefetchCacheEntry,\n} from './router-reducer-types'\n\nexport function fillLazyItemsTillLeafWithHead(\n  newCache: CacheNode,\n  existingCache: CacheNode | undefined,\n  routerState: FlightRouterState,\n  cacheNodeSeedData: CacheNodeSeedData | null,\n  head: React.ReactNode,\n  prefetchEntry?: PrefetchCacheEntry\n): void {\n  const isLastSegment = Object.keys(routerState[1]).length === 0\n  if (isLastSegment) {\n    newCache.head = head\n    return\n  }\n  // Remove segment that we got data for so that it is filled in during rendering of rsc.\n  for (const key in routerState[1]) {\n    const parallelRouteState = routerState[1][key]\n    const segmentForParallelRoute = parallelRouteState[0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n\n    // TODO: We should traverse the cacheNodeSeedData tree instead of the router\n    // state tree. Ideally, they would always be the same shape, but because of\n    // the loading.js pattern, cacheNodeSeedData sometimes only represents a\n    // partial tree. That's why this node is sometimes null. Once PPR lands,\n    // loading.js will no longer have special behavior and we can traverse the\n    // data tree instead.\n    //\n    // We should also consider merging the router state tree and the data tree\n    // in the response format, so that we don't have to send the keys twice.\n    // Then the client can convert them into separate representations.\n    const parallelSeedData =\n      cacheNodeSeedData !== null && cacheNodeSeedData[2][key] !== undefined\n        ? cacheNodeSeedData[2][key]\n        : null\n    if (existingCache) {\n      const existingParallelRoutesCacheNode =\n        existingCache.parallelRoutes.get(key)\n      if (existingParallelRoutesCacheNode) {\n        const hasReusablePrefetch =\n          prefetchEntry?.kind === 'auto' &&\n          prefetchEntry.status === PrefetchCacheEntryStatus.reusable\n\n        let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n        const existingCacheNode = parallelRouteCacheNode.get(cacheKey)\n        let newCacheNode: CacheNode\n        if (parallelSeedData !== null) {\n          // New data was sent from the server.\n          const seedNode = parallelSeedData[1]\n          const loading = parallelSeedData[3]\n          newCacheNode = {\n            lazyData: null,\n            rsc: seedNode,\n            // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n            // this path during a navigation, but until PPR is fully implemented\n            // yet it's possible the existing node does have a non-null\n            // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n            // old behavior — no PPR value.\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            loading,\n            parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n          }\n        } else if (hasReusablePrefetch && existingCacheNode) {\n          // No new data was sent from the server, but the existing cache node\n          // was prefetched, so we should reuse that.\n          newCacheNode = {\n            lazyData: existingCacheNode.lazyData,\n            rsc: existingCacheNode.rsc,\n            // This is a PPR-only field. Unlike the previous branch, since we're\n            // just cloning the existing cache node, we might as well keep the\n            // PPR value, if it exists.\n            prefetchRsc: existingCacheNode.prefetchRsc,\n            head: existingCacheNode.head,\n            prefetchHead: existingCacheNode.prefetchHead,\n            parallelRoutes: new Map(existingCacheNode.parallelRoutes),\n            loading: existingCacheNode.loading,\n          } as CacheNode\n        } else {\n          // No data available for this node. This will trigger a lazy fetch\n          // during render.\n          newCacheNode = {\n            lazyData: null,\n            rsc: null,\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n            loading: null,\n          }\n        }\n\n        // Overrides the cache key with the new cache node.\n        parallelRouteCacheNode.set(cacheKey, newCacheNode)\n        // Traverse deeper to apply the head / fill lazy items till the head.\n        fillLazyItemsTillLeafWithHead(\n          newCacheNode,\n          existingCacheNode,\n          parallelRouteState,\n          parallelSeedData ? parallelSeedData : null,\n          head,\n          prefetchEntry\n        )\n\n        newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n        continue\n      }\n    }\n\n    let newCacheNode: CacheNode\n    if (parallelSeedData !== null) {\n      // New data was sent from the server.\n      const seedNode = parallelSeedData[1]\n      const loading = parallelSeedData[3]\n      newCacheNode = {\n        lazyData: null,\n        rsc: seedNode,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading,\n      }\n    } else {\n      // No data available for this node. This will trigger a lazy fetch\n      // during render.\n      newCacheNode = {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n      }\n    }\n\n    const existingParallelRoutes = newCache.parallelRoutes.get(key)\n    if (existingParallelRoutes) {\n      existingParallelRoutes.set(cacheKey, newCacheNode)\n    } else {\n      newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]))\n    }\n\n    fillLazyItemsTillLeafWithHead(\n      newCacheNode,\n      undefined,\n      parallelRouteState,\n      parallelSeedData,\n      head,\n      prefetchEntry\n    )\n  }\n}\n"],"names":["createRouterCacheKey","PrefetchCacheEntryStatus","fillLazyItemsTillLeafWithHead","newCache","existingCache","routerState","cacheNodeSeedData","head","prefetchEntry","isLastSegment","Object","keys","length","key","parallelRouteState","segmentForParallelRoute","cacheKey","parallelSeedData","undefined","existingParallelRoutesCacheNode","parallelRoutes","get","hasReusablePrefetch","kind","status","reusable","parallelRouteCacheNode","Map","existingCacheNode","newCacheNode","seedNode","loading","lazyData","rsc","prefetchRsc","prefetchHead","set","existingParallelRoutes"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3810, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3816, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/prefetch-reducer.ts"],"sourcesContent":["import type {\n  PrefetchAction,\n  ReducerState,\n  ReadonlyReducerState,\n} from '../router-reducer-types'\nimport { PromiseQueue } from '../../promise-queue'\nimport {\n  getOrCreatePrefetchCacheEntry,\n  prunePrefetchCache,\n} from '../prefetch-cache-utils'\n\nexport const prefetchQueue = new PromiseQueue(5)\n\nexport const prefetchReducer =\n  process.env.__NEXT_PPR && process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? identityReducerWhenSegmentCacheIsEnabled\n    : prefetchReducerImpl\n\nfunction identityReducerWhenSegmentCacheIsEnabled<T>(state: T): T {\n  // Unlike the old implementation, the Segment Cache doesn't store its data in\n  // the router reducer state.\n  //\n  // This shouldn't be reachable because we wrap the prefetch API in a check,\n  // too, which prevents the action from being dispatched. But it's here for\n  // clarity + code elimination.\n  return state\n}\n\nfunction prefetchReducerImpl(\n  state: ReadonlyReducerState,\n  action: PrefetchAction\n): ReducerState {\n  // let's prune the prefetch cache before we do anything else\n  prunePrefetchCache(state.prefetchCache)\n\n  const { url } = action\n\n  getOrCreatePrefetchCacheEntry({\n    url,\n    nextUrl: state.nextUrl,\n    prefetchCache: state.prefetchCache,\n    kind: action.kind,\n    tree: state.tree,\n    allowAliasing: true,\n  })\n\n  return state\n}\n"],"names":["PromiseQueue","getOrCreatePrefetchCacheEntry","prunePrefetchCache","prefetchQueue","prefetchReducer","process","env","__NEXT_PPR","__NEXT_CLIENT_SEGMENT_CACHE","identityReducerWhenSegmentCacheIsEnabled","prefetchReducerImpl","state","action","prefetchCache","url","nextUrl","kind","tree","allowAliasing"],"mappings":";;;;AAKA,SAASA,YAAY,QAAQ,sBAAqB;AAClD,SACEC,6BAA6B,EAC7BC,kBAAkB,QACb,0BAAyB;;;AAEzB,MAAMC,gBAAgB,4LAAIH,eAAAA,CAAa,GAAE;AAEzC,MAAMI,kBACXC,QAAQC,GAAG,CAACC,UAAU,IAAIF,QAAQC,GAAG,CAACE,2BAA2B,GAC7DC,SACAC,oBAAmB;AAEzB,SAASD,yCAA4CE,KAAQ;IAC3D,6EAA6E;IAC7E,4BAA4B;IAC5B,EAAE;IACF,2EAA2E;IAC3E,0EAA0E;IAC1E,8BAA8B;IAC9B,OAAOA;AACT;AAEA,SAASD,oBACPC,KAA2B,EAC3BC,MAAsB;IAEtB,4DAA4D;+NAC5DV,qBAAAA,EAAmBS,MAAME,aAAa;IAEtC,MAAM,EAAEC,GAAG,EAAE,GAAGF;+NAEhBX,gCAAAA,EAA8B;QAC5Ba;QACAC,SAASJ,MAAMI,OAAO;QACtBF,eAAeF,MAAME,aAAa;QAClCG,MAAMJ,OAAOI,IAAI;QACjBC,MAAMN,MAAMM,IAAI;QAChBC,eAAe;IACjB;IAEA,OAAOP;AACT","ignoreList":[0]}},
    {"offset": {"line": 3849, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3855, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/prefetch-cache-utils.ts"],"sourcesContent":["import {\n  fetchServerResponse,\n  type FetchServerResponseResult,\n} from './fetch-server-response'\nimport {\n  PrefetchCacheEntryStatus,\n  type PrefetchCacheEntry,\n  PrefetchKind,\n  type ReadonlyReducerState,\n} from './router-reducer-types'\nimport { prefetchQueue } from './reducers/prefetch-reducer'\n\nconst INTERCEPTION_CACHE_KEY_MARKER = '%'\n\nexport type AliasedPrefetchCacheEntry = PrefetchCacheEntry & {\n  /** This is a special property that indicates a prefetch entry associated with a different URL\n   * was returned rather than the requested URL. This signals to the router that it should only\n   * apply the part that doesn't depend on searchParams (specifically the loading state).\n   */\n  aliased?: boolean\n}\n\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n * @return The generated prefetch cache key.\n */\nfunction createPrefetchCacheKeyImpl(\n  url: URL,\n  includeSearchParams: boolean,\n  prefix?: string | null\n) {\n  // Initially we only use the pathname as the cache key. We don't want to include\n  // search params so that multiple URLs with the same search parameter can re-use\n  // loading states.\n  let pathnameFromUrl = url.pathname\n\n  // RSC responses can differ based on search params, specifically in the case where we aren't\n  // returning a partial response (ie with `PrefetchKind.AUTO`).\n  // In the auto case, since loading.js & layout.js won't have access to search params,\n  // we can safely re-use that cache entry. But for full prefetches, we should not\n  // re-use the cache entry as the response may differ.\n  if (includeSearchParams) {\n    // if we have a full prefetch, we can include the search param in the key,\n    // as we'll be getting back a full response. The server might have read the search\n    // params when generating the full response.\n    pathnameFromUrl += url.search\n  }\n\n  if (prefix) {\n    return `${prefix}${INTERCEPTION_CACHE_KEY_MARKER}${pathnameFromUrl}`\n  }\n\n  return pathnameFromUrl\n}\n\nfunction createPrefetchCacheKey(\n  url: URL,\n  kind: PrefetchKind | undefined,\n  nextUrl?: string | null\n) {\n  return createPrefetchCacheKeyImpl(url, kind === PrefetchKind.FULL, nextUrl)\n}\n\nfunction getExistingCacheEntry(\n  url: URL,\n  kind: PrefetchKind = PrefetchKind.TEMPORARY,\n  nextUrl: string | null,\n  prefetchCache: Map<string, PrefetchCacheEntry>,\n  allowAliasing: boolean\n): AliasedPrefetchCacheEntry | undefined {\n  // We first check if there's a more specific interception route prefetch entry\n  // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n  // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n  for (const maybeNextUrl of [nextUrl, null]) {\n    const cacheKeyWithParams = createPrefetchCacheKeyImpl(\n      url,\n      true,\n      maybeNextUrl\n    )\n    const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(\n      url,\n      false,\n      maybeNextUrl\n    )\n\n    // First, we check if we have a cache entry that exactly matches the URL\n    const cacheKeyToUse = url.search\n      ? cacheKeyWithParams\n      : cacheKeyWithoutParams\n\n    const existingEntry = prefetchCache.get(cacheKeyToUse)\n    if (existingEntry && allowAliasing) {\n      // We know we're returning an aliased entry when the pathname matches but the search params don't,\n      const isAliased =\n        existingEntry.url.pathname === url.pathname &&\n        existingEntry.url.search !== url.search\n\n      if (isAliased) {\n        return {\n          ...existingEntry,\n          aliased: true,\n        }\n      }\n\n      return existingEntry\n    }\n\n    // If the request contains search params, and we're not doing a full prefetch, we can return the\n    // param-less entry if it exists.\n    // This is technically covered by the check at the bottom of this function, which iterates over cache entries,\n    // but lets us arrive there quicker in the param-full case.\n    const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams)\n    if (\n      process.env.NODE_ENV !== 'development' &&\n      allowAliasing &&\n      url.search &&\n      kind !== PrefetchKind.FULL &&\n      entryWithoutParams &&\n      // We shouldn't return the aliased entry if it was relocated to a new cache key.\n      // Since it's rewritten, it could respond with a completely different loading state.\n      !entryWithoutParams.key.includes(INTERCEPTION_CACHE_KEY_MARKER)\n    ) {\n      return { ...entryWithoutParams, aliased: true }\n    }\n  }\n\n  // If we've gotten to this point, we didn't find a specific cache entry that matched\n  // the request URL.\n  // We attempt a partial match by checking if there's a cache entry with the same pathname.\n  // Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it \"aliased\".\n  // This will signal to the router that it should only apply the loading state on the prefetched data.\n  if (\n    process.env.NODE_ENV !== 'development' &&\n    kind !== PrefetchKind.FULL &&\n    allowAliasing\n  ) {\n    for (const cacheEntry of prefetchCache.values()) {\n      if (\n        cacheEntry.url.pathname === url.pathname &&\n        // We shouldn't return the aliased entry if it was relocated to a new cache key.\n        // Since it's rewritten, it could respond with a completely different loading state.\n        !cacheEntry.key.includes(INTERCEPTION_CACHE_KEY_MARKER)\n      ) {\n        return { ...cacheEntry, aliased: true }\n      }\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Returns a prefetch cache entry if one exists. Otherwise creates a new one and enqueues a fetch request\n * to retrieve the prefetch data from the server.\n */\nexport function getOrCreatePrefetchCacheEntry({\n  url,\n  nextUrl,\n  tree,\n  prefetchCache,\n  kind,\n  allowAliasing = true,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'prefetchCache' | 'tree'> & {\n  url: URL\n  kind?: PrefetchKind\n  allowAliasing: boolean\n}): AliasedPrefetchCacheEntry {\n  const existingCacheEntry = getExistingCacheEntry(\n    url,\n    kind,\n    nextUrl,\n    prefetchCache,\n    allowAliasing\n  )\n\n  if (existingCacheEntry) {\n    // Grab the latest status of the cache entry and update it\n    existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry)\n\n    // when `kind` is provided, an explicit prefetch was requested.\n    // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n    const switchedToFullPrefetch =\n      existingCacheEntry.kind !== PrefetchKind.FULL &&\n      kind === PrefetchKind.FULL\n\n    if (switchedToFullPrefetch) {\n      // If we switched to a full prefetch, validate that the existing cache entry contained partial data.\n      // It's possible that the cache entry was seeded with full data but has a cache type of \"auto\" (ie when cache entries\n      // are seeded but without a prefetch intent)\n      existingCacheEntry.data.then((prefetchResponse) => {\n        const isFullPrefetch =\n          Array.isArray(prefetchResponse.flightData) &&\n          prefetchResponse.flightData.some((flightData) => {\n            // If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.\n            return flightData.isRootRender && flightData.seedData !== null\n          })\n\n        if (!isFullPrefetch) {\n          return createLazyPrefetchEntry({\n            tree,\n            url,\n            nextUrl,\n            prefetchCache,\n            // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n            // rather than assuming the same intent as the previous entry, to be consistent with how we\n            // lazily create prefetch entries when intent is left unspecified.\n            kind: kind ?? PrefetchKind.TEMPORARY,\n          })\n        }\n      })\n    }\n\n    // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n    // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n    if (kind && existingCacheEntry.kind === PrefetchKind.TEMPORARY) {\n      existingCacheEntry.kind = kind\n    }\n\n    // We've determined that the existing entry we found is still valid, so we return it.\n    return existingCacheEntry\n  }\n\n  // If we didn't return an entry, create a new one.\n  return createLazyPrefetchEntry({\n    tree,\n    url,\n    nextUrl,\n    prefetchCache,\n    kind: kind || PrefetchKind.TEMPORARY,\n  })\n}\n\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n */\nfunction prefixExistingPrefetchCacheEntry({\n  url,\n  nextUrl,\n  prefetchCache,\n  existingCacheKey,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'prefetchCache'> & {\n  url: URL\n  existingCacheKey: string\n}) {\n  const existingCacheEntry = prefetchCache.get(existingCacheKey)\n  if (!existingCacheEntry) {\n    // no-op -- there wasn't an entry to move\n    return\n  }\n\n  const newCacheKey = createPrefetchCacheKey(\n    url,\n    existingCacheEntry.kind,\n    nextUrl\n  )\n  prefetchCache.set(newCacheKey, { ...existingCacheEntry, key: newCacheKey })\n  prefetchCache.delete(existingCacheKey)\n\n  return newCacheKey\n}\n\n/**\n * Use to seed the prefetch cache with data that has already been fetched.\n */\nexport function createSeededPrefetchCacheEntry({\n  nextUrl,\n  tree,\n  prefetchCache,\n  url,\n  data,\n  kind,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'tree' | 'prefetchCache'> & {\n  url: URL\n  data: FetchServerResponseResult\n  kind: PrefetchKind\n}) {\n  // The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the\n  // prefetch cache so that we can skip an extra prefetch request later, since we already have the data.\n  // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n  const prefetchCacheKey = data.couldBeIntercepted\n    ? createPrefetchCacheKey(url, kind, nextUrl)\n    : createPrefetchCacheKey(url, kind)\n\n  const prefetchEntry = {\n    treeAtTimeOfPrefetch: tree,\n    data: Promise.resolve(data),\n    kind,\n    prefetchTime: Date.now(),\n    lastUsedTime: Date.now(),\n    staleTime: -1,\n    key: prefetchCacheKey,\n    status: PrefetchCacheEntryStatus.fresh,\n    url,\n  } satisfies PrefetchCacheEntry\n\n  prefetchCache.set(prefetchCacheKey, prefetchEntry)\n\n  return prefetchEntry\n}\n\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */\nfunction createLazyPrefetchEntry({\n  url,\n  kind,\n  tree,\n  nextUrl,\n  prefetchCache,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'tree' | 'prefetchCache'> & {\n  url: URL\n  kind: PrefetchKind\n}): PrefetchCacheEntry {\n  const prefetchCacheKey = createPrefetchCacheKey(url, kind)\n\n  // initiates the fetch request for the prefetch and attaches a listener\n  // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n  const data = prefetchQueue.enqueue(() =>\n    fetchServerResponse(url, {\n      flightRouterState: tree,\n      nextUrl,\n      prefetchKind: kind,\n    }).then((prefetchResponse) => {\n      // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n      // to avoid drift between this cache key prefixing logic\n      // (which is currently directly influenced by the server response)\n      let newCacheKey\n\n      if (prefetchResponse.couldBeIntercepted) {\n        // Determine if we need to prefix the cache key with the nextUrl\n        newCacheKey = prefixExistingPrefetchCacheEntry({\n          url,\n          existingCacheKey: prefetchCacheKey,\n          nextUrl,\n          prefetchCache,\n        })\n      }\n\n      // If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.\n      // This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`\n      // staleTime.\n      if (prefetchResponse.prerendered) {\n        const existingCacheEntry = prefetchCache.get(\n          // if we prefixed the cache key due to route interception, we want to use the new key. Otherwise we use the original key\n          newCacheKey ?? prefetchCacheKey\n        )\n        if (existingCacheEntry) {\n          existingCacheEntry.kind = PrefetchKind.FULL\n          if (prefetchResponse.staleTime !== -1) {\n            // This is the stale time that was collected by the server during\n            // static generation. Use this in place of the default stale time.\n            existingCacheEntry.staleTime = prefetchResponse.staleTime\n          }\n        }\n      }\n\n      return prefetchResponse\n    })\n  )\n\n  const prefetchEntry = {\n    treeAtTimeOfPrefetch: tree,\n    data,\n    kind,\n    prefetchTime: Date.now(),\n    lastUsedTime: null,\n    staleTime: -1,\n    key: prefetchCacheKey,\n    status: PrefetchCacheEntryStatus.fresh,\n    url,\n  }\n\n  prefetchCache.set(prefetchCacheKey, prefetchEntry)\n\n  return prefetchEntry\n}\n\nexport function prunePrefetchCache(\n  prefetchCache: ReadonlyReducerState['prefetchCache']\n) {\n  for (const [href, prefetchCacheEntry] of prefetchCache) {\n    if (\n      getPrefetchEntryCacheStatus(prefetchCacheEntry) ===\n      PrefetchCacheEntryStatus.expired\n    ) {\n      prefetchCache.delete(href)\n    }\n  }\n}\n\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nconst DYNAMIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n\nconst STATIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME) * 1000\n\nfunction getPrefetchEntryCacheStatus({\n  kind,\n  prefetchTime,\n  lastUsedTime,\n  staleTime,\n}: PrefetchCacheEntry): PrefetchCacheEntryStatus {\n  if (staleTime !== -1) {\n    // `staleTime` is the value sent by the server during static generation.\n    // When this is available, it takes precedence over any of the heuristics\n    // that follow.\n    //\n    // TODO: When PPR is enabled, the server will *always* return a stale time\n    // when prefetching. We should never use a prefetch entry that hasn't yet\n    // received data from the server. So the only two cases should be 1) we use\n    // the server-generated stale time 2) the unresolved entry is discarded.\n    return Date.now() < prefetchTime + staleTime\n      ? PrefetchCacheEntryStatus.fresh\n      : PrefetchCacheEntryStatus.stale\n  }\n\n  // We will re-use the cache entry data for up to the `dynamic` staletime window.\n  if (Date.now() < (lastUsedTime ?? prefetchTime) + DYNAMIC_STALETIME_MS) {\n    return lastUsedTime\n      ? PrefetchCacheEntryStatus.reusable\n      : PrefetchCacheEntryStatus.fresh\n  }\n\n  // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n  // A stale entry will only re-use the `loading` boundary, not the full data.\n  // This will trigger a \"lazy fetch\" for the full data.\n  if (kind === PrefetchKind.AUTO) {\n    if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n      return PrefetchCacheEntryStatus.stale\n    }\n  }\n\n  // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n  if (kind === PrefetchKind.FULL) {\n    if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n      return PrefetchCacheEntryStatus.reusable\n    }\n  }\n\n  return PrefetchCacheEntryStatus.expired\n}\n"],"names":["fetchServerResponse","PrefetchCacheEntryStatus","PrefetchKind","prefetchQueue","INTERCEPTION_CACHE_KEY_MARKER","createPrefetchCacheKeyImpl","url","includeSearchParams","prefix","pathnameFromUrl","pathname","search","createPrefetchCacheKey","kind","nextUrl","FULL","getExistingCacheEntry","prefetchCache","allowAliasing","TEMPORARY","maybeNextUrl","cacheKeyWithParams","cacheKeyWithoutParams","cacheKeyToUse","existingEntry","get","isAliased","aliased","entryWithoutParams","process","env","NODE_ENV","key","includes","cacheEntry","values","undefined","getOrCreatePrefetchCacheEntry","tree","existingCacheEntry","status","getPrefetchEntryCacheStatus","switchedToFullPrefetch","data","then","prefetchResponse","isFullPrefetch","Array","isArray","flightData","some","isRootRender","seedData","createLazyPrefetchEntry","prefixExistingPrefetchCacheEntry","existingCacheKey","newCacheKey","set","delete","createSeededPrefetchCacheEntry","prefetchCacheKey","couldBeIntercepted","prefetchEntry","treeAtTimeOfPrefetch","Promise","resolve","prefetchTime","Date","now","lastUsedTime","staleTime","fresh","enqueue","flightRouterState","prefetchKind","prerendered","prunePrefetchCache","href","prefetchCacheEntry","expired","DYNAMIC_STALETIME_MS","Number","__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME","STATIC_STALETIME_MS","__NEXT_CLIENT_ROUTER_STATIC_STALETIME","stale","reusable","AUTO"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4129, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4135, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/invalidate-cache-by-router-state.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { FlightRouterState } from '../../../server/app-render/types'\nimport { createRouterCacheKey } from './create-router-cache-key'\n\n/**\n * Invalidate cache one level down from the router state.\n */\nexport function invalidateCacheByRouterState(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  routerState: FlightRouterState\n): void {\n  // Remove segment that we got data for so that it is filled in during rendering of rsc.\n  for (const key in routerState[1]) {\n    const segmentForParallelRoute = routerState[1][key][0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n    const existingParallelRoutesCacheNode =\n      existingCache.parallelRoutes.get(key)\n    if (existingParallelRoutesCacheNode) {\n      let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n      parallelRouteCacheNode.delete(cacheKey)\n      newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n    }\n  }\n}\n"],"names":["createRouterCacheKey","invalidateCacheByRouterState","newCache","existingCache","routerState","key","segmentForParallelRoute","cacheKey","existingParallelRoutesCacheNode","parallelRoutes","get","parallelRouteCacheNode","Map","delete","set"],"mappings":";;;AAEA,SAASA,oBAAoB,QAAQ,4BAA2B;;AAKzD,SAASC,6BACdC,QAAmB,EACnBC,aAAwB,EACxBC,WAA8B;IAE9B,uFAAuF;IACvF,IAAK,MAAMC,OAAOD,WAAW,CAAC,EAAE,CAAE;QAChC,MAAME,0BAA0BF,WAAW,CAAC,EAAE,CAACC,IAAI,CAAC,EAAE;QACtD,MAAME,4OAAWP,uBAAAA,EAAqBM;QACtC,MAAME,kCACJL,cAAcM,cAAc,CAACC,GAAG,CAACL;QACnC,IAAIG,iCAAiC;YACnC,IAAIG,yBAAyB,IAAIC,IAAIJ;YACrCG,uBAAuBE,MAAM,CAACN;YAC9BL,SAASO,cAAc,CAACK,GAAG,CAACT,KAAKM;QACnC;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 4153, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4159, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/fill-cache-with-new-subtree-data.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { Segment } from '../../../server/app-render/types'\nimport { invalidateCacheByRouterState } from './invalidate-cache-by-router-state'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport type { PrefetchCacheEntry } from './router-reducer-types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\n\n/**\n * Common logic for filling cache with new sub tree data.\n */\nfunction fillCacheHelper(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData,\n  prefetchEntry: PrefetchCacheEntry | undefined,\n  fillLazyItems: boolean\n): void {\n  const {\n    segmentPath,\n    seedData: cacheNodeSeedData,\n    tree: treePatch,\n    head,\n  } = flightData\n  let newCacheNode = newCache\n  let existingCacheNode = existingCache\n\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n\n    // segmentPath is a repeating tuple of parallelRouteKey and segment\n    // we know we've hit the last entry we've reached our final pair\n    const isLastEntry = i === segmentPath.length - 2\n    const cacheKey = createRouterCacheKey(segment)\n\n    const existingChildSegmentMap =\n      existingCacheNode.parallelRoutes.get(parallelRouteKey)\n\n    if (!existingChildSegmentMap) {\n      // Bailout because the existing cache does not have the path to the leaf node\n      // Will trigger lazy fetch in layout-router because of missing segment\n      continue\n    }\n\n    let childSegmentMap = newCacheNode.parallelRoutes.get(parallelRouteKey)\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n      childSegmentMap = new Map(existingChildSegmentMap)\n      newCacheNode.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n    }\n\n    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)\n    let childCacheNode = childSegmentMap.get(cacheKey)\n\n    if (isLastEntry) {\n      if (\n        cacheNodeSeedData &&\n        (!childCacheNode ||\n          !childCacheNode.lazyData ||\n          childCacheNode === existingChildCacheNode)\n      ) {\n        const incomingSegment = cacheNodeSeedData[0]\n        const rsc = cacheNodeSeedData[1]\n        const loading = cacheNodeSeedData[3]\n\n        childCacheNode = {\n          lazyData: null,\n          // When `fillLazyItems` is false, we only want to fill the RSC data for the layout,\n          // not the page segment.\n          rsc:\n            fillLazyItems || incomingSegment !== PAGE_SEGMENT_KEY ? rsc : null,\n          prefetchRsc: null,\n          head: null,\n          prefetchHead: null,\n          loading,\n          parallelRoutes:\n            fillLazyItems && existingChildCacheNode\n              ? new Map(existingChildCacheNode.parallelRoutes)\n              : new Map(),\n        }\n\n        if (existingChildCacheNode && fillLazyItems) {\n          invalidateCacheByRouterState(\n            childCacheNode,\n            existingChildCacheNode,\n            treePatch\n          )\n        }\n        if (fillLazyItems) {\n          fillLazyItemsTillLeafWithHead(\n            childCacheNode,\n            existingChildCacheNode,\n            treePatch,\n            cacheNodeSeedData,\n            head,\n            prefetchEntry\n          )\n        }\n\n        childSegmentMap.set(cacheKey, childCacheNode)\n      }\n      continue\n    }\n\n    if (!childCacheNode || !existingChildCacheNode) {\n      // Bailout because the existing cache does not have the path to the leaf node\n      // Will trigger lazy fetch in layout-router because of missing segment\n      continue\n    }\n\n    if (childCacheNode === existingChildCacheNode) {\n      childCacheNode = {\n        lazyData: childCacheNode.lazyData,\n        rsc: childCacheNode.rsc,\n        prefetchRsc: childCacheNode.prefetchRsc,\n        head: childCacheNode.head,\n        prefetchHead: childCacheNode.prefetchHead,\n        parallelRoutes: new Map(childCacheNode.parallelRoutes),\n        loading: childCacheNode.loading,\n      } as CacheNode\n      childSegmentMap.set(cacheKey, childCacheNode)\n    }\n\n    // Move deeper into the cache nodes\n    newCacheNode = childCacheNode\n    existingCacheNode = existingChildCacheNode\n  }\n}\n\n/**\n * Fill cache with rsc based on flightDataPath\n */\nexport function fillCacheWithNewSubTreeData(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData,\n  prefetchEntry?: PrefetchCacheEntry\n): void {\n  fillCacheHelper(newCache, existingCache, flightData, prefetchEntry, true)\n}\n\nexport function fillCacheWithNewSubTreeDataButOnlyLoading(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData,\n  prefetchEntry?: PrefetchCacheEntry\n): void {\n  fillCacheHelper(newCache, existingCache, flightData, prefetchEntry, false)\n}\n"],"names":["invalidateCacheByRouterState","fillLazyItemsTillLeafWithHead","createRouterCacheKey","PAGE_SEGMENT_KEY","fillCacheHelper","newCache","existingCache","flightData","prefetchEntry","fillLazyItems","segmentPath","seedData","cacheNodeSeedData","tree","treePatch","head","newCacheNode","existingCacheNode","i","length","parallelRouteKey","segment","isLastEntry","cacheKey","existingChildSegmentMap","parallelRoutes","get","childSegmentMap","Map","set","existingChildCacheNode","childCacheNode","lazyData","incomingSegment","rsc","loading","prefetchRsc","prefetchHead","fillCacheWithNewSubTreeData","fillCacheWithNewSubTreeDataButOnlyLoading"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4247, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4253, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/apply-flight-data.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { fillCacheWithNewSubTreeData } from './fill-cache-with-new-subtree-data'\nimport type { PrefetchCacheEntry } from './router-reducer-types'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\n\nexport function applyFlightData(\n  existingCache: CacheNode,\n  cache: CacheNode,\n  flightData: NormalizedFlightData,\n  prefetchEntry?: PrefetchCacheEntry\n): boolean {\n  // The one before last item is the router state tree patch\n  const { tree: treePatch, seedData, head, isRootRender } = flightData\n\n  // Handles case where prefetch only returns the router tree patch without rendered components.\n  if (seedData === null) {\n    return false\n  }\n\n  if (isRootRender) {\n    const rsc = seedData[1]\n    const loading = seedData[3]\n    cache.loading = loading\n    cache.rsc = rsc\n    // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n    // this path during a navigation, but until PPR is fully implemented\n    // yet it's possible the existing node does have a non-null\n    // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n    // old behavior — no PPR value.\n    cache.prefetchRsc = null\n    fillLazyItemsTillLeafWithHead(\n      cache,\n      existingCache,\n      treePatch,\n      seedData,\n      head,\n      prefetchEntry\n    )\n  } else {\n    // Copy rsc for the root node of the cache.\n    cache.rsc = existingCache.rsc\n    // This is a PPR-only field. Unlike the previous branch, since we're\n    // just cloning the existing cache node, we might as well keep the\n    // PPR value, if it exists.\n    cache.prefetchRsc = existingCache.prefetchRsc\n    cache.parallelRoutes = new Map(existingCache.parallelRoutes)\n    cache.loading = existingCache.loading\n    // Create a copy of the existing cache with the rsc applied.\n    fillCacheWithNewSubTreeData(cache, existingCache, flightData, prefetchEntry)\n  }\n\n  return true\n}\n"],"names":["fillLazyItemsTillLeafWithHead","fillCacheWithNewSubTreeData","applyFlightData","existingCache","cache","flightData","prefetchEntry","tree","treePatch","seedData","head","isRootRender","rsc","loading","prefetchRsc","parallelRoutes","Map"],"mappings":";;;AACA,SAASA,6BAA6B,QAAQ,wCAAuC;AACrF,SAASC,2BAA2B,QAAQ,qCAAoC;;;AAIzE,SAASC,gBACdC,aAAwB,EACxBC,KAAgB,EAChBC,UAAgC,EAChCC,aAAkC;IAElC,0DAA0D;IAC1D,MAAM,EAAEC,MAAMC,SAAS,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,YAAY,EAAE,GAAGN;IAE1D,8FAA8F;IAC9F,IAAII,aAAa,MAAM;QACrB,OAAO;IACT;IAEA,IAAIE,cAAc;QAChB,MAAMC,MAAMH,QAAQ,CAAC,EAAE;QACvB,MAAMI,UAAUJ,QAAQ,CAAC,EAAE;QAC3BL,MAAMS,OAAO,GAAGA;QAChBT,MAAMQ,GAAG,GAAGA;QACZ,kEAAkE;QAClE,oEAAoE;QACpE,2DAA2D;QAC3D,kEAAkE;QAClE,+BAA+B;QAC/BR,MAAMU,WAAW,GAAG;SACpBd,qRAAAA,EACEI,OACAD,eACAK,WACAC,UACAC,MACAJ;IAEJ,OAAO;QACL,2CAA2C;QAC3CF,MAAMQ,GAAG,GAAGT,cAAcS,GAAG;QAC7B,oEAAoE;QACpE,kEAAkE;QAClE,2BAA2B;QAC3BR,MAAMU,WAAW,GAAGX,cAAcW,WAAW;QAC7CV,MAAMW,cAAc,GAAG,IAAIC,IAAIb,cAAcY,cAAc;QAC3DX,MAAMS,OAAO,GAAGV,cAAcU,OAAO;QACrC,4DAA4D;wPAC5DZ,8BAAAA,EAA4BG,OAAOD,eAAeE,YAAYC;IAChE;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 4293, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4299, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/refetch-inactive-parallel-segments.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../server/app-render/types'\nimport type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { AppRouterState } from './router-reducer-types'\nimport { applyFlightData } from './apply-flight-data'\nimport { fetchServerResponse } from './fetch-server-response'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\ninterface RefreshInactiveParallelSegments {\n  state: AppRouterState\n  updatedTree: FlightRouterState\n  updatedCache: CacheNode\n  includeNextUrl: boolean\n  canonicalUrl: string\n}\n\n/**\n * Refreshes inactive segments that are still in the current FlightRouterState.\n * A segment is considered \"inactive\" when the server response indicates it didn't match to a page component.\n * This happens during a soft-navigation, where the server will want to patch in the segment\n * with the \"default\" component, but we explicitly ignore the server in this case\n * and keep the existing state for that segment. New data for inactive segments are inherently\n * not part of the server response when we patch the tree, because they were associated with a response\n * from an earlier navigation/request. For each segment, once it becomes \"active\", we encode the URL that provided\n * the data for it. This function traverses parallel routes looking for these markers so that it can re-fetch\n * and patch the new data into the tree.\n */\nexport async function refreshInactiveParallelSegments(\n  options: RefreshInactiveParallelSegments\n) {\n  const fetchedSegments = new Set<string>()\n  await refreshInactiveParallelSegmentsImpl({\n    ...options,\n    rootTree: options.updatedTree,\n    fetchedSegments,\n  })\n}\n\nasync function refreshInactiveParallelSegmentsImpl({\n  state,\n  updatedTree,\n  updatedCache,\n  includeNextUrl,\n  fetchedSegments,\n  rootTree = updatedTree,\n  canonicalUrl,\n}: RefreshInactiveParallelSegments & {\n  fetchedSegments: Set<string>\n  rootTree: FlightRouterState\n}) {\n  const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree\n  const fetchPromises = []\n\n  if (\n    refetchPath &&\n    refetchPath !== canonicalUrl &&\n    refetchMarker === 'refresh' &&\n    // it's possible for the tree to contain multiple segments that contain data at the same URL\n    // we keep track of them so we can dedupe the requests\n    !fetchedSegments.has(refetchPath)\n  ) {\n    fetchedSegments.add(refetchPath) // Mark this URL as fetched\n\n    // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n    // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.\n    const fetchPromise = fetchServerResponse(\n      new URL(refetchPath, location.origin),\n      {\n        // refetch from the root of the updated tree, otherwise it will be scoped to the current segment\n        // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n        flightRouterState: [rootTree[0], rootTree[1], rootTree[2], 'refetch'],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n      }\n    ).then(({ flightData }) => {\n      if (typeof flightData !== 'string') {\n        for (const flightDataPath of flightData) {\n          // we only pass the new cache as this function is called after clearing the router cache\n          // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's\n          // just been created & has been written to, but hasn't been \"committed\" yet.\n          applyFlightData(updatedCache, updatedCache, flightDataPath)\n        }\n      } else {\n        // When flightData is a string, it suggests that the server response should have triggered an MPA navigation\n        // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect\n        // when refreshing on-screen data, so handling this has been ommitted.\n      }\n    })\n\n    fetchPromises.push(fetchPromise)\n  }\n\n  for (const key in parallelRoutes) {\n    const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n      state,\n      updatedTree: parallelRoutes[key],\n      updatedCache,\n      includeNextUrl,\n      fetchedSegments,\n      rootTree,\n      canonicalUrl,\n    })\n\n    fetchPromises.push(parallelFetchPromise)\n  }\n\n  await Promise.all(fetchPromises)\n}\n\n/**\n * Walks the current parallel segments to determine if they are \"active\".\n * An active parallel route will have a `__PAGE__` segment in the FlightRouterState.\n * As opposed to a `__DEFAULT__` segment, which means there was no match for that parallel route.\n * We add a special marker here so that we know how to refresh its data when the router is revalidated.\n */\nexport function addRefreshMarkerToActiveParallelSegments(\n  tree: FlightRouterState,\n  path: string\n) {\n  const [segment, parallelRoutes, , refetchMarker] = tree\n  // a page segment might also contain concatenated search params, so we do a partial match on the key\n  if (segment.includes(PAGE_SEGMENT_KEY) && refetchMarker !== 'refresh') {\n    tree[2] = path\n    tree[3] = 'refresh'\n  }\n\n  for (const key in parallelRoutes) {\n    addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path)\n  }\n}\n"],"names":["applyFlightData","fetchServerResponse","PAGE_SEGMENT_KEY","refreshInactiveParallelSegments","options","fetchedSegments","Set","refreshInactiveParallelSegmentsImpl","rootTree","updatedTree","state","updatedCache","includeNextUrl","canonicalUrl","parallelRoutes","refetchPath","refetchMarker","fetchPromises","has","add","fetchPromise","URL","location","origin","flightRouterState","nextUrl","then","flightData","flightDataPath","push","key","parallelFetchPromise","Promise","all","addRefreshMarkerToActiveParallelSegments","tree","path","segment","includes"],"mappings":";;;;AAGA,SAASA,eAAe,QAAQ,sBAAqB;AACrD,SAASC,mBAAmB,QAAQ,0BAAyB;AAC7D,SAASC,gBAAgB,QAAQ,8BAA6B;;;;AAqBvD,eAAeC,gCACpBC,OAAwC;IAExC,MAAMC,kBAAkB,IAAIC;IAC5B,MAAMC,oCAAoC;QACxC,GAAGH,OAAO;QACVI,UAAUJ,QAAQK,WAAW;QAC7BJ;IACF;AACF;AAEA,eAAeE,oCAAoC,KAWlD;IAXkD,IAAA,EACjDG,KAAK,EACLD,WAAW,EACXE,YAAY,EACZC,cAAc,EACdP,eAAe,EACfG,WAAWC,WAAW,EACtBI,YAAY,EAIb,GAXkD;IAYjD,MAAM,GAAGC,gBAAgBC,aAAaC,cAAc,GAAGP;IACvD,MAAMQ,gBAAgB,EAAE;IAExB,IACEF,eACAA,gBAAgBF,gBAChBG,kBAAkB,aAClB,4FAA4F;IAC5F,sDAAsD;IACtD,CAACX,gBAAgBa,GAAG,CAACH,cACrB;QACAV,gBAAgBc,GAAG,CAACJ,aAAa,2BAA2B;;QAE5D,wHAAwH;QACxH,kIAAkI;QAClI,MAAMK,2OAAenB,sBAAAA,EACnB,IAAIoB,IAAIN,aAAaO,SAASC,MAAM,GACpC;YACE,gGAAgG;YAChG,8HAA8H;YAC9HC,mBAAmB;gBAAChB,QAAQ,CAAC,EAAE;gBAAEA,QAAQ,CAAC,EAAE;gBAAEA,QAAQ,CAAC,EAAE;gBAAE;aAAU;YACrEiB,SAASb,iBAAiBF,MAAMe,OAAO,GAAG;QAC5C,GACAC,IAAI,CAAC,CAAA;gBAAC,EAAEC,UAAU,EAAE,GAAA;YACpB,IAAI,OAAOA,eAAe,UAAU;gBAClC,KAAK,MAAMC,kBAAkBD,WAAY;oBACvC,wFAAwF;oBACxF,4GAA4G;oBAC5G,4EAA4E;4OAC5E3B,kBAAAA,EAAgBW,cAAcA,cAAciB;gBAC9C;YACF,OAAO;YACL,4GAA4G;YAC5G,+GAA+G;YAC/G,sEAAsE;YACxE;QACF;QAEAX,cAAcY,IAAI,CAACT;IACrB;IAEA,IAAK,MAAMU,OAAOhB,eAAgB;QAChC,MAAMiB,uBAAuBxB,oCAAoC;YAC/DG;YACAD,aAAaK,cAAc,CAACgB,IAAI;YAChCnB;YACAC;YACAP;YACAG;YACAK;QACF;QAEAI,cAAcY,IAAI,CAACE;IACrB;IAEA,MAAMC,QAAQC,GAAG,CAAChB;AACpB;AAQO,SAASiB,yCACdC,IAAuB,EACvBC,IAAY;IAEZ,MAAM,CAACC,SAASvB,kBAAkBE,cAAc,GAAGmB;IACnD,oGAAoG;IACpG,IAAIE,QAAQC,QAAQ,yKAACpC,mBAAAA,KAAqBc,kBAAkB,WAAW;QACrEmB,IAAI,CAAC,EAAE,GAAGC;QACVD,IAAI,CAAC,EAAE,GAAG;IACZ;IAEA,IAAK,MAAML,OAAOhB,eAAgB;QAChCoB,yCAAyCpB,cAAc,CAACgB,IAAI,EAAEM;IAChE;AACF","ignoreList":[0]}},
    {"offset": {"line": 4380, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4386, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/create-initial-router-state.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { FlightDataPath } from '../../../server/app-render/types'\n\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { extractPathFromFlightRouterState } from './compute-changed-path'\nimport { createSeededPrefetchCacheEntry } from './prefetch-cache-utils'\nimport { PrefetchKind, type PrefetchCacheEntry } from './router-reducer-types'\nimport { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\nimport { getFlightDataPartsFromPath } from '../../flight-data-helpers'\n\nexport interface InitialRouterStateParameters {\n  initialCanonicalUrlParts: string[]\n  initialParallelRoutes: CacheNode['parallelRoutes']\n  initialFlightData: FlightDataPath[]\n  location: Location | null\n  couldBeIntercepted: boolean\n  postponed: boolean\n  prerendered: boolean\n}\n\nexport function createInitialRouterState({\n  initialFlightData,\n  initialCanonicalUrlParts,\n  initialParallelRoutes,\n  location,\n  couldBeIntercepted,\n  postponed,\n  prerendered,\n}: InitialRouterStateParameters) {\n  // When initialized on the server, the canonical URL is provided as an array of parts.\n  // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n  // as a URL that should be crawled.\n  const initialCanonicalUrl = initialCanonicalUrlParts.join('/')\n  const normalizedFlightData = getFlightDataPartsFromPath(initialFlightData[0])\n  const {\n    tree: initialTree,\n    seedData: initialSeedData,\n    head: initialHead,\n  } = normalizedFlightData\n  const isServer = !location\n  // For the SSR render, seed data should always be available (we only send back a `null` response\n  // in the case of a `loading` segment, pre-PPR.)\n  const rsc = initialSeedData?.[1]\n  const loading = initialSeedData?.[3] ?? null\n\n  const cache: CacheNode = {\n    lazyData: null,\n    rsc,\n    prefetchRsc: null,\n    head: null,\n    prefetchHead: null,\n    // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n    parallelRoutes: isServer ? new Map() : initialParallelRoutes,\n    loading,\n  }\n\n  const canonicalUrl =\n    // location.href is read as the initial value for canonicalUrl in the browser\n    // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n    location\n      ? // window.location does not have the same type as URL but has all the fields createHrefFromUrl needs.\n        createHrefFromUrl(location)\n      : initialCanonicalUrl\n\n  addRefreshMarkerToActiveParallelSegments(initialTree, canonicalUrl)\n\n  const prefetchCache = new Map<string, PrefetchCacheEntry>()\n\n  // When the cache hasn't been seeded yet we fill the cache with the head.\n  if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n    fillLazyItemsTillLeafWithHead(\n      cache,\n      undefined,\n      initialTree,\n      initialSeedData,\n      initialHead\n    )\n  }\n\n  const initialState = {\n    tree: initialTree,\n    cache,\n    prefetchCache,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // First render needs to preserve the previous window.history.state\n      // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: {\n      apply: false,\n      onlyHashChange: false,\n      hashFragment: null,\n      segmentPaths: [],\n    },\n    canonicalUrl,\n    nextUrl:\n      // the || operator is intentional, the pathname can be an empty string\n      (extractPathFromFlightRouterState(initialTree) || location?.pathname) ??\n      null,\n  }\n\n  if (process.env.NODE_ENV !== 'development' && location) {\n    // Seed the prefetch cache with this page's data.\n    // This is to prevent needlessly re-prefetching a page that is already reusable,\n    // and will avoid triggering a loading state/data fetch stall when navigating back to the page.\n    // We don't currently do this in development because links aren't prefetched in development\n    // so having a mismatch between prefetch/no prefetch provides inconsistent behavior based on which page\n    // was loaded first.\n    const url = new URL(\n      `${location.pathname}${location.search}`,\n      location.origin\n    )\n\n    createSeededPrefetchCacheEntry({\n      url,\n      data: {\n        flightData: [normalizedFlightData],\n        canonicalUrl: undefined,\n        couldBeIntercepted: !!couldBeIntercepted,\n        prerendered,\n        postponed,\n        // TODO: The initial RSC payload includes both static and dynamic data\n        // in the same response, even if PPR is enabled. So if there's any\n        // dynamic data at all, we can't set a stale time. In the future we may\n        // add a way to split a single Flight stream into static and dynamic\n        // parts. But in the meantime we should at least make this work for\n        // fully static pages.\n        staleTime: -1,\n      },\n      tree: initialState.tree,\n      prefetchCache: initialState.prefetchCache,\n      nextUrl: initialState.nextUrl,\n      kind: prerendered ? PrefetchKind.FULL : PrefetchKind.AUTO,\n    })\n  }\n\n  return initialState\n}\n"],"names":["createHrefFromUrl","fillLazyItemsTillLeafWithHead","extractPathFromFlightRouterState","createSeededPrefetchCacheEntry","PrefetchKind","addRefreshMarkerToActiveParallelSegments","getFlightDataPartsFromPath","createInitialRouterState","initialFlightData","initialCanonicalUrlParts","initialParallelRoutes","location","couldBeIntercepted","postponed","prerendered","initialCanonicalUrl","join","normalizedFlightData","tree","initialTree","seedData","initialSeedData","head","initialHead","isServer","rsc","loading","cache","lazyData","prefetchRsc","prefetchHead","parallelRoutes","Map","canonicalUrl","prefetchCache","size","undefined","initialState","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","onlyHashChange","hashFragment","segmentPaths","nextUrl","pathname","process","env","NODE_ENV","url","URL","search","origin","data","flightData","staleTime","kind","FULL","AUTO"],"mappings":";;;AAGA,SAASA,iBAAiB,QAAQ,yBAAwB;AAC1D,SAASC,6BAA6B,QAAQ,wCAAuC;AACrF,SAASC,gCAAgC,QAAQ,yBAAwB;AACzE,SAASC,8BAA8B,QAAQ,yBAAwB;AACvE,SAASC,YAAY,QAAiC,yBAAwB;AAC9E,SAASC,wCAAwC,QAAQ,uCAAsC;AAC/F,SAASC,0BAA0B,QAAQ,4BAA2B;;;;;;;;AAY/D,SAASC,yBAAyB,KAQV;IARU,IAAA,EACvCC,iBAAiB,EACjBC,wBAAwB,EACxBC,qBAAqB,EACrBC,QAAQ,EACRC,kBAAkB,EAClBC,SAAS,EACTC,WAAW,EACkB,GARU;IASvC,sFAAsF;IACtF,kGAAkG;IAClG,mCAAmC;IACnC,MAAMC,sBAAsBN,yBAAyBO,IAAI,CAAC;IAC1D,MAAMC,wBAAuBX,mNAAAA,EAA2BE,iBAAiB,CAAC,EAAE;IAC5E,MAAM,EACJU,MAAMC,WAAW,EACjBC,UAAUC,eAAe,EACzBC,MAAMC,WAAW,EAClB,GAAGN;IACJ,MAAMO,WAAW,CAACb;IAClB,gGAAgG;IAChG,gDAAgD;IAChD,MAAMc,MAAMJ,mBAAAA,OAAAA,KAAAA,IAAAA,eAAiB,CAAC,EAAE;QAChBA;IAAhB,MAAMK,UAAUL,CAAAA,oBAAAA,mBAAAA,OAAAA,KAAAA,IAAAA,eAAiB,CAAC,EAAE,KAAA,OAApBA,oBAAwB;IAExC,MAAMM,QAAmB;QACvBC,UAAU;QACVH;QACAI,aAAa;QACbP,MAAM;QACNQ,cAAc;QACd,oJAAoJ;QACpJC,gBAAgBP,WAAW,IAAIQ,QAAQtB;QACvCgB;IACF;IAEA,MAAMO,eACJ,AACA,6EAD6E,qEACqE;IAClJtB,YAEIX,iPAAAA,EAAkBW,YAClBI;gPAENV,2CAAAA,EAAyCc,aAAac;IAEtD,MAAMC,gBAAgB,IAAIF;IAE1B,yEAAyE;IACzE,IAAItB,0BAA0B,QAAQA,sBAAsByB,IAAI,KAAK,GAAG;8PACtElC,gCAAAA,EACE0B,OACAS,WACAjB,aACAE,iBACAE;IAEJ;QAqBI,AACCrB,sEADqE;IAnB1E,MAAMmC,eAAe;QACnBnB,MAAMC;QACNQ;QACAO;QACAI,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,mEAAmE;YACnE,gFAAgF;YAChFC,4BAA4B;QAC9B;QACAC,mBAAmB;YACjBC,OAAO;YACPC,gBAAgB;YAChBC,cAAc;YACdC,cAAc,EAAE;QAClB;QACAb;QACAc,SAEE,CAAC7C,kOAAAA,mCAAAA,EAAiCiB,gBAAAA,CAAgBR,YAAAA,OAAAA,KAAAA,IAAAA,SAAUqC,QAAQ,CAAA,KAAA,OAAnE9C,OACD;IACJ;IAEA,IAAI+C,QAAQC,GAAG,CAACC,QAAQ,KAAK,UAA2B,OAAVxC;;IAiC9C;IAEA,OAAO0B;AACT","ignoreList":[0]}},
    {"offset": {"line": 4461, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4467, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { FlightSegmentPath } from '../../../server/app-render/types'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\n\n/**\n * Fill cache up to the end of the flightSegmentPath, invalidating anything below it.\n */\nexport function invalidateCacheBelowFlightSegmentPath(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightSegmentPath: FlightSegmentPath\n): void {\n  const isLastEntry = flightSegmentPath.length <= 2\n  const [parallelRouteKey, segment] = flightSegmentPath\n\n  const cacheKey = createRouterCacheKey(segment)\n\n  const existingChildSegmentMap =\n    existingCache.parallelRoutes.get(parallelRouteKey)\n\n  if (!existingChildSegmentMap) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return\n  }\n\n  let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey)\n  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n    childSegmentMap = new Map(existingChildSegmentMap)\n    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n  }\n\n  // In case of last entry don't copy further down.\n  if (isLastEntry) {\n    childSegmentMap.delete(cacheKey)\n    return\n  }\n\n  const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)\n  let childCacheNode = childSegmentMap.get(cacheKey)\n\n  if (!childCacheNode || !existingChildCacheNode) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return\n  }\n\n  if (childCacheNode === existingChildCacheNode) {\n    childCacheNode = {\n      lazyData: childCacheNode.lazyData,\n      rsc: childCacheNode.rsc,\n      prefetchRsc: childCacheNode.prefetchRsc,\n      head: childCacheNode.head,\n      prefetchHead: childCacheNode.prefetchHead,\n      parallelRoutes: new Map(childCacheNode.parallelRoutes),\n    } as CacheNode\n    childSegmentMap.set(cacheKey, childCacheNode)\n  }\n\n  invalidateCacheBelowFlightSegmentPath(\n    childCacheNode,\n    existingChildCacheNode,\n    getNextFlightSegmentPath(flightSegmentPath)\n  )\n}\n"],"names":["createRouterCacheKey","getNextFlightSegmentPath","invalidateCacheBelowFlightSegmentPath","newCache","existingCache","flightSegmentPath","isLastEntry","length","parallelRouteKey","segment","cacheKey","existingChildSegmentMap","parallelRoutes","get","childSegmentMap","Map","set","delete","existingChildCacheNode","childCacheNode","lazyData","rsc","prefetchRsc","head","prefetchHead"],"mappings":";;;AAEA,SAASA,oBAAoB,QAAQ,4BAA2B;AAChE,SAASC,wBAAwB,QAAQ,4BAA2B;;;AAK7D,SAASC,sCACdC,QAAmB,EACnBC,aAAwB,EACxBC,iBAAoC;IAEpC,MAAMC,cAAcD,kBAAkBE,MAAM,IAAI;IAChD,MAAM,CAACC,kBAAkBC,QAAQ,GAAGJ;IAEpC,MAAMK,WAAWV,wPAAAA,EAAqBS;IAEtC,MAAME,0BACJP,cAAcQ,cAAc,CAACC,GAAG,CAACL;IAEnC,IAAI,CAACG,yBAAyB;QAC5B,6EAA6E;QAC7E,sEAAsE;QACtE;IACF;IAEA,IAAIG,kBAAkBX,SAASS,cAAc,CAACC,GAAG,CAACL;IAClD,IAAI,CAACM,mBAAmBA,oBAAoBH,yBAAyB;QACnEG,kBAAkB,IAAIC,IAAIJ;QAC1BR,SAASS,cAAc,CAACI,GAAG,CAACR,kBAAkBM;IAChD;IAEA,iDAAiD;IACjD,IAAIR,aAAa;QACfQ,gBAAgBG,MAAM,CAACP;QACvB;IACF;IAEA,MAAMQ,yBAAyBP,wBAAwBE,GAAG,CAACH;IAC3D,IAAIS,iBAAiBL,gBAAgBD,GAAG,CAACH;IAEzC,IAAI,CAACS,kBAAkB,CAACD,wBAAwB;QAC9C,6EAA6E;QAC7E,sEAAsE;QACtE;IACF;IAEA,IAAIC,mBAAmBD,wBAAwB;QAC7CC,iBAAiB;YACfC,UAAUD,eAAeC,QAAQ;YACjCC,KAAKF,eAAeE,GAAG;YACvBC,aAAaH,eAAeG,WAAW;YACvCC,MAAMJ,eAAeI,IAAI;YACzBC,cAAcL,eAAeK,YAAY;YACzCZ,gBAAgB,IAAIG,IAAII,eAAeP,cAAc;QACvD;QACAE,gBAAgBE,GAAG,CAACN,UAAUS;IAChC;IAEAjB,sCACEiB,gBACAD,+MACAjB,2BAAAA,EAAyBI;AAE7B","ignoreList":[0]}},
    {"offset": {"line": 4514, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4520, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/apply-router-state-patch-to-tree.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../server/app-render/types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\nimport { matchSegment } from '../match-segments'\nimport { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\n\n/**\n * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.\n */\nfunction applyPatch(\n  initialTree: FlightRouterState,\n  patchTree: FlightRouterState\n): FlightRouterState {\n  const [initialSegment, initialParallelRoutes] = initialTree\n  const [patchSegment, patchParallelRoutes] = patchTree\n\n  // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree\n  // this is because the __DEFAULT__ segment is used as a placeholder on navigation\n  if (\n    patchSegment === DEFAULT_SEGMENT_KEY &&\n    initialSegment !== DEFAULT_SEGMENT_KEY\n  ) {\n    return initialTree\n  }\n\n  if (matchSegment(initialSegment, patchSegment)) {\n    const newParallelRoutes: FlightRouterState[1] = {}\n    for (const key in initialParallelRoutes) {\n      const isInPatchTreeParallelRoutes =\n        typeof patchParallelRoutes[key] !== 'undefined'\n      if (isInPatchTreeParallelRoutes) {\n        newParallelRoutes[key] = applyPatch(\n          initialParallelRoutes[key],\n          patchParallelRoutes[key]\n        )\n      } else {\n        newParallelRoutes[key] = initialParallelRoutes[key]\n      }\n    }\n\n    for (const key in patchParallelRoutes) {\n      if (newParallelRoutes[key]) {\n        continue\n      }\n\n      newParallelRoutes[key] = patchParallelRoutes[key]\n    }\n\n    const tree: FlightRouterState = [initialSegment, newParallelRoutes]\n\n    // Copy over the existing tree\n    if (initialTree[2]) {\n      tree[2] = initialTree[2]\n    }\n\n    if (initialTree[3]) {\n      tree[3] = initialTree[3]\n    }\n\n    if (initialTree[4]) {\n      tree[4] = initialTree[4]\n    }\n\n    return tree\n  }\n\n  return patchTree\n}\n\n/**\n * Apply the router state from the Flight response, but skip patching default segments.\n * Useful for patching the router cache when navigating, where we persist the existing default segment if there isn't a new one.\n * Creates a new router state tree.\n */\nexport function applyRouterStatePatchToTree(\n  flightSegmentPath: FlightSegmentPath,\n  flightRouterState: FlightRouterState,\n  treePatch: FlightRouterState,\n  path: string\n): FlightRouterState | null {\n  const [segment, parallelRoutes, url, refetch, isRootLayout] =\n    flightRouterState\n\n  // Root refresh\n  if (flightSegmentPath.length === 1) {\n    const tree: FlightRouterState = applyPatch(flightRouterState, treePatch)\n\n    addRefreshMarkerToActiveParallelSegments(tree, path)\n\n    return tree\n  }\n\n  const [currentSegment, parallelRouteKey] = flightSegmentPath\n\n  // Tree path returned from the server should always match up with the current tree in the browser\n  if (!matchSegment(currentSegment, segment)) {\n    return null\n  }\n\n  const lastSegment = flightSegmentPath.length === 2\n\n  let parallelRoutePatch\n  if (lastSegment) {\n    parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch)\n  } else {\n    parallelRoutePatch = applyRouterStatePatchToTree(\n      getNextFlightSegmentPath(flightSegmentPath),\n      parallelRoutes[parallelRouteKey],\n      treePatch,\n      path\n    )\n\n    if (parallelRoutePatch === null) {\n      return null\n    }\n  }\n\n  const tree: FlightRouterState = [\n    flightSegmentPath[0],\n    {\n      ...parallelRoutes,\n      [parallelRouteKey]: parallelRoutePatch,\n    },\n    url,\n    refetch,\n  ]\n\n  // Current segment is the root layout\n  if (isRootLayout) {\n    tree[4] = true\n  }\n\n  addRefreshMarkerToActiveParallelSegments(tree, path)\n\n  return tree\n}\n"],"names":["DEFAULT_SEGMENT_KEY","getNextFlightSegmentPath","matchSegment","addRefreshMarkerToActiveParallelSegments","applyPatch","initialTree","patchTree","initialSegment","initialParallelRoutes","patchSegment","patchParallelRoutes","newParallelRoutes","key","isInPatchTreeParallelRoutes","tree","applyRouterStatePatchToTree","flightSegmentPath","flightRouterState","treePatch","path","segment","parallelRoutes","url","refetch","isRootLayout","length","currentSegment","parallelRouteKey","lastSegment","parallelRoutePatch"],"mappings":";;;AAIA,SAASA,mBAAmB,QAAQ,8BAA6B;AACjE,SAASC,wBAAwB,QAAQ,4BAA2B;AACpE,SAASC,YAAY,QAAQ,oBAAmB;AAChD,SAASC,wCAAwC,QAAQ,uCAAsC;;;;;AAE/F;;CAEC,GACD,SAASC,WACPC,WAA8B,EAC9BC,SAA4B;IAE5B,MAAM,CAACC,gBAAgBC,sBAAsB,GAAGH;IAChD,MAAM,CAACI,cAAcC,oBAAoB,GAAGJ;IAE5C,kGAAkG;IAClG,iFAAiF;IACjF,IACEG,iBAAiBT,8LAAAA,IACjBO,2LAAmBP,sBAAAA,EACnB;QACA,OAAOK;IACT;IAEA,iMAAIH,eAAAA,EAAaK,gBAAgBE,eAAe;QAC9C,MAAME,oBAA0C,CAAC;QACjD,IAAK,MAAMC,OAAOJ,sBAAuB;YACvC,MAAMK,8BACJ,OAAOH,mBAAmB,CAACE,IAAI,KAAK;YACtC,IAAIC,6BAA6B;gBAC/BF,iBAAiB,CAACC,IAAI,GAAGR,WACvBI,qBAAqB,CAACI,IAAI,EAC1BF,mBAAmB,CAACE,IAAI;YAE5B,OAAO;gBACLD,iBAAiB,CAACC,IAAI,GAAGJ,qBAAqB,CAACI,IAAI;YACrD;QACF;QAEA,IAAK,MAAMA,OAAOF,oBAAqB;YACrC,IAAIC,iBAAiB,CAACC,IAAI,EAAE;gBAC1B;YACF;YAEAD,iBAAiB,CAACC,IAAI,GAAGF,mBAAmB,CAACE,IAAI;QACnD;QAEA,MAAME,OAA0B;YAACP;YAAgBI;SAAkB;QAEnE,8BAA8B;QAC9B,IAAIN,WAAW,CAAC,EAAE,EAAE;YAClBS,IAAI,CAAC,EAAE,GAAGT,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBS,IAAI,CAAC,EAAE,GAAGT,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBS,IAAI,CAAC,EAAE,GAAGT,WAAW,CAAC,EAAE;QAC1B;QAEA,OAAOS;IACT;IAEA,OAAOR;AACT;AAOO,SAASS,4BACdC,iBAAoC,EACpCC,iBAAoC,EACpCC,SAA4B,EAC5BC,IAAY;IAEZ,MAAM,CAACC,SAASC,gBAAgBC,KAAKC,SAASC,aAAa,GACzDP;IAEF,eAAe;IACf,IAAID,kBAAkBS,MAAM,KAAK,GAAG;QAClC,MAAMX,OAA0BV,WAAWa,mBAAmBC;oPAE9Df,2CAAAA,EAAyCW,MAAMK;QAE/C,OAAOL;IACT;IAEA,MAAM,CAACY,gBAAgBC,iBAAiB,GAAGX;IAE3C,iGAAiG;IACjG,IAAI,8LAACd,eAAAA,EAAawB,gBAAgBN,UAAU;QAC1C,OAAO;IACT;IAEA,MAAMQ,cAAcZ,kBAAkBS,MAAM,KAAK;IAEjD,IAAII;IACJ,IAAID,aAAa;QACfC,qBAAqBzB,WAAWiB,cAAc,CAACM,iBAAiB,EAAET;IACpE,OAAO;QACLW,qBAAqBd,mNACnBd,2BAAAA,EAAyBe,oBACzBK,cAAc,CAACM,iBAAiB,EAChCT,WACAC;QAGF,IAAIU,uBAAuB,MAAM;YAC/B,OAAO;QACT;IACF;IAEA,MAAMf,OAA0B;QAC9BE,iBAAiB,CAAC,EAAE;QACpB;YACE,GAAGK,cAAc;YACjB,CAACM,iBAAiB,EAAEE;QACtB;QACAP;QACAC;KACD;IAED,qCAAqC;IACrC,IAAIC,cAAc;QAChBV,IAAI,CAAC,EAAE,GAAG;IACZ;gPAEAX,2CAAAA,EAAyCW,MAAMK;IAE/C,OAAOL;AACT","ignoreList":[0]}},
    {"offset": {"line": 4614, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4620, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/should-hard-navigate.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  FlightDataPath,\n  Segment,\n} from '../../../server/app-render/types'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\nimport { matchSegment } from '../match-segments'\n\n// TODO-APP: flightSegmentPath will be empty in case of static response, needs to be handled.\nexport function shouldHardNavigate(\n  flightSegmentPath: FlightDataPath,\n  flightRouterState: FlightRouterState\n): boolean {\n  const [segment, parallelRoutes] = flightRouterState\n  // TODO-APP: Check if `as` can be replaced.\n  const [currentSegment, parallelRouteKey] = flightSegmentPath as [\n    Segment,\n    string,\n  ]\n\n  // Check if current segment matches the existing segment.\n  if (!matchSegment(currentSegment, segment)) {\n    // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n    if (Array.isArray(currentSegment)) {\n      return true\n    }\n\n    // If the existing segment did not match soft navigation is triggered.\n    return false\n  }\n  const lastSegment = flightSegmentPath.length <= 2\n\n  if (lastSegment) {\n    return false\n  }\n\n  return shouldHardNavigate(\n    getNextFlightSegmentPath(flightSegmentPath),\n    parallelRoutes[parallelRouteKey]\n  )\n}\n"],"names":["getNextFlightSegmentPath","matchSegment","shouldHardNavigate","flightSegmentPath","flightRouterState","segment","parallelRoutes","currentSegment","parallelRouteKey","Array","isArray","lastSegment","length"],"mappings":";;;AAKA,SAASA,wBAAwB,QAAQ,4BAA2B;AACpE,SAASC,YAAY,QAAQ,oBAAmB;;;AAGzC,SAASC,mBACdC,iBAAiC,EACjCC,iBAAoC;IAEpC,MAAM,CAACC,SAASC,eAAe,GAAGF;IAClC,2CAA2C;IAC3C,MAAM,CAACG,gBAAgBC,iBAAiB,GAAGL;IAK3C,yDAAyD;IACzD,IAAI,8LAACF,eAAAA,EAAaM,gBAAgBF,UAAU;QAC1C,kGAAkG;QAClG,IAAII,MAAMC,OAAO,CAACH,iBAAiB;YACjC,OAAO;QACT;QAEA,sEAAsE;QACtE,OAAO;IACT;IACA,MAAMI,cAAcR,kBAAkBS,MAAM,IAAI;IAEhD,IAAID,aAAa;QACf,OAAO;IACT;IAEA,OAAOT,0MACLF,2BAAAA,EAAyBG,oBACzBG,cAAc,CAACE,iBAAiB;AAEpC","ignoreList":[0]}},
    {"offset": {"line": 4646, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4652, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/is-navigating-to-new-root-layout.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../server/app-render/types'\n\nexport function isNavigatingToNewRootLayout(\n  currentTree: FlightRouterState,\n  nextTree: FlightRouterState\n): boolean {\n  // Compare segments\n  const currentTreeSegment = currentTree[0]\n  const nextTreeSegment = nextTree[0]\n\n  // If any segment is different before we find the root layout, the root layout has changed.\n  // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n  // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n  if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n    // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n    // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n    if (\n      currentTreeSegment[0] !== nextTreeSegment[0] ||\n      currentTreeSegment[2] !== nextTreeSegment[2]\n    ) {\n      return true\n    }\n  } else if (currentTreeSegment !== nextTreeSegment) {\n    return true\n  }\n\n  // Current tree root layout found\n  if (currentTree[4]) {\n    // If the next tree doesn't have the root layout flag, it must have changed.\n    return !nextTree[4]\n  }\n  // Current tree didn't have its root layout here, must have changed.\n  if (nextTree[4]) {\n    return true\n  }\n  // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n  // But it's not possible to be more than one parallelRoutes before the root layout is found\n  // TODO-APP: change to traverse all parallel routes\n  const currentTreeChild = Object.values(currentTree[1])[0]\n  const nextTreeChild = Object.values(nextTree[1])[0]\n  if (!currentTreeChild || !nextTreeChild) return true\n  return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild)\n}\n"],"names":["isNavigatingToNewRootLayout","currentTree","nextTree","currentTreeSegment","nextTreeSegment","Array","isArray","currentTreeChild","Object","values","nextTreeChild"],"mappings":";;;AAEO,SAASA,4BACdC,WAA8B,EAC9BC,QAA2B;IAE3B,mBAAmB;IACnB,MAAMC,qBAAqBF,WAAW,CAAC,EAAE;IACzC,MAAMG,kBAAkBF,QAAQ,CAAC,EAAE;IAEnC,2FAA2F;IAC3F,4DAA4D;IAC5D,uIAAuI;IACvI,IAAIG,MAAMC,OAAO,CAACH,uBAAuBE,MAAMC,OAAO,CAACF,kBAAkB;QACvE,sHAAsH;QACtH,uGAAuG;QACvG,IACED,kBAAkB,CAAC,EAAE,KAAKC,eAAe,CAAC,EAAE,IAC5CD,kBAAkB,CAAC,EAAE,KAAKC,eAAe,CAAC,EAAE,EAC5C;YACA,OAAO;QACT;IACF,OAAO,IAAID,uBAAuBC,iBAAiB;QACjD,OAAO;IACT;IAEA,iCAAiC;IACjC,IAAIH,WAAW,CAAC,EAAE,EAAE;QAClB,4EAA4E;QAC5E,OAAO,CAACC,QAAQ,CAAC,EAAE;IACrB;IACA,oEAAoE;IACpE,IAAIA,QAAQ,CAAC,EAAE,EAAE;QACf,OAAO;IACT;IACA,4GAA4G;IAC5G,2FAA2F;IAC3F,mDAAmD;IACnD,MAAMK,mBAAmBC,OAAOC,MAAM,CAACR,WAAW,CAAC,EAAE,CAAC,CAAC,EAAE;IACzD,MAAMS,gBAAgBF,OAAOC,MAAM,CAACP,QAAQ,CAAC,EAAE,CAAC,CAAC,EAAE;IACnD,IAAI,CAACK,oBAAoB,CAACG,eAAe,OAAO;IAChD,OAAOV,4BAA4BO,kBAAkBG;AACvD","ignoreList":[0]}},
    {"offset": {"line": 4688, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4694, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/handle-mutable.ts"],"sourcesContent":["import { computeChangedPath } from './compute-changed-path'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n} from './router-reducer-types'\n\nfunction isNotUndefined<T>(value: T): value is Exclude<T, undefined> {\n  return typeof value !== 'undefined'\n}\n\nexport function handleMutable(\n  state: ReadonlyReducerState,\n  mutable: Mutable\n): ReducerState {\n  // shouldScroll is true by default, can override to false.\n  const shouldScroll = mutable.shouldScroll ?? true\n\n  let nextUrl = state.nextUrl\n\n  if (isNotUndefined(mutable.patchedTree)) {\n    // If we received a patched tree, we need to compute the changed path.\n    const changedPath = computeChangedPath(state.tree, mutable.patchedTree)\n    if (changedPath) {\n      // If the tree changed, we need to update the nextUrl\n      nextUrl = changedPath\n    } else if (!nextUrl) {\n      // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n      nextUrl = state.canonicalUrl\n    }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n  }\n\n  return {\n    // Set href.\n    canonicalUrl: isNotUndefined(mutable.canonicalUrl)\n      ? mutable.canonicalUrl === state.canonicalUrl\n        ? state.canonicalUrl\n        : mutable.canonicalUrl\n      : state.canonicalUrl,\n    pushRef: {\n      pendingPush: isNotUndefined(mutable.pendingPush)\n        ? mutable.pendingPush\n        : state.pushRef.pendingPush,\n      mpaNavigation: isNotUndefined(mutable.mpaNavigation)\n        ? mutable.mpaNavigation\n        : state.pushRef.mpaNavigation,\n      preserveCustomHistoryState: isNotUndefined(\n        mutable.preserveCustomHistoryState\n      )\n        ? mutable.preserveCustomHistoryState\n        : state.pushRef.preserveCustomHistoryState,\n    },\n    // All navigation requires scroll and focus management to trigger.\n    focusAndScrollRef: {\n      apply: shouldScroll\n        ? isNotUndefined(mutable?.scrollableSegments)\n          ? true\n          : state.focusAndScrollRef.apply\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          false,\n      onlyHashChange: mutable.onlyHashChange || false,\n      hashFragment: shouldScroll\n        ? // Empty hash should trigger default behavior of scrolling layout into view.\n          // #top is handled in layout-router.\n          mutable.hashFragment && mutable.hashFragment !== ''\n          ? // Remove leading # and decode hash to make non-latin hashes work.\n            decodeURIComponent(mutable.hashFragment.slice(1))\n          : state.focusAndScrollRef.hashFragment\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          null,\n      segmentPaths: shouldScroll\n        ? mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          [],\n    },\n    // Apply cache.\n    cache: mutable.cache ? mutable.cache : state.cache,\n    prefetchCache: mutable.prefetchCache\n      ? mutable.prefetchCache\n      : state.prefetchCache,\n    // Apply patched router state.\n    tree: isNotUndefined(mutable.patchedTree)\n      ? mutable.patchedTree\n      : state.tree,\n    nextUrl,\n  }\n}\n"],"names":["computeChangedPath","isNotUndefined","value","handleMutable","state","mutable","shouldScroll","nextUrl","patchedTree","changedPath","tree","canonicalUrl","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","scrollableSegments","onlyHashChange","hashFragment","decodeURIComponent","slice","segmentPaths","cache","prefetchCache"],"mappings":";;;AAAA,SAASA,kBAAkB,QAAQ,yBAAwB;;AAO3D,SAASC,eAAkBC,KAAQ;IACjC,OAAO,OAAOA,UAAU;AAC1B;AAEO,SAASC,cACdC,KAA2B,EAC3BC,OAAgB;QAGKA;IADrB,0DAA0D;IAC1D,MAAMC,eAAeD,CAAAA,wBAAAA,QAAQC,YAAY,KAAA,OAApBD,wBAAwB;IAE7C,IAAIE,UAAUH,MAAMG,OAAO;IAE3B,IAAIN,eAAeI,QAAQG,WAAW,GAAG;QACvC,sEAAsE;QACtE,MAAMC,kBAAcT,4OAAAA,EAAmBI,MAAMM,IAAI,EAAEL,QAAQG,WAAW;QACtE,IAAIC,aAAa;YACf,qDAAqD;YACrDF,UAAUE;QACZ,OAAO,IAAI,CAACF,SAAS;YACnB,6HAA6H;YAC7HA,UAAUH,MAAMO,YAAY;QAC9B;IACA,0EAA0E;IAC5E;QAyCQN;IAvCR,OAAO;QACL,YAAY;QACZM,cAAcV,eAAeI,QAAQM,YAAY,IAC7CN,QAAQM,YAAY,KAAKP,MAAMO,YAAY,GACzCP,MAAMO,YAAY,GAClBN,QAAQM,YAAY,GACtBP,MAAMO,YAAY;QACtBC,SAAS;YACPC,aAAaZ,eAAeI,QAAQQ,WAAW,IAC3CR,QAAQQ,WAAW,GACnBT,MAAMQ,OAAO,CAACC,WAAW;YAC7BC,eAAeb,eAAeI,QAAQS,aAAa,IAC/CT,QAAQS,aAAa,GACrBV,MAAMQ,OAAO,CAACE,aAAa;YAC/BC,4BAA4Bd,eAC1BI,QAAQU,0BAA0B,IAEhCV,QAAQU,0BAA0B,GAClCX,MAAMQ,OAAO,CAACG,0BAA0B;QAC9C;QACA,kEAAkE;QAClEC,mBAAmB;YACjBC,OAAOX,eACHL,eAAeI,WAAAA,OAAAA,KAAAA,IAAAA,QAASa,kBAAkB,IACxC,OACAd,MAAMY,iBAAiB,CAACC,KAAK,GAE/B;YACJE,gBAAgBd,QAAQc,cAAc,IAAI;YAC1CC,cAAcd,eAEV,AACAD,QAAQe,YAAY,IAAIf,QAAQe,IADI,QACQ,KAAK,KAE/CC,mBAAmBhB,QAAQe,YAAY,CAACE,KAAK,CAAC,MAC9ClB,MAAMY,iBAAiB,CAACI,YAAY,GAEtC;YACJG,cAAcjB,eACVD,CAAAA,8BAAAA,WAAAA,OAAAA,KAAAA,IAAAA,QAASa,kBAAkB,KAAA,OAA3Bb,8BAA+BD,MAAMY,iBAAiB,CAACO,YAAY,GAEnE,EAAE;QACR;QACA,eAAe;QACfC,OAAOnB,QAAQmB,KAAK,GAAGnB,QAAQmB,KAAK,GAAGpB,MAAMoB,KAAK;QAClDC,eAAepB,QAAQoB,aAAa,GAChCpB,QAAQoB,aAAa,GACrBrB,MAAMqB,aAAa;QACvB,8BAA8B;QAC9Bf,MAAMT,eAAeI,QAAQG,WAAW,IACpCH,QAAQG,WAAW,GACnBJ,MAAMM,IAAI;QACdH;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 4743, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4749, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/ppr-navigations.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../../../server/app-render/types'\nimport type {\n  CacheNode,\n  ChildSegmentMap,\n  ReadyCacheNode,\n} from '../../../shared/lib/app-router-context.shared-runtime'\nimport { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\nexport type Task = {\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // The CacheNode that corresponds to the tree that this Task represents. If\n  // `children` is null (i.e. if this is a terminal task node), then `node`\n  // represents a brand new Cache Node tree, which way or may not need to be\n  // filled with dynamic data from the server.\n  node: CacheNode | null\n  // Whether anything in this tree contains dynamic holes that need to be filled\n  // by the server.\n  needsDynamicRequest: boolean\n  children: Map<string, Task> | null\n}\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched — due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function updateCacheNodeOnNavigation(\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: React.ReactNode | null,\n  isPrefetchHeadPartial: boolean\n): Task | null {\n  // Diff the old and new trees to reuse the shared layouts.\n  const oldRouterStateChildren = oldRouterState[1]\n  const newRouterStateChildren = newRouterState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null\n\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n\n  // Clone the current set of segment children, even if they aren't active in\n  // the new tree.\n  // TODO: We currently retain all the inactive segments indefinitely, until\n  // there's an explicit refresh, or a parent layout is lazily refreshed. We\n  // rely on this for popstate navigations, which update the Router State Tree\n  // but do not eagerly perform a data fetch, because they expect the segment\n  // data to already be in the Cache Node tree. For highly static sites that\n  // are mostly read-only, this may happen only rarely, causing memory to\n  // leak. We should figure out a better model for the lifetime of inactive\n  // segments, so we can maintain instant back/forward navigations without\n  // leaking memory indefinitely.\n  const prefetchParallelRoutes = new Map(oldParallelRoutes)\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server — for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  // Most navigations require a request to fetch additional data from the\n  // server, either because the data was not already prefetched, or because the\n  // target route contains dynamic data that cannot be prefetched.\n  //\n  // However, if the target route is fully static, and it's already completely\n  // loaded into the segment cache, then we can skip the server request.\n  //\n  // This starts off as `false`, and is set to `true` if any of the child\n  // routes requires a dynamic request.\n  let needsDynamicRequest = false\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    const newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldRouterStateChild: FlightRouterState | void =\n      oldRouterStateChildren[parallelRouteKey]\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const newSegmentChild = newRouterStateChild[0]\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n\n    const oldSegmentChild =\n      oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined\n\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    let taskChild: Task | null\n    if (newSegmentChild === DEFAULT_SEGMENT_KEY) {\n      // This is another kind of leaf segment — a default route.\n      //\n      // Default routes have special behavior. When there's no matching segment\n      // for a parallel route, Next.js preserves the currently active segment\n      // during a client navigation — but not for initial render. The server\n      // leaves it to the client to account for this. So we need to handle\n      // it here.\n      if (oldRouterStateChild !== undefined) {\n        // Reuse the existing Router State for this segment. We spawn a \"task\"\n        // just to keep track of the updated router state; unlike most, it's\n        // already fulfilled and won't be affected by the dynamic response.\n        taskChild = spawnReusedTask(oldRouterStateChild)\n      } else {\n        // There's no currently active segment. Switch to the \"create\" path.\n        taskChild = createCacheNodeOnNavigation(\n          newRouterStateChild,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          isPrefetchHeadPartial\n        )\n      }\n    } else if (\n      oldSegmentChild !== undefined &&\n      matchSegment(newSegmentChild, oldSegmentChild)\n    ) {\n      if (\n        oldCacheNodeChild !== undefined &&\n        oldRouterStateChild !== undefined\n      ) {\n        // This segment exists in both the old and new trees. Recursively update\n        // the children.\n        taskChild = updateCacheNodeOnNavigation(\n          oldCacheNodeChild,\n          oldRouterStateChild,\n          newRouterStateChild,\n          prefetchDataChild,\n          prefetchHead,\n          isPrefetchHeadPartial\n        )\n      } else {\n        // Either there's no existing Cache Node for this segment, or this\n        // segment doesn't exist in the old Router State tree. Switch to the\n        // \"create\" path.\n        taskChild = createCacheNodeOnNavigation(\n          newRouterStateChild,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          isPrefetchHeadPartial\n        )\n      }\n    } else {\n      // This is a new tree. Switch to the \"create\" path.\n      taskChild = createCacheNodeOnNavigation(\n        newRouterStateChild,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead,\n        isPrefetchHeadPartial\n      )\n    }\n\n    if (taskChild !== null) {\n      // Something changed in the child tree. Keep track of the child task.\n      if (taskChildren === null) {\n        taskChildren = new Map()\n      }\n      taskChildren.set(parallelRouteKey, taskChild)\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n        prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n\n      if (taskChild.needsDynamicRequest) {\n        needsDynamicRequest = true\n      }\n\n      // The child tree's route state may be different from the prefetched\n      // route sent by the server. We need to clone it as we traverse back up\n      // the tree.\n      patchedRouterStateChildren[parallelRouteKey] = taskChild.route\n    } else {\n      // The child didn't change. We can use the prefetched router state.\n      patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild\n    }\n  }\n\n  if (taskChildren === null) {\n    // No new tasks were spawned.\n    return null\n  }\n\n  const newCacheNode: ReadyCacheNode = {\n    lazyData: null,\n    rsc: oldCacheNode.rsc,\n    // We intentionally aren't updating the prefetchRsc field, since this node\n    // is already part of the current tree, because it would be weird for\n    // prefetch data to be newer than the final data. It probably won't ever be\n    // observable anyway, but it could happen if the segment is unmounted then\n    // mounted again, because LayoutRouter will momentarily switch to rendering\n    // prefetchRsc, via useDeferredValue.\n    prefetchRsc: oldCacheNode.prefetchRsc,\n    head: oldCacheNode.head,\n    prefetchHead: oldCacheNode.prefetchHead,\n    loading: oldCacheNode.loading,\n\n    // Everything is cloned except for the children, which we computed above.\n    parallelRoutes: prefetchParallelRoutes,\n  }\n\n  return {\n    // Return a cloned copy of the router state with updated children.\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    needsDynamicRequest,\n    children: taskChildren,\n  }\n}\n\nfunction createCacheNodeOnNavigation(\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  possiblyPartialPrefetchHead: React.ReactNode | null,\n  isPrefetchHeadPartial: boolean\n): Task {\n  // Same traversal as updateCacheNodeNavigation, but we switch to this path\n  // once we reach the part of the tree that was not in the previous route. We\n  // don't need to diff against the old tree, we just need to create a new one.\n  if (prefetchData === null) {\n    // There's no prefetch for this segment. Everything from this point will be\n    // requested from the server, even if there are static children below it.\n    // Create a terminal task node that will later be fulfilled by\n    // server response.\n    return spawnPendingTask(\n      routerState,\n      null,\n      possiblyPartialPrefetchHead,\n      isPrefetchHeadPartial\n    )\n  }\n\n  const routerStateChildren = routerState[1]\n  const isPrefetchRscPartial = prefetchData[4]\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const isLeafSegment = Object.keys(routerStateChildren).length === 0\n\n  // If prefetch data is available for a segment, and it's fully static (i.e.\n  // does not contain any dynamic holes), we don't need to request it from\n  // the server.\n  if (\n    // Check if the segment data is partial\n    isPrefetchRscPartial ||\n    // Check if the head is partial (only relevant if this is a leaf segment)\n    (isPrefetchHeadPartial && isLeafSegment)\n  ) {\n    // We only have partial data from this segment. Like missing segments, we\n    // must request the full data from the server.\n    return spawnPendingTask(\n      routerState,\n      prefetchData,\n      possiblyPartialPrefetchHead,\n      isPrefetchHeadPartial\n    )\n  }\n\n  // The prefetched segment is fully static, so we don't need to request a new\n  // one from the server. Keep traversing down the tree until we reach something\n  // that requires a dynamic request.\n  const prefetchDataChildren = prefetchData[2]\n  const taskChildren = new Map()\n  const cacheNodeChildren = new Map()\n  let needsDynamicRequest = false\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const taskChild = createCacheNodeOnNavigation(\n      routerStateChild,\n      prefetchDataChild,\n      possiblyPartialPrefetchHead,\n      isPrefetchHeadPartial\n    )\n    taskChildren.set(parallelRouteKey, taskChild)\n    if (taskChild.needsDynamicRequest) {\n      needsDynamicRequest = true\n    }\n    const newCacheNodeChild = taskChild.node\n    if (newCacheNodeChild !== null) {\n      const newSegmentMapChild: ChildSegmentMap = new Map()\n      newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n      cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild)\n    }\n  }\n\n  const rsc = prefetchData[1]\n  const loading = prefetchData[3]\n  return {\n    route: routerState,\n    node: {\n      lazyData: null,\n      // Since this is a fully static segment, we don't need to use the\n      // `prefetchRsc` field.\n      rsc,\n      prefetchRsc: null,\n      head: isLeafSegment ? possiblyPartialPrefetchHead : null,\n      prefetchHead: null,\n      loading,\n      parallelRoutes: cacheNodeChildren,\n    },\n    needsDynamicRequest,\n    children: taskChildren,\n  }\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction spawnPendingTask(\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: React.ReactNode | null,\n  isPrefetchHeadPartial: boolean\n): Task {\n  // Create a task that will later be fulfilled by data from the server.\n  const newTask: Task = {\n    route: routerState,\n\n    // Corresponds to the part of the route that will be rendered on the server.\n    node: createPendingCacheNode(\n      routerState,\n      prefetchData,\n      prefetchHead,\n      isPrefetchHeadPartial\n    ),\n    // Set this to true to indicate that this tree is missing data. This will\n    // be propagated to all the parent tasks.\n    needsDynamicRequest: true,\n    children: null,\n  }\n  return newTask\n}\n\nfunction spawnReusedTask(reusedRouterState: FlightRouterState): Task {\n  // Create a task that reuses an existing segment, e.g. when reusing\n  // the current active segment in place of a default route.\n  return {\n    route: reusedRouterState,\n    node: null,\n    needsDynamicRequest: false,\n    children: null,\n  }\n}\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for — everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function listenForDynamicRequest(\n  task: Task,\n  responsePromise: Promise<FetchServerResponseResult>\n) {\n  responsePromise.then(\n    ({ flightData }: FetchServerResponseResult) => {\n      if (typeof flightData === 'string') {\n        // Happens when navigating to page in `pages` from `app`. We shouldn't\n        // get here because should have already handled this during\n        // the prefetch.\n        return\n      }\n      for (const normalizedFlightData of flightData) {\n        const {\n          segmentPath,\n          tree: serverRouterState,\n          seedData: dynamicData,\n          head: dynamicHead,\n        } = normalizedFlightData\n\n        if (!dynamicData) {\n          // This shouldn't happen. PPR should always send back a response.\n          // However, `FlightDataPath` is a shared type and the pre-PPR handling of\n          // this might return null.\n          continue\n        }\n\n        writeDynamicDataIntoPendingTask(\n          task,\n          segmentPath,\n          serverRouterState,\n          dynamicData,\n          dynamicHead\n        )\n      }\n\n      // Now that we've exhausted all the data we received from the server, if\n      // there are any remaining pending tasks in the tree, abort them now.\n      // If there's any missing data, it will trigger a lazy fetch.\n      abortTask(task, null)\n    },\n    (error: any) => {\n      // This will trigger an error during render\n      abortTask(task, error)\n    }\n  )\n}\n\nfunction writeDynamicDataIntoPendingTask(\n  rootTask: Task,\n  segmentPath: FlightSegmentPath,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: React.ReactNode\n) {\n  // The data sent by the server represents only a subtree of the app. We need\n  // to find the part of the task tree that matches the server response, and\n  // fulfill it using the dynamic data.\n  //\n  // segmentPath represents the parent path of subtree. It's a repeating pattern\n  // of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // Iterate through the path and finish any tasks that match this payload.\n  let task = rootTask\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n    const taskChildren = task.children\n    if (taskChildren !== null) {\n      const taskChild = taskChildren.get(parallelRouteKey)\n      if (taskChild !== undefined) {\n        const taskSegment = taskChild.route[0]\n        if (matchSegment(segment, taskSegment)) {\n          // Found a match for this task. Keep traversing down the task tree.\n          task = taskChild\n          continue\n        }\n      }\n    }\n    // We didn't find a child task that matches the server data. Exit. We won't\n    // abort the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    return\n  }\n\n  finishTaskUsingDynamicDataPayload(\n    task,\n    serverRouterState,\n    dynamicData,\n    dynamicHead\n  )\n}\n\nfunction finishTaskUsingDynamicDataPayload(\n  task: Task,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: React.ReactNode\n) {\n  if (!task.needsDynamicRequest) {\n    // Everything in this subtree is already complete. Bail out.\n    return\n  }\n\n  // dynamicData may represent a larger subtree than the task. Before we can\n  // finish the task, we need to line them up.\n  const taskChildren = task.children\n  const taskNode = task.node\n  if (taskChildren === null) {\n    // We've reached the leaf node of the pending task. The server data tree\n    // lines up the pending Cache Node tree. We can now switch to the\n    // normal algorithm.\n    if (taskNode !== null) {\n      finishPendingCacheNode(\n        taskNode,\n        task.route,\n        serverRouterState,\n        dynamicData,\n        dynamicHead\n      )\n      // Set this to false to indicate that this task is now complete.\n      task.needsDynamicRequest = false\n    }\n    return\n  }\n  // The server returned more data than we need to finish the task. Skip over\n  // the extra segments until we reach the leaf task node.\n  const serverChildren = serverRouterState[1]\n  const dynamicDataChildren = dynamicData[2]\n\n  for (const parallelRouteKey in serverRouterState) {\n    const serverRouterStateChild: FlightRouterState =\n      serverChildren[parallelRouteKey]\n    const dynamicDataChild: CacheNodeSeedData | null | void =\n      dynamicDataChildren[parallelRouteKey]\n\n    const taskChild = taskChildren.get(parallelRouteKey)\n    if (taskChild !== undefined) {\n      const taskSegment = taskChild.route[0]\n      if (\n        matchSegment(serverRouterStateChild[0], taskSegment) &&\n        dynamicDataChild !== null &&\n        dynamicDataChild !== undefined\n      ) {\n        // Found a match for this task. Keep traversing down the task tree.\n        return finishTaskUsingDynamicDataPayload(\n          taskChild,\n          serverRouterStateChild,\n          dynamicDataChild,\n          dynamicHead\n        )\n      }\n    }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n  }\n}\n\nfunction createPendingCacheNode(\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: React.ReactNode | null,\n  isPrefetchHeadPartial: boolean\n): ReadyCacheNode {\n  const routerStateChildren = routerState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null\n\n  const parallelRoutes = new Map()\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const prefetchDataChild: CacheNodeSeedData | null | void =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n    const newCacheNodeChild = createPendingCacheNode(\n      routerStateChild,\n      prefetchDataChild === undefined ? null : prefetchDataChild,\n      prefetchHead,\n      isPrefetchHeadPartial\n    )\n\n    const newSegmentMapChild: ChildSegmentMap = new Map()\n    newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n    parallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n  }\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const isLeafSegment = parallelRoutes.size === 0\n  const maybePrefetchRsc = prefetchData !== null ? prefetchData[1] : null\n  const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null\n  return {\n    lazyData: null,\n    parallelRoutes: parallelRoutes,\n\n    prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n    prefetchHead: isLeafSegment ? prefetchHead : null,\n\n    // TODO: Technically, a loading boundary could contain dynamic data. We must\n    // have separate `loading` and `prefetchLoading` fields to handle this, like\n    // we do for the segment data and head.\n    loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,\n\n    // Create a deferred promise. This will be fulfilled once the dynamic\n    // response is received from the server.\n    rsc: createDeferredRsc() as React.ReactNode,\n    head: isLeafSegment ? (createDeferredRsc() as React.ReactNode) : null,\n  }\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  taskState: FlightRouterState,\n  serverState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: React.ReactNode\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety — it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n  const taskStateChildren = taskState[1]\n  const serverStateChildren = serverState[1]\n  const dataChildren = dynamicData[2]\n\n  // The router state that we traverse the tree with (taskState) is the same one\n  // that we used to construct the pending Cache Node tree. That way we're sure\n  // to resolve all the pending promises.\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in taskStateChildren) {\n    const taskStateChild: FlightRouterState =\n      taskStateChildren[parallelRouteKey]\n    const serverStateChild: FlightRouterState | void =\n      serverStateChildren[parallelRouteKey]\n    const dataChild: CacheNodeSeedData | null | void =\n      dataChildren[parallelRouteKey]\n\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    const taskSegmentChild = taskStateChild[0]\n    const taskSegmentKeyChild = createRouterCacheKey(taskSegmentChild)\n\n    const cacheNodeChild =\n      segmentMapChild !== undefined\n        ? segmentMapChild.get(taskSegmentKeyChild)\n        : undefined\n\n    if (cacheNodeChild !== undefined) {\n      if (\n        serverStateChild !== undefined &&\n        matchSegment(taskSegmentChild, serverStateChild[0])\n      ) {\n        if (dataChild !== undefined && dataChild !== null) {\n          // This is the happy path. Recursively update all the children.\n          finishPendingCacheNode(\n            cacheNodeChild,\n            taskStateChild,\n            serverStateChild,\n            dataChild,\n            dynamicHead\n          )\n        } else {\n          // The server never returned data for this segment. Trigger a lazy\n          // fetch during render. This shouldn't happen because the Route Tree\n          // and the Seed Data tree sent by the server should always be the same\n          // shape when part of the same server response.\n          abortPendingCacheNode(taskStateChild, cacheNodeChild, null)\n        }\n      } else {\n        // The server never returned data for this segment. Trigger a lazy\n        // fetch during render.\n        abortPendingCacheNode(taskStateChild, cacheNodeChild, null)\n      }\n    } else {\n      // The server response matches what was expected to receive, but there's\n      // no matching Cache Node in the task tree. This is a bug in the\n      // implementation because we should have created a node for every\n      // segment in the tree that's associated with this task.\n    }\n  }\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[1]\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead)\n  }\n}\n\nexport function abortTask(task: Task, error: any): void {\n  const cacheNode = task.node\n  if (cacheNode === null) {\n    // This indicates the task is already complete.\n    return\n  }\n\n  const taskChildren = task.children\n  if (taskChildren === null) {\n    // Reached the leaf task node. This is the root of a pending cache\n    // node tree.\n    abortPendingCacheNode(task.route, cacheNode, error)\n  } else {\n    // This is an intermediate task node. Keep traversing until we reach a\n    // task node with no children. That will be the root of the cache node tree\n    // that needs to be resolved.\n    for (const taskChild of taskChildren.values()) {\n      abortTask(taskChild, error)\n    }\n  }\n\n  // Set this to false to indicate that this task is now complete.\n  task.needsDynamicRequest = false\n}\n\nfunction abortPendingCacheNode(\n  routerState: FlightRouterState,\n  cacheNode: CacheNode,\n  error: any\n): void {\n  // For every pending segment in the tree, resolve its `rsc` promise to `null`\n  // to trigger a lazy fetch during render.\n  //\n  // Or, if an error object is provided, it will error instead.\n  const routerStateChildren = routerState[1]\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    if (segmentMapChild === undefined) {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n      continue\n    }\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const cacheNodeChild = segmentMapChild.get(segmentKeyChild)\n    if (cacheNodeChild !== undefined) {\n      abortPendingCacheNode(routerStateChild, cacheNodeChild, error)\n    } else {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n    }\n  }\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error)\n    }\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null)\n  }\n}\n\nexport function updateCacheNodeOnPopstateRestoration(\n  oldCacheNode: CacheNode,\n  routerState: FlightRouterState\n) {\n  // A popstate navigation reads data from the local cache. It does not issue\n  // new network requests (unless the cache entries have been evicted). So, we\n  // update the cache to drop the prefetch data for any segment whose dynamic\n  // data was already received. This prevents an unnecessary flash back to PPR\n  // state during a back/forward navigation.\n  //\n  // This function clones the entire cache node tree and sets the `prefetchRsc`\n  // field to `null` to prevent it from being rendered. We can't mutate the node\n  // in place because this is a concurrent data structure.\n\n  const routerStateChildren = routerState[1]\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n  const newParallelRoutes = new Map(oldParallelRoutes)\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    if (oldSegmentMapChild !== undefined) {\n      const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild)\n      if (oldCacheNodeChild !== undefined) {\n        const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(\n          oldCacheNodeChild,\n          routerStateChild\n        )\n        const newSegmentMapChild = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  // Only show prefetched data if the dynamic data is still pending.\n  //\n  // Tehnically, what we're actually checking is whether the dynamic network\n  // response was received. But since it's a streaming response, this does not\n  // mean that all the dynamic data has fully streamed in. It just means that\n  // _some_ of the dynamic data was received. But as a heuristic, we assume that\n  // the rest dynamic data will stream in quickly, so it's still better to skip\n  // the prefetch state.\n  const rsc = oldCacheNode.rsc\n  const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending'\n\n  return {\n    lazyData: null,\n    rsc,\n    head: oldCacheNode.head,\n\n    prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : null,\n    prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n    loading: oldCacheNode.loading,\n\n    // These are the cloned children we computed above\n    parallelRoutes: newParallelRoutes,\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc = Promise<React.ReactNode> & {\n  status: 'pending'\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype FulfilledDeferredRsc = Promise<React.ReactNode> & {\n  status: 'fulfilled'\n  value: React.ReactNode\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype RejectedDeferredRsc = Promise<React.ReactNode> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype DeferredRsc =\n  | PendingDeferredRsc\n  | FulfilledDeferredRsc\n  | RejectedDeferredRsc\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value: any): value is DeferredRsc {\n  return value && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc(): PendingDeferredRsc {\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<React.ReactNode>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: React.ReactNode) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  return pendingRsc\n}\n"],"names":["DEFAULT_SEGMENT_KEY","matchSegment","createRouterCacheKey","updateCacheNodeOnNavigation","oldCacheNode","oldRouterState","newRouterState","prefetchData","prefetchHead","isPrefetchHeadPartial","oldRouterStateChildren","newRouterStateChildren","prefetchDataChildren","oldParallelRoutes","parallelRoutes","prefetchParallelRoutes","Map","patchedRouterStateChildren","taskChildren","needsDynamicRequest","parallelRouteKey","newRouterStateChild","oldRouterStateChild","oldSegmentMapChild","get","prefetchDataChild","newSegmentChild","newSegmentKeyChild","oldSegmentChild","undefined","oldCacheNodeChild","taskChild","spawnReusedTask","createCacheNodeOnNavigation","set","newCacheNodeChild","node","newSegmentMapChild","route","newCacheNode","lazyData","rsc","prefetchRsc","head","loading","patchRouterStateWithNewChildren","children","routerState","possiblyPartialPrefetchHead","spawnPendingTask","routerStateChildren","isPrefetchRscPartial","isLeafSegment","Object","keys","length","cacheNodeChildren","routerStateChild","segmentChild","segmentKeyChild","baseRouterState","newChildren","clone","newTask","createPendingCacheNode","reusedRouterState","listenForDynamicRequest","task","responsePromise","then","flightData","normalizedFlightData","segmentPath","tree","serverRouterState","seedData","dynamicData","dynamicHead","writeDynamicDataIntoPendingTask","abortTask","error","rootTask","i","segment","taskSegment","finishTaskUsingDynamicDataPayload","taskNode","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","size","maybePrefetchRsc","maybePrefetchLoading","createDeferredRsc","cacheNode","taskState","serverState","taskStateChildren","serverStateChildren","dataChildren","taskStateChild","serverStateChild","dataChild","segmentMapChild","taskSegmentChild","taskSegmentKeyChild","cacheNodeChild","abortPendingCacheNode","dynamicSegmentData","isDeferredRsc","resolve","values","reject","updateCacheNodeOnPopstateRestoration","newParallelRoutes","shouldUsePrefetch","status","DEFERRED","Symbol","value","tag","pendingRsc","Promise","res","rej","fulfilledRsc","rejectedRsc","reason"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5358, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5364, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/clear-cache-node-data-for-segment-path.ts"],"sourcesContent":["import type { FlightSegmentPath } from '../../../server/app-render/types'\nimport type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\nimport { createRouterCacheKey } from './create-router-cache-key'\n\n/**\n * This will clear the CacheNode data for a particular segment path. This will cause a lazy-fetch in layout router to fill in new data.\n */\nexport function clearCacheNodeDataForSegmentPath(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightSegmentPath: FlightSegmentPath\n): void {\n  const isLastEntry = flightSegmentPath.length <= 2\n\n  const [parallelRouteKey, segment] = flightSegmentPath\n  const cacheKey = createRouterCacheKey(segment)\n\n  const existingChildSegmentMap =\n    existingCache.parallelRoutes.get(parallelRouteKey)\n\n  let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey)\n\n  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n    childSegmentMap = new Map(existingChildSegmentMap)\n    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n  }\n\n  const existingChildCacheNode = existingChildSegmentMap?.get(cacheKey)\n  let childCacheNode = childSegmentMap.get(cacheKey)\n\n  // In case of last segment start off the fetch at this level and don't copy further down.\n  if (isLastEntry) {\n    if (\n      !childCacheNode ||\n      !childCacheNode.lazyData ||\n      childCacheNode === existingChildCacheNode\n    ) {\n      childSegmentMap.set(cacheKey, {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n      })\n    }\n    return\n  }\n\n  if (!childCacheNode || !existingChildCacheNode) {\n    // Start fetch in the place where the existing cache doesn't have the data yet.\n    if (!childCacheNode) {\n      childSegmentMap.set(cacheKey, {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n      })\n    }\n    return\n  }\n\n  if (childCacheNode === existingChildCacheNode) {\n    childCacheNode = {\n      lazyData: childCacheNode.lazyData,\n      rsc: childCacheNode.rsc,\n      prefetchRsc: childCacheNode.prefetchRsc,\n      head: childCacheNode.head,\n      prefetchHead: childCacheNode.prefetchHead,\n      parallelRoutes: new Map(childCacheNode.parallelRoutes),\n      loading: childCacheNode.loading,\n    } as CacheNode\n    childSegmentMap.set(cacheKey, childCacheNode)\n  }\n\n  return clearCacheNodeDataForSegmentPath(\n    childCacheNode,\n    existingChildCacheNode,\n    getNextFlightSegmentPath(flightSegmentPath)\n  )\n}\n"],"names":["getNextFlightSegmentPath","createRouterCacheKey","clearCacheNodeDataForSegmentPath","newCache","existingCache","flightSegmentPath","isLastEntry","length","parallelRouteKey","segment","cacheKey","existingChildSegmentMap","parallelRoutes","get","childSegmentMap","Map","set","existingChildCacheNode","childCacheNode","lazyData","rsc","prefetchRsc","head","prefetchHead","loading"],"mappings":";;;AAEA,SAASA,wBAAwB,QAAQ,4BAA2B;AACpE,SAASC,oBAAoB,QAAQ,4BAA2B;;;AAKzD,SAASC,iCACdC,QAAmB,EACnBC,aAAwB,EACxBC,iBAAoC;IAEpC,MAAMC,cAAcD,kBAAkBE,MAAM,IAAI;IAEhD,MAAM,CAACC,kBAAkBC,QAAQ,GAAGJ;IACpC,MAAMK,4OAAWT,uBAAAA,EAAqBQ;IAEtC,MAAME,0BACJP,cAAcQ,cAAc,CAACC,GAAG,CAACL;IAEnC,IAAIM,kBAAkBX,SAASS,cAAc,CAACC,GAAG,CAACL;IAElD,IAAI,CAACM,mBAAmBA,oBAAoBH,yBAAyB;QACnEG,kBAAkB,IAAIC,IAAIJ;QAC1BR,SAASS,cAAc,CAACI,GAAG,CAACR,kBAAkBM;IAChD;IAEA,MAAMG,yBAAyBN,2BAAAA,OAAAA,KAAAA,IAAAA,wBAAyBE,GAAG,CAACH;IAC5D,IAAIQ,iBAAiBJ,gBAAgBD,GAAG,CAACH;IAEzC,yFAAyF;IACzF,IAAIJ,aAAa;QACf,IACE,CAACY,kBACD,CAACA,eAAeC,QAAQ,IACxBD,mBAAmBD,wBACnB;YACAH,gBAAgBE,GAAG,CAACN,UAAU;gBAC5BS,UAAU;gBACVC,KAAK;gBACLC,aAAa;gBACbC,MAAM;gBACNC,cAAc;gBACdX,gBAAgB,IAAIG;gBACpBS,SAAS;YACX;QACF;QACA;IACF;IAEA,IAAI,CAACN,kBAAkB,CAACD,wBAAwB;QAC9C,+EAA+E;QAC/E,IAAI,CAACC,gBAAgB;YACnBJ,gBAAgBE,GAAG,CAACN,UAAU;gBAC5BS,UAAU;gBACVC,KAAK;gBACLC,aAAa;gBACbC,MAAM;gBACNC,cAAc;gBACdX,gBAAgB,IAAIG;gBACpBS,SAAS;YACX;QACF;QACA;IACF;IAEA,IAAIN,mBAAmBD,wBAAwB;QAC7CC,iBAAiB;YACfC,UAAUD,eAAeC,QAAQ;YACjCC,KAAKF,eAAeE,GAAG;YACvBC,aAAaH,eAAeG,WAAW;YACvCC,MAAMJ,eAAeI,IAAI;YACzBC,cAAcL,eAAeK,YAAY;YACzCX,gBAAgB,IAAIG,IAAIG,eAAeN,cAAc;YACrDY,SAASN,eAAeM,OAAO;QACjC;QACAV,gBAAgBE,GAAG,CAACN,UAAUQ;IAChC;IAEA,OAAOhB,iCACLgB,gBACAD,+MACAjB,2BAAAA,EAAyBK;AAE7B","ignoreList":[0]}},
    {"offset": {"line": 5427, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5433, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/aliased-prefetch-navigations.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n} from '../../../server/app-render/types'\nimport type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport {\n  addSearchParamsIfPageSegment,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\nimport { createEmptyCacheNode } from '../app-router'\nimport { applyRouterStatePatchToTree } from './apply-router-state-patch-to-tree'\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport { fillCacheWithNewSubTreeDataButOnlyLoading } from './fill-cache-with-new-subtree-data'\nimport { handleMutable } from './handle-mutable'\nimport type { Mutable, ReadonlyReducerState } from './router-reducer-types'\n\n/**\n * This is a stop-gap until per-segment caching is implemented. It leverages the `aliased` flag that is added\n * to prefetch entries when it's determined that the loading state from that entry should be used for this navigation.\n * This function takes the aliased entry and only applies the loading state to the updated cache node.\n * We should remove this once per-segment fetching is implemented as ideally the prefetch cache will contain a\n * more granular segment map and so the router will be able to simply re-use the loading segment for the new navigation.\n */\nexport function handleAliasedPrefetchEntry(\n  state: ReadonlyReducerState,\n  flightData: NormalizedFlightData[],\n  url: URL,\n  mutable: Mutable\n) {\n  let currentTree = state.tree\n  let currentCache = state.cache\n  const href = createHrefFromUrl(url)\n  let applied\n\n  for (const normalizedFlightData of flightData) {\n    // If the segment doesn't have a loading component, we don't need to do anything.\n    if (!hasLoadingComponentInSeedData(normalizedFlightData.seedData)) {\n      continue\n    }\n\n    let treePatch = normalizedFlightData.tree\n    // Segments are keyed by searchParams (e.g. __PAGE__?{\"foo\":\"bar\"}). We might return a less specific, param-less entry,\n    // so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.\n    // We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set\n    treePatch = addSearchParamsToPageSegments(\n      treePatch,\n      Object.fromEntries(url.searchParams)\n    )\n\n    const { seedData, isRootRender, pathToSegment } = normalizedFlightData\n    // TODO-APP: remove ''\n    const flightSegmentPathWithLeadingEmpty = ['', ...pathToSegment]\n\n    // Segments are keyed by searchParams (e.g. __PAGE__?{\"foo\":\"bar\"}). We might return a less specific, param-less entry,\n    // so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.\n    // We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set\n    treePatch = addSearchParamsToPageSegments(\n      treePatch,\n      Object.fromEntries(url.searchParams)\n    )\n\n    let newTree = applyRouterStatePatchToTree(\n      flightSegmentPathWithLeadingEmpty,\n      currentTree,\n      treePatch,\n      href\n    )\n\n    const newCache = createEmptyCacheNode()\n\n    // The prefetch cache entry was aliased -- this signals that we only fill in the cache with the\n    // loading state and not the actual parallel route seed data.\n    if (isRootRender && seedData) {\n      // Fill in the cache with the new loading / rsc data\n      const rsc = seedData[1]\n      const loading = seedData[3]\n      newCache.loading = loading\n      newCache.rsc = rsc\n\n      // Construct a new tree and apply the aliased loading state for each parallel route\n      fillNewTreeWithOnlyLoadingSegments(\n        newCache,\n        currentCache,\n        treePatch,\n        seedData\n      )\n    } else {\n      // Copy rsc for the root node of the cache.\n      newCache.rsc = currentCache.rsc\n      newCache.prefetchRsc = currentCache.prefetchRsc\n      newCache.loading = currentCache.loading\n      newCache.parallelRoutes = new Map(currentCache.parallelRoutes)\n\n      // copy the loading state only into the leaf node (the part that changed)\n      fillCacheWithNewSubTreeDataButOnlyLoading(\n        newCache,\n        currentCache,\n        normalizedFlightData\n      )\n    }\n\n    // If we don't have an updated tree, there's no reason to update the cache, as the tree\n    // dictates what cache nodes to render.\n    if (newTree) {\n      currentTree = newTree\n      currentCache = newCache\n      applied = true\n    }\n  }\n\n  if (!applied) {\n    return false\n  }\n\n  mutable.patchedTree = currentTree\n  mutable.cache = currentCache\n  mutable.canonicalUrl = href\n  mutable.hashFragment = url.hash\n\n  return handleMutable(state, mutable)\n}\n\nfunction hasLoadingComponentInSeedData(seedData: CacheNodeSeedData | null) {\n  if (!seedData) return false\n\n  const parallelRoutes = seedData[2]\n  const loading = seedData[3]\n\n  if (loading) {\n    return true\n  }\n\n  for (const key in parallelRoutes) {\n    if (hasLoadingComponentInSeedData(parallelRoutes[key])) {\n      return true\n    }\n  }\n\n  return false\n}\n\nfunction fillNewTreeWithOnlyLoadingSegments(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  routerState: FlightRouterState,\n  cacheNodeSeedData: CacheNodeSeedData | null\n) {\n  const isLastSegment = Object.keys(routerState[1]).length === 0\n  if (isLastSegment) {\n    return\n  }\n\n  for (const key in routerState[1]) {\n    const parallelRouteState = routerState[1][key]\n    const segmentForParallelRoute = parallelRouteState[0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n\n    const parallelSeedData =\n      cacheNodeSeedData !== null && cacheNodeSeedData[2][key] !== undefined\n        ? cacheNodeSeedData[2][key]\n        : null\n\n    let newCacheNode: CacheNode\n    if (parallelSeedData !== null) {\n      // New data was sent from the server.\n      const rsc = parallelSeedData[1]\n      const loading = parallelSeedData[3]\n      newCacheNode = {\n        lazyData: null,\n        // copy the layout but null the page segment as that's not meant to be used\n        rsc: segmentForParallelRoute.includes(PAGE_SEGMENT_KEY) ? null : rsc,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading,\n      }\n    } else {\n      // No data available for this node. This will trigger a lazy fetch\n      // during render.\n      newCacheNode = {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n      }\n    }\n\n    const existingParallelRoutes = newCache.parallelRoutes.get(key)\n    if (existingParallelRoutes) {\n      existingParallelRoutes.set(cacheKey, newCacheNode)\n    } else {\n      newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]))\n    }\n\n    fillNewTreeWithOnlyLoadingSegments(\n      newCacheNode,\n      existingCache,\n      parallelRouteState,\n      parallelSeedData\n    )\n  }\n}\n\n/**\n * Add search params to the page segments in the flight router state\n * Page segments that are associated with search params have a page segment key\n * followed by a query string. This function will add those params to the page segment.\n * This is useful if we return an aliased prefetch entry (ie, won't have search params)\n * but the canonical router URL has search params.\n */\nexport function addSearchParamsToPageSegments(\n  flightRouterState: FlightRouterState,\n  searchParams: Record<string, string | string[] | undefined>\n): FlightRouterState {\n  const [segment, parallelRoutes, ...rest] = flightRouterState\n\n  // If it's a page segment, modify the segment by adding search params\n  if (segment.includes(PAGE_SEGMENT_KEY)) {\n    const newSegment = addSearchParamsIfPageSegment(segment, searchParams)\n    return [newSegment, parallelRoutes, ...rest]\n  }\n\n  // Otherwise, recurse through the parallel routes and return a new tree\n  const updatedParallelRoutes: { [key: string]: FlightRouterState } = {}\n\n  for (const [key, parallelRoute] of Object.entries(parallelRoutes)) {\n    updatedParallelRoutes[key] = addSearchParamsToPageSegments(\n      parallelRoute,\n      searchParams\n    )\n  }\n\n  return [segment, updatedParallelRoutes, ...rest]\n}\n"],"names":["addSearchParamsIfPageSegment","PAGE_SEGMENT_KEY","createEmptyCacheNode","applyRouterStatePatchToTree","createHrefFromUrl","createRouterCacheKey","fillCacheWithNewSubTreeDataButOnlyLoading","handleMutable","handleAliasedPrefetchEntry","state","flightData","url","mutable","currentTree","tree","currentCache","cache","href","applied","normalizedFlightData","hasLoadingComponentInSeedData","seedData","treePatch","addSearchParamsToPageSegments","Object","fromEntries","searchParams","isRootRender","pathToSegment","flightSegmentPathWithLeadingEmpty","newTree","newCache","rsc","loading","fillNewTreeWithOnlyLoadingSegments","prefetchRsc","parallelRoutes","Map","patchedTree","canonicalUrl","hashFragment","hash","key","existingCache","routerState","cacheNodeSeedData","isLastSegment","keys","length","parallelRouteState","segmentForParallelRoute","cacheKey","parallelSeedData","undefined","newCacheNode","lazyData","includes","head","prefetchHead","existingParallelRoutes","get","set","flightRouterState","segment","rest","newSegment","updatedParallelRoutes","parallelRoute","entries"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5602, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5608, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/navigate-reducer.ts"],"sourcesContent":["import type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../../server/app-render/types'\nimport { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { invalidateCacheBelowFlightSegmentPath } from '../invalidate-cache-below-flight-segmentpath'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { shouldHardNavigate } from '../should-hard-navigate'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport {\n  PrefetchCacheEntryStatus,\n  type Mutable,\n  type NavigateAction,\n  type ReadonlyReducerState,\n  type ReducerState,\n} from '../router-reducer-types'\nimport { handleMutable } from '../handle-mutable'\nimport { applyFlightData } from '../apply-flight-data'\nimport { prefetchQueue } from './prefetch-reducer'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\nimport {\n  listenForDynamicRequest,\n  updateCacheNodeOnNavigation,\n} from '../ppr-navigations'\nimport {\n  getOrCreatePrefetchCacheEntry,\n  prunePrefetchCache,\n} from '../prefetch-cache-utils'\nimport { clearCacheNodeDataForSegmentPath } from '../clear-cache-node-data-for-segment-path'\nimport { handleAliasedPrefetchEntry } from '../aliased-prefetch-navigations'\nimport {\n  navigate as navigateUsingSegmentCache,\n  NavigationResultTag,\n  type NavigationResult,\n} from '../../segment-cache/navigation'\n\nexport function handleExternalUrl(\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  url: string,\n  pendingPush: boolean\n) {\n  mutable.mpaNavigation = true\n  mutable.canonicalUrl = url\n  mutable.pendingPush = pendingPush\n  mutable.scrollableSegments = undefined\n\n  return handleMutable(state, mutable)\n}\n\nfunction generateSegmentsFromPatch(\n  flightRouterPatch: FlightRouterState\n): FlightSegmentPath[] {\n  const segments: FlightSegmentPath[] = []\n  const [segment, parallelRoutes] = flightRouterPatch\n\n  if (Object.keys(parallelRoutes).length === 0) {\n    return [[segment]]\n  }\n\n  for (const [parallelRouteKey, parallelRoute] of Object.entries(\n    parallelRoutes\n  )) {\n    for (const childSegment of generateSegmentsFromPatch(parallelRoute)) {\n      // If the segment is empty, it means we are at the root of the tree\n      if (segment === '') {\n        segments.push([parallelRouteKey, ...childSegment])\n      } else {\n        segments.push([segment, parallelRouteKey, ...childSegment])\n      }\n    }\n  }\n\n  return segments\n}\n\nfunction triggerLazyFetchForLeafSegments(\n  newCache: CacheNode,\n  currentCache: CacheNode,\n  flightSegmentPath: FlightSegmentPath,\n  treePatch: FlightRouterState\n) {\n  let appliedPatch = false\n\n  newCache.rsc = currentCache.rsc\n  newCache.prefetchRsc = currentCache.prefetchRsc\n  newCache.loading = currentCache.loading\n  newCache.parallelRoutes = new Map(currentCache.parallelRoutes)\n\n  const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map(\n    (segment) => [...flightSegmentPath, ...segment]\n  )\n\n  for (const segmentPaths of segmentPathsToFill) {\n    clearCacheNodeDataForSegmentPath(newCache, currentCache, segmentPaths)\n\n    appliedPatch = true\n  }\n\n  return appliedPatch\n}\n\nfunction handleNavigationResult(\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  pendingPush: boolean,\n  result: NavigationResult\n): ReducerState {\n  switch (result.tag) {\n    case NavigationResultTag.MPA: {\n      // Perform an MPA navigation.\n      const newUrl = result.data\n      return handleExternalUrl(state, mutable, newUrl, pendingPush)\n    }\n    case NavigationResultTag.NoOp:\n      // The server responded with no change to the current page.\n      return handleMutable(state, mutable)\n    case NavigationResultTag.Success: {\n      // Received a new result.\n      mutable.cache = result.data.cacheNode\n      mutable.patchedTree = result.data.flightRouterState\n      mutable.canonicalUrl = result.data.canonicalUrl\n      // TODO: Not yet implemented\n      // mutable.scrollableSegments = scrollableSegments\n      // mutable.hashFragment = hash\n      // mutable.shouldScroll = shouldScroll\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Async: {\n      return result.data.then(\n        (asyncResult) =>\n          handleNavigationResult(state, mutable, pendingPush, asyncResult),\n        // If the navigation failed, return the current state.\n        // TODO: This matches the current behavior but we need to do something\n        // better here if the network fails.\n        () => {\n          return state\n        }\n      )\n    }\n    default:\n      const _exhaustiveCheck: never = result\n      return state\n  }\n}\n\nexport function navigateReducer(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll, allowAliasing } =\n    action\n  const mutable: Mutable = {}\n  const { hash } = url\n  const href = createHrefFromUrl(url)\n  const pendingPush = navigateType === 'push'\n  // we want to prune the prefetch cache on every navigation to avoid it growing too large\n  prunePrefetchCache(state.prefetchCache)\n\n  mutable.preserveCustomHistoryState = false\n  mutable.pendingPush = pendingPush\n\n  if (isExternalUrl) {\n    return handleExternalUrl(state, mutable, url.toString(), pendingPush)\n  }\n\n  // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n  // which will trigger an MPA navigation.\n  if (document.getElementById('__next-page-redirect')) {\n    return handleExternalUrl(state, mutable, href, pendingPush)\n  }\n\n  if (process.env.__NEXT_PPR && process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n    // (Very Early Experimental Feature) Segment Cache\n    //\n    // Bypass the normal prefetch cache and use the new per-segment cache\n    // implementation instead. This is only supported if PPR is enabled, too.\n    //\n    // Temporary glue code between the router reducer and the new navigation\n    // implementation. Eventually we'll rewrite the router reducer to a\n    // state machine.\n    // TODO: Currently this always returns an async result, but in the future\n    // it will return a sync result if the navigation was prefetched. Hence\n    // a result type that's more complicated than you might expect.\n    const result = navigateUsingSegmentCache(\n      url,\n      state.cache,\n      state.tree,\n      state.nextUrl\n    )\n    return handleNavigationResult(state, mutable, pendingPush, result)\n  }\n\n  const prefetchValues = getOrCreatePrefetchCacheEntry({\n    url,\n    nextUrl: state.nextUrl,\n    tree: state.tree,\n    prefetchCache: state.prefetchCache,\n    allowAliasing,\n  })\n  const { treeAtTimeOfPrefetch, data } = prefetchValues\n\n  prefetchQueue.bump(data)\n\n  return data.then(\n    ({ flightData, canonicalUrl: canonicalUrlOverride, postponed }) => {\n      let isFirstRead = false\n      // we only want to mark this once\n      if (!prefetchValues.lastUsedTime) {\n        // important: we should only mark the cache node as dirty after we unsuspend from the call above\n        prefetchValues.lastUsedTime = Date.now()\n        isFirstRead = true\n      }\n\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(state, mutable, flightData, pendingPush)\n      }\n\n      const updatedCanonicalUrl = canonicalUrlOverride\n        ? createHrefFromUrl(canonicalUrlOverride)\n        : href\n\n      const onlyHashChange =\n        !!hash &&\n        state.canonicalUrl.split('#', 1)[0] ===\n          updatedCanonicalUrl.split('#', 1)[0]\n\n      // If only the hash has changed, the server hasn't sent us any new data. We can just update\n      // the mutable properties responsible for URL and scroll handling and return early.\n      if (onlyHashChange) {\n        mutable.onlyHashChange = true\n        mutable.canonicalUrl = updatedCanonicalUrl\n        mutable.shouldScroll = shouldScroll\n        mutable.hashFragment = hash\n        mutable.scrollableSegments = []\n        return handleMutable(state, mutable)\n      }\n\n      if (prefetchValues.aliased) {\n        const result = handleAliasedPrefetchEntry(\n          state,\n          flightData,\n          url,\n          mutable\n        )\n\n        // We didn't return new router state because we didn't apply the aliased entry for some reason.\n        // We'll re-invoke the navigation handler but ensure that we don't attempt to use the aliased entry. This\n        // will create an on-demand prefetch entry.\n        if (result === false) {\n          return navigateReducer(state, { ...action, allowAliasing: false })\n        }\n\n        return result\n      }\n\n      let currentTree = state.tree\n      let currentCache = state.cache\n      let scrollableSegments: FlightSegmentPath[] = []\n      for (const normalizedFlightData of flightData) {\n        const {\n          pathToSegment: flightSegmentPath,\n          seedData,\n          head,\n          isHeadPartial,\n          isRootRender,\n        } = normalizedFlightData\n        let treePatch = normalizedFlightData.tree\n\n        // TODO-APP: remove ''\n        const flightSegmentPathWithLeadingEmpty = ['', ...flightSegmentPath]\n\n        // Create new tree based on the flightSegmentPath and router state patch\n        let newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          flightSegmentPathWithLeadingEmpty,\n          currentTree,\n          treePatch,\n          href\n        )\n\n        // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n        // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n        if (newTree === null) {\n          newTree = applyRouterStatePatchToTree(\n            // TODO-APP: remove ''\n            flightSegmentPathWithLeadingEmpty,\n            treeAtTimeOfPrefetch,\n            treePatch,\n            href\n          )\n        }\n\n        if (newTree !== null) {\n          if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n            return handleExternalUrl(state, mutable, href, pendingPush)\n          }\n\n          if (\n            // This is just a paranoid check. When a route is PPRed, the server\n            // will send back a static response that's rendered from\n            // the root. If for some reason it doesn't, we fall back to the\n            // non-PPR implementation.\n            // TODO: We should get rid of the else branch and do all navigations\n            // via updateCacheNodeOnNavigation. The current structure is just\n            // an incremental step.\n            seedData &&\n            isRootRender &&\n            postponed\n          ) {\n            const task = updateCacheNodeOnNavigation(\n              currentCache,\n              currentTree,\n              treePatch,\n              seedData,\n              head,\n              isHeadPartial\n            )\n\n            if (task !== null) {\n              // Use the tree computed by updateCacheNodeOnNavigation instead\n              // of the one computed by applyRouterStatePatchToTree.\n              // TODO: We should remove applyRouterStatePatchToTree\n              // from the PPR path entirely.\n              const patchedRouterState: FlightRouterState = task.route\n              newTree = patchedRouterState\n\n              const newCache = task.node\n              if (newCache !== null) {\n                // We've created a new Cache Node tree that contains a prefetched\n                // version of the next page. This can be rendered instantly.\n                mutable.cache = newCache\n              }\n              if (task.needsDynamicRequest) {\n                // The prefetched tree has dynamic holes in it. We initiate a\n                // dynamic request to fill them in.\n                //\n                // Do not block on the result. We'll immediately render the Cache\n                // Node tree and suspend on the dynamic parts. When the request\n                // comes in, we'll fill in missing data and ping React to\n                // re-render. Unlike the lazy fetching model in the non-PPR\n                // implementation, this is modeled as a single React update +\n                // streaming, rather than multiple top-level updates. (However,\n                // even in the new model, we'll still need to sometimes update the\n                // root multiple times per navigation, like if the server sends us\n                // a different response than we expected. For now, we revert back\n                // to the lazy fetching mechanism in that case.)\n                const dynamicRequest = fetchServerResponse(url, {\n                  flightRouterState: currentTree,\n                  nextUrl: state.nextUrl,\n                })\n\n                listenForDynamicRequest(task, dynamicRequest)\n                // We store the dynamic request on the `lazyData` property of the CacheNode\n                // because we're not going to await the dynamic request here. Since we're not blocking\n                // on the dynamic request, `layout-router` will\n                // task.node.lazyData = dynamicRequest\n              } else {\n                // The prefetched tree does not contain dynamic holes — it's\n                // fully static. We can skip the dynamic request.\n              }\n            } else {\n              // Nothing changed, so reuse the old cache.\n              // TODO: What if the head changed but not any of the segment data?\n              // Is that possible? If so, we should clone the whole tree and\n              // update the head.\n              newTree = treePatch\n            }\n          } else {\n            // The static response does not include any dynamic holes, so\n            // there's no need to do a second request.\n            // TODO: As an incremental step this just reverts back to the\n            // non-PPR implementation. We can simplify this branch further,\n            // given that PPR prefetches are always static and return the whole\n            // tree. Or in the meantime we could factor it out into a\n            // separate function.\n            const cache: CacheNode = createEmptyCacheNode()\n            let applied = false\n\n            if (\n              prefetchValues.status === PrefetchCacheEntryStatus.stale &&\n              !isFirstRead\n            ) {\n              // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n              // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n              // while copying over the `loading` for the segment that contains the page data.\n              // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n\n              // We skip this branch if only the hash fragment has changed, as we don't want to trigger a lazy fetch in that case\n              applied = triggerLazyFetchForLeafSegments(\n                cache,\n                currentCache,\n                flightSegmentPath,\n                treePatch\n              )\n              // since we re-used the stale cache's loading state & refreshed the data,\n              // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n              prefetchValues.lastUsedTime = Date.now()\n            } else {\n              applied = applyFlightData(\n                currentCache,\n                cache,\n                normalizedFlightData,\n                prefetchValues\n              )\n            }\n\n            const hardNavigate = shouldHardNavigate(\n              // TODO-APP: remove ''\n              flightSegmentPathWithLeadingEmpty,\n              currentTree\n            )\n\n            if (hardNavigate) {\n              // Copy rsc for the root node of the cache.\n              cache.rsc = currentCache.rsc\n              cache.prefetchRsc = currentCache.prefetchRsc\n\n              invalidateCacheBelowFlightSegmentPath(\n                cache,\n                currentCache,\n                flightSegmentPath\n              )\n              // Ensure the existing cache value is used when the cache was not invalidated.\n              mutable.cache = cache\n            } else if (applied) {\n              mutable.cache = cache\n              // If we applied the cache, we update the \"current cache\" value so any other\n              // segments in the FlightDataPath will be able to reference the updated cache.\n              currentCache = cache\n            }\n          }\n\n          currentTree = newTree\n\n          for (const subSegment of generateSegmentsFromPatch(treePatch)) {\n            const scrollableSegmentPath = [...flightSegmentPath, ...subSegment]\n            // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n            if (\n              scrollableSegmentPath[scrollableSegmentPath.length - 1] !==\n              DEFAULT_SEGMENT_KEY\n            ) {\n              scrollableSegments.push(scrollableSegmentPath)\n            }\n          }\n        }\n      }\n\n      mutable.patchedTree = currentTree\n      mutable.canonicalUrl = updatedCanonicalUrl\n      mutable.scrollableSegments = scrollableSegments\n      mutable.hashFragment = hash\n      mutable.shouldScroll = shouldScroll\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n"],"names":["fetchServerResponse","createHrefFromUrl","invalidateCacheBelowFlightSegmentPath","applyRouterStatePatchToTree","shouldHardNavigate","isNavigatingToNewRootLayout","PrefetchCacheEntryStatus","handleMutable","applyFlightData","prefetchQueue","createEmptyCacheNode","DEFAULT_SEGMENT_KEY","listenForDynamicRequest","updateCacheNodeOnNavigation","getOrCreatePrefetchCacheEntry","prunePrefetchCache","clearCacheNodeDataForSegmentPath","handleAliasedPrefetchEntry","navigate","navigateUsingSegmentCache","NavigationResultTag","handleExternalUrl","state","mutable","url","pendingPush","mpaNavigation","canonicalUrl","scrollableSegments","undefined","generateSegmentsFromPatch","flightRouterPatch","segments","segment","parallelRoutes","Object","keys","length","parallelRouteKey","parallelRoute","entries","childSegment","push","triggerLazyFetchForLeafSegments","newCache","currentCache","flightSegmentPath","treePatch","appliedPatch","rsc","prefetchRsc","loading","Map","segmentPathsToFill","map","segmentPaths","handleNavigationResult","result","tag","MPA","newUrl","data","NoOp","Success","cache","cacheNode","patchedTree","flightRouterState","Async","then","asyncResult","_exhaustiveCheck","navigateReducer","action","isExternalUrl","navigateType","shouldScroll","allowAliasing","hash","href","prefetchCache","preserveCustomHistoryState","toString","document","getElementById","process","env","__NEXT_PPR","__NEXT_CLIENT_SEGMENT_CACHE","tree","nextUrl","prefetchValues","treeAtTimeOfPrefetch","bump","flightData","canonicalUrlOverride","postponed","isFirstRead","lastUsedTime","Date","now","updatedCanonicalUrl","onlyHashChange","split","hashFragment","aliased","currentTree","normalizedFlightData","pathToSegment","seedData","head","isHeadPartial","isRootRender","flightSegmentPathWithLeadingEmpty","newTree","task","patchedRouterState","route","node","needsDynamicRequest","dynamicRequest","applied","status","stale","hardNavigate","subSegment","scrollableSegmentPath"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5938, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5944, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/server-patch-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  ServerPatchAction,\n  ReducerState,\n  ReadonlyReducerState,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyFlightData } from '../apply-flight-data'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { createEmptyCacheNode } from '../../app-router'\n\nexport function serverPatchReducer(\n  state: ReadonlyReducerState,\n  action: ServerPatchAction\n): ReducerState {\n  const {\n    serverResponse: { flightData, canonicalUrl: canonicalUrlOverride },\n  } = action\n\n  const mutable: Mutable = {}\n\n  mutable.preserveCustomHistoryState = false\n\n  // Handle case when navigating to page in `pages` from `app`\n  if (typeof flightData === 'string') {\n    return handleExternalUrl(\n      state,\n      mutable,\n      flightData,\n      state.pushRef.pendingPush\n    )\n  }\n\n  let currentTree = state.tree\n  let currentCache = state.cache\n\n  for (const normalizedFlightData of flightData) {\n    const { segmentPath: flightSegmentPath, tree: treePatch } =\n      normalizedFlightData\n\n    const newTree = applyRouterStatePatchToTree(\n      // TODO-APP: remove ''\n      ['', ...flightSegmentPath],\n      currentTree,\n      treePatch,\n      state.canonicalUrl\n    )\n\n    // `applyRouterStatePatchToTree` returns `null` when it determined that the server response is not applicable to the current tree.\n    // In other words, the server responded with a tree that doesn't match what the client is currently rendering.\n    // This can happen if the server patch action took longer to resolve than a subsequent navigation which would have changed the tree.\n    // Previously this case triggered an MPA navigation but it should be safe to simply discard the server response rather than forcing\n    // the entire page to reload.\n    if (newTree === null) {\n      return state\n    }\n\n    if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n      return handleExternalUrl(\n        state,\n        mutable,\n        state.canonicalUrl,\n        state.pushRef.pendingPush\n      )\n    }\n\n    const canonicalUrlOverrideHref = canonicalUrlOverride\n      ? createHrefFromUrl(canonicalUrlOverride)\n      : undefined\n\n    if (canonicalUrlOverrideHref) {\n      mutable.canonicalUrl = canonicalUrlOverrideHref\n    }\n\n    const cache: CacheNode = createEmptyCacheNode()\n    applyFlightData(currentCache, cache, normalizedFlightData)\n\n    mutable.patchedTree = newTree\n    mutable.cache = cache\n\n    currentCache = cache\n    currentTree = newTree\n  }\n\n  return handleMutable(state, mutable)\n}\n"],"names":["createHrefFromUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleExternalUrl","applyFlightData","handleMutable","createEmptyCacheNode","serverPatchReducer","state","action","serverResponse","flightData","canonicalUrl","canonicalUrlOverride","mutable","preserveCustomHistoryState","pushRef","pendingPush","currentTree","tree","currentCache","cache","normalizedFlightData","segmentPath","flightSegmentPath","treePatch","newTree","canonicalUrlOverrideHref","undefined","patchedTree"],"mappings":";;;AAAA,SAASA,iBAAiB,QAAQ,0BAAyB;AAC3D,SAASC,2BAA2B,QAAQ,sCAAqC;AACjF,SAASC,2BAA2B,QAAQ,sCAAqC;AAOjF,SAASC,iBAAiB,QAAQ,qBAAoB;AACtD,SAASC,eAAe,QAAQ,uBAAsB;AACtD,SAASC,aAAa,QAAQ,oBAAmB;AAEjD,SAASC,oBAAoB,QAAQ,mBAAkB;;;;;;;;AAEhD,SAASC,mBACdC,KAA2B,EAC3BC,MAAyB;IAEzB,MAAM,EACJC,gBAAgB,EAAEC,UAAU,EAAEC,cAAcC,oBAAoB,EAAE,EACnE,GAAGJ;IAEJ,MAAMK,UAAmB,CAAC;IAE1BA,QAAQC,0BAA0B,GAAG;IAErC,4DAA4D;IAC5D,IAAI,OAAOJ,eAAe,UAAU;QAClC,uOAAOR,oBAAAA,EACLK,OACAM,SACAH,YACAH,MAAMQ,OAAO,CAACC,WAAW;IAE7B;IAEA,IAAIC,cAAcV,MAAMW,IAAI;IAC5B,IAAIC,eAAeZ,MAAMa,KAAK;IAE9B,KAAK,MAAMC,wBAAwBX,WAAY;QAC7C,MAAM,EAAEY,aAAaC,iBAAiB,EAAEL,MAAMM,SAAS,EAAE,GACvDH;QAEF,MAAMI,WAAUzB,6QAAAA,CACd,CACA,qBADsB;YACrB;eAAOuB;SAAkB,EAC1BN,aACAO,WACAjB,MAAMI,YAAY;QAGpB,kIAAkI;QAClI,8GAA8G;QAC9G,oIAAoI;QACpI,mIAAmI;QACnI,6BAA6B;QAC7B,IAAIc,YAAY,MAAM;YACpB,OAAOlB;QACT;QAEA,IAAIN,8QAAAA,EAA4BgB,aAAaQ,UAAU;YACrD,uOAAOvB,oBAAAA,EACLK,OACAM,SACAN,MAAMI,YAAY,EAClBJ,MAAMQ,OAAO,CAACC,WAAW;QAE7B;QAEA,MAAMU,2BAA2Bd,qPAC7Bb,oBAAAA,EAAkBa,wBAClBe;QAEJ,IAAID,0BAA0B;YAC5Bb,QAAQF,YAAY,GAAGe;QACzB;QAEA,MAAMN,iMAAmBf,uBAAAA;gOACzBF,kBAAAA,EAAgBgB,cAAcC,OAAOC;QAErCR,QAAQe,WAAW,GAAGH;QACtBZ,QAAQO,KAAK,GAAGA;QAEhBD,eAAeC;QACfH,cAAcQ;IAChB;IAEA,yNAAOrB,gBAAAA,EAAcG,OAAOM;AAC9B","ignoreList":[0]}},
    {"offset": {"line": 6001, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6007, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/restore-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  RestoreAction,\n} from '../router-reducer-types'\nimport { extractPathFromFlightRouterState } from '../compute-changed-path'\nimport { updateCacheNodeOnPopstateRestoration } from '../ppr-navigations'\n\nexport function restoreReducer(\n  state: ReadonlyReducerState,\n  action: RestoreAction\n): ReducerState {\n  const { url, tree } = action\n  const href = createHrefFromUrl(url)\n  // This action is used to restore the router state from the history state.\n  // However, it's possible that the history state no longer contains the `FlightRouterState`.\n  // We will copy over the internal state on pushState/replaceState events, but if a history entry\n  // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n  // the history state will not contain the `FlightRouterState`.\n  // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n  const treeToRestore = tree || state.tree\n\n  const oldCache = state.cache\n  const newCache = process.env.__NEXT_PPR\n    ? // When PPR is enabled, we update the cache to drop the prefetch\n      // data for any segment whose dynamic data was already received. This\n      // prevents an unnecessary flash back to PPR state during a\n      // back/forward navigation.\n      updateCacheNodeOnPopstateRestoration(oldCache, treeToRestore)\n    : oldCache\n\n  return {\n    // Set canonical url\n    canonicalUrl: href,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // Ensures that the custom history state that was set is preserved when applying this update.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache: newCache,\n    prefetchCache: state.prefetchCache,\n    // Restore provided tree\n    tree: treeToRestore,\n    nextUrl: extractPathFromFlightRouterState(treeToRestore) ?? url.pathname,\n  }\n}\n"],"names":["createHrefFromUrl","extractPathFromFlightRouterState","updateCacheNodeOnPopstateRestoration","restoreReducer","state","action","url","tree","href","treeToRestore","oldCache","cache","newCache","process","env","__NEXT_PPR","canonicalUrl","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","prefetchCache","nextUrl","pathname"],"mappings":";;;AAAA,SAASA,iBAAiB,QAAQ,0BAAyB;AAM3D,SAASC,gCAAgC,QAAQ,0BAAyB;AAC1E,SAASC,oCAAoC,QAAQ,qBAAoB;;;;AAElE,SAASC,eACdC,KAA2B,EAC3BC,MAAqB;IAErB,MAAM,EAAEC,GAAG,EAAEC,IAAI,EAAE,GAAGF;IACtB,MAAMG,qOAAOR,oBAAAA,EAAkBM;IAC/B,0EAA0E;IAC1E,4FAA4F;IAC5F,gGAAgG;IAChG,6FAA6F;IAC7F,8DAA8D;IAC9D,yGAAyG;IACzG,MAAMG,gBAAgBF,QAAQH,MAAMG,IAAI;IAExC,MAAMG,WAAWN,MAAMO,KAAK;IAC5B,MAAMC,WAAWC,QAAQC,GAAG,CAACC,UAAU,GAEnC,oDAIAL,iBAJqE;QAoB9DT;IAdX,OAAO;QACL,oBAAoB;QACpBe,cAAcR;QACdS,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,6FAA6F;YAC7FC,4BAA4B;QAC9B;QACAC,mBAAmBjB,MAAMiB,iBAAiB;QAC1CV,OAAOC;QACPU,eAAelB,MAAMkB,aAAa;QAClC,wBAAwB;QACxBf,MAAME;QACNc,SAAStB,CAAAA,+PAAAA,mCAAAA,EAAiCQ,cAAAA,KAAAA,OAAjCR,oCAAmDK,IAAIkB,QAAQ;IAC1E;AACF","ignoreList":[0]}},
    {"offset": {"line": 6046, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6052, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/handle-segment-mismatch.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../server/app-render/types'\nimport { handleExternalUrl } from './reducers/navigate-reducer'\nimport type {\n  ReadonlyReducerState,\n  ReducerActions,\n} from './router-reducer-types'\n\n/**\n * Handles the case where the client router attempted to patch the tree but, due to a mismatch, the patch failed.\n * This will perform an MPA navigation to return the router to a valid state.\n */\nexport function handleSegmentMismatch(\n  state: ReadonlyReducerState,\n  action: ReducerActions,\n  treePatch: FlightRouterState\n) {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(\n      'Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.\\n\\n' +\n        'Reason: Segment mismatch\\n' +\n        `Last Action: ${action.type}\\n\\n` +\n        `Current Tree: ${JSON.stringify(state.tree)}\\n\\n` +\n        `Tree Patch Payload: ${JSON.stringify(treePatch)}`\n    )\n  }\n\n  return handleExternalUrl(state, {}, state.canonicalUrl, true)\n}\n"],"names":["handleExternalUrl","handleSegmentMismatch","state","action","treePatch","process","env","NODE_ENV","console","warn","type","JSON","stringify","tree","canonicalUrl"],"mappings":";;;AACA,SAASA,iBAAiB,QAAQ,8BAA6B;;AAUxD,SAASC,sBACdC,KAA2B,EAC3BC,MAAsB,EACtBC,SAA4B;IAE5B,IAAIC,QAAQC,GAAG,CAACC,QAAQ,KAAK,WAAe;QAC1CC,QAAQC,IAAI,CACV,sJACE,+BACA,CAAC,kBAAeN,OAAOO,IAAI,GAAC,MAAI,IAChC,CAAC,mBAAgBC,KAAKC,SAAS,CAACV,MAAMW,IAAI,IAAE,MAAI,IAChD,CAAC,yBAAsBF,KAAKC,SAAS,CAACR,UAAW;IAEvD;IAEA,uOAAOJ,oBAAAA,EAAkBE,OAAO,CAAC,GAAGA,MAAMY,YAAY,EAAE;AAC1D","ignoreList":[0]}},
    {"offset": {"line": 6063, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6069, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../../server/app-render/types'\nimport { isInterceptionRouteAppPath } from '../../../../server/lib/interception-routes'\n\nexport function hasInterceptionRouteInCurrentTree([\n  segment,\n  parallelRoutes,\n]: FlightRouterState): boolean {\n  // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n  if (Array.isArray(segment) && (segment[2] === 'di' || segment[2] === 'ci')) {\n    return true\n  }\n\n  // If segment is not an array, apply the existing string-based check\n  if (typeof segment === 'string' && isInterceptionRouteAppPath(segment)) {\n    return true\n  }\n\n  // Iterate through parallelRoutes if they exist\n  if (parallelRoutes) {\n    for (const key in parallelRoutes) {\n      if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n"],"names":["isInterceptionRouteAppPath","hasInterceptionRouteInCurrentTree","segment","parallelRoutes","Array","isArray","key"],"mappings":";;;AACA,SAASA,0BAA0B,QAAQ,6CAA4C;;AAEhF,SAASC,kCAAkC,KAG9B;IAH8B,IAAA,CAChDC,SACAC,eACkB,GAH8B;IAIhD,wGAAwG;IACxG,IAAIC,MAAMC,OAAO,CAACH,YAAaA,CAAAA,OAAO,CAAC,EAAE,KAAK,QAAQA,OAAO,CAAC,EAAE,KAAK,IAAG,GAAI;QAC1E,OAAO;IACT;IAEA,oEAAoE;IACpE,IAAI,OAAOA,YAAY,aAAYF,uNAAAA,EAA2BE,UAAU;QACtE,OAAO;IACT;IAEA,+CAA+C;IAC/C,IAAIC,gBAAgB;QAClB,IAAK,MAAMG,OAAOH,eAAgB;YAChC,IAAIF,kCAAkCE,cAAc,CAACG,IAAI,GAAG;gBAC1D,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 6094, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6100, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/refresh-reducer.ts"],"sourcesContent":["import { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n  RefreshAction,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\n\nexport function refreshReducer(\n  state: ReadonlyReducerState,\n  action: RefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  cache.lazyData = fetchServerResponse(new URL(href, origin), {\n    flightRouterState: [\n      currentTree[0],\n      currentTree[1],\n      currentTree[2],\n      'refetch',\n    ],\n    nextUrl: includeNextUrl ? state.nextUrl : null,\n  })\n\n  return cache.lazyData.then(\n    async ({ flightData, canonicalUrl: canonicalUrlOverride }) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      for (const normalizedFlightData of flightData) {\n        const {\n          tree: treePatch,\n          seedData: cacheNodeSeedData,\n          head,\n          isRootRender,\n        } = normalizedFlightData\n\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        const canonicalUrlOverrideHref = canonicalUrlOverride\n          ? createHrefFromUrl(canonicalUrlOverride)\n          : undefined\n\n        if (canonicalUrlOverride) {\n          mutable.canonicalUrl = canonicalUrlOverrideHref\n        }\n\n        // Handles case where prefetch only returns the router tree patch without rendered components.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[1]\n          const loading = cacheNodeSeedData[3]\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          cache.loading = loading\n          fillLazyItemsTillLeafWithHead(\n            cache,\n            // Existing cache is not passed in as `router.refresh()` has to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head\n          )\n          mutable.prefetchCache = new Map()\n        }\n\n        await refreshInactiveParallelSegments({\n          state,\n          updatedTree: newTree,\n          updatedCache: cache,\n          includeNextUrl,\n          canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n        })\n\n        mutable.cache = cache\n        mutable.patchedTree = newTree\n\n        currentTree = newTree\n      }\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n"],"names":["fetchServerResponse","createHrefFromUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleExternalUrl","handleMutable","fillLazyItemsTillLeafWithHead","createEmptyCacheNode","handleSegmentMismatch","hasInterceptionRouteInCurrentTree","refreshInactiveParallelSegments","refreshReducer","state","action","origin","mutable","href","canonicalUrl","currentTree","tree","preserveCustomHistoryState","cache","includeNextUrl","lazyData","URL","flightRouterState","nextUrl","then","flightData","canonicalUrlOverride","pushRef","pendingPush","normalizedFlightData","treePatch","seedData","cacheNodeSeedData","head","isRootRender","console","log","newTree","canonicalUrlOverrideHref","undefined","rsc","loading","prefetchRsc","prefetchCache","Map","updatedTree","updatedCache","patchedTree"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6198, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6204, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/hmr-refresh-reducer.ts"],"sourcesContent":["import { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  HmrRefreshAction,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport { applyFlightData } from '../apply-flight-data'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\n\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(\n  state: ReadonlyReducerState,\n  action: HmrRefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  cache.lazyData = fetchServerResponse(new URL(href, origin), {\n    flightRouterState: [state.tree[0], state.tree[1], state.tree[2], 'refetch'],\n    nextUrl: includeNextUrl ? state.nextUrl : null,\n    isHmrRefresh: true,\n  })\n\n  return cache.lazyData.then(\n    ({ flightData, canonicalUrl: canonicalUrlOverride }) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      let currentTree = state.tree\n      let currentCache = state.cache\n\n      for (const normalizedFlightData of flightData) {\n        const { tree: treePatch, isRootRender } = normalizedFlightData\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        const canonicalUrlOverrideHref = canonicalUrlOverride\n          ? createHrefFromUrl(canonicalUrlOverride)\n          : undefined\n\n        if (canonicalUrlOverride) {\n          mutable.canonicalUrl = canonicalUrlOverrideHref\n        }\n        const applied = applyFlightData(\n          currentCache,\n          cache,\n          normalizedFlightData\n        )\n\n        if (applied) {\n          mutable.cache = cache\n          currentCache = cache\n        }\n\n        mutable.patchedTree = newTree\n        mutable.canonicalUrl = href\n\n        currentTree = newTree\n      }\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n\nfunction hmrRefreshReducerNoop(\n  state: ReadonlyReducerState,\n  _action: HmrRefreshAction\n): ReducerState {\n  return state\n}\n\nexport const hmrRefreshReducer =\n  process.env.NODE_ENV === 'production'\n    ? hmrRefreshReducerNoop\n    : hmrRefreshReducerImpl\n"],"names":["fetchServerResponse","createHrefFromUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleExternalUrl","handleMutable","applyFlightData","createEmptyCacheNode","handleSegmentMismatch","hasInterceptionRouteInCurrentTree","hmrRefreshReducerImpl","state","action","origin","mutable","href","canonicalUrl","preserveCustomHistoryState","cache","includeNextUrl","tree","lazyData","URL","flightRouterState","nextUrl","isHmrRefresh","then","flightData","canonicalUrlOverride","pushRef","pendingPush","currentTree","currentCache","normalizedFlightData","treePatch","isRootRender","console","log","newTree","canonicalUrlOverrideHref","undefined","applied","patchedTree","hmrRefreshReducerNoop","_action","hmrRefreshReducer","process","env","NODE_ENV"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6295, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6301, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/server-reference-info.ts"],"sourcesContent":["export interface ServerReferenceInfo {\n  type: 'server-action' | 'use-cache'\n  usedArgs: [boolean, boolean, boolean, boolean, boolean, boolean]\n  hasRestArgs: boolean\n}\n\n/**\n * Extracts info about the server reference for the given server reference ID by\n * parsing the first byte of the hex-encoded ID.\n *\n * ```\n * Bit positions: [7]      [6] [5] [4] [3] [2] [1]  [0]\n * Bits:          typeBit  argMask                  restArgs\n * ```\n *\n * If the `typeBit` is `1` the server reference represents a `\"use cache\"`\n * function, otherwise a server action.\n *\n * The `argMask` encodes whether the function uses the argument at the\n * respective position.\n *\n * The `restArgs` bit indicates whether the function uses a rest parameter. It's\n * also set to 1 if the function has more than 6 args.\n *\n * @param id hex-encoded server reference ID\n */\nexport function extractInfoFromServerReferenceId(\n  id: string\n): ServerReferenceInfo {\n  const infoByte = parseInt(id.slice(0, 2), 16)\n  const typeBit = (infoByte >> 7) & 0x1\n  const argMask = (infoByte >> 1) & 0x3f\n  const restArgs = infoByte & 0x1\n  const usedArgs = Array(6)\n\n  for (let index = 0; index < 6; index++) {\n    const bitPosition = 5 - index\n    const bit = (argMask >> bitPosition) & 0x1\n    usedArgs[index] = bit === 1\n  }\n\n  return {\n    type: typeBit === 1 ? 'use-cache' : 'server-action',\n    usedArgs: usedArgs as [\n      boolean,\n      boolean,\n      boolean,\n      boolean,\n      boolean,\n      boolean,\n    ],\n    hasRestArgs: restArgs === 1,\n  }\n}\n\n/**\n * Creates a sparse array containing only the used arguments based on the\n * provided action info.\n */\nexport function omitUnusedArgs(\n  args: unknown[],\n  info: ServerReferenceInfo\n): unknown[] {\n  const filteredArgs = new Array(args.length)\n\n  for (let index = 0; index < args.length; index++) {\n    if (\n      (index < 6 && info.usedArgs[index]) ||\n      // This assumes that the server reference info byte has the restArgs bit\n      // set to 1 if there are more than 6 args.\n      (index >= 6 && info.hasRestArgs)\n    ) {\n      filteredArgs[index] = args[index]\n    }\n  }\n\n  return filteredArgs\n}\n"],"names":["extractInfoFromServerReferenceId","id","infoByte","parseInt","slice","typeBit","argMask","restArgs","usedArgs","Array","index","bitPosition","bit","type","hasRestArgs","omitUnusedArgs","args","info","filteredArgs","length"],"mappings":"AAMA;;;;;;;;;;;;;;;;;;;CAmBC,GACD;;;;AAAO,SAASA,iCACdC,EAAU;IAEV,MAAMC,WAAWC,SAASF,GAAGG,KAAK,CAAC,GAAG,IAAI;IAC1C,MAAMC,UAAWH,YAAY,IAAK;IAClC,MAAMI,UAAWJ,YAAY,IAAK;IAClC,MAAMK,WAAWL,WAAW;IAC5B,MAAMM,WAAWC,MAAM;IAEvB,IAAK,IAAIC,QAAQ,GAAGA,QAAQ,GAAGA,QAAS;QACtC,MAAMC,cAAc,IAAID;QACxB,MAAME,MAAON,WAAWK,cAAe;QACvCH,QAAQ,CAACE,MAAM,GAAGE,QAAQ;IAC5B;IAEA,OAAO;QACLC,MAAMR,YAAY,IAAI,cAAc;QACpCG,UAAUA;QAQVM,aAAaP,aAAa;IAC5B;AACF;AAMO,SAASQ,eACdC,IAAe,EACfC,IAAyB;IAEzB,MAAMC,eAAe,IAAIT,MAAMO,KAAKG,MAAM;IAE1C,IAAK,IAAIT,QAAQ,GAAGA,QAAQM,KAAKG,MAAM,EAAET,QAAS;QAChD,IACGA,QAAQ,KAAKO,KAAKT,QAAQ,CAACE,MAAM,IAClC,wEAAwE;QACxE,0CAA0C;QACzCA,SAAS,KAAKO,KAAKH,WAAW,EAC/B;YACAI,YAAY,CAACR,MAAM,GAAGM,IAAI,CAACN,MAAM;QACnC;IACF;IAEA,OAAOQ;AACT","ignoreList":[0]}},
    {"offset": {"line": 6352, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6358, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/reducers/server-action-reducer.ts"],"sourcesContent":["import type {\n  ActionFlightResponse,\n  ActionResult,\n} from '../../../../server/app-render/types'\nimport { callServer } from '../../../app-call-server'\nimport { findSourceMapURL } from '../../../app-find-source-map-url'\nimport {\n  ACTION_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n} from '../../app-router-headers'\n\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromFetch } from 'react-server-dom-webpack/client'\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { encodeReply } from 'react-server-dom-webpack/client'\nconst { createFromFetch, createTemporaryReferenceSet, encodeReply } = (\n  !!process.env.NEXT_RUNTIME\n    ? // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client.edge')\n    : // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client')\n) as typeof import('react-server-dom-webpack/client')\n\nimport {\n  PrefetchKind,\n  type ReadonlyReducerState,\n  type ReducerState,\n  type ServerActionAction,\n  type ServerActionMutable,\n} from '../router-reducer-types'\nimport { assignLocation } from '../../../assign-location'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { handleMutable } from '../handle-mutable'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\nimport {\n  normalizeFlightData,\n  type NormalizedFlightData,\n} from '../../../flight-data-helpers'\nimport { getRedirectError } from '../../redirect'\nimport { RedirectType } from '../../redirect-error'\nimport { createSeededPrefetchCacheEntry } from '../prefetch-cache-utils'\nimport { removeBasePath } from '../../../remove-base-path'\nimport { hasBasePath } from '../../../has-base-path'\nimport {\n  extractInfoFromServerReferenceId,\n  omitUnusedArgs,\n} from './server-reference-info'\n\ntype FetchServerActionResult = {\n  redirectLocation: URL | undefined\n  redirectType: RedirectType | undefined\n  actionResult?: ActionResult\n  actionFlightData?: NormalizedFlightData[] | string\n  isPrerender: boolean\n  revalidatedParts: {\n    tag: boolean\n    cookie: boolean\n    paths: string[]\n  }\n}\n\nasync function fetchServerAction(\n  state: ReadonlyReducerState,\n  nextUrl: ReadonlyReducerState['nextUrl'],\n  { actionId, actionArgs }: ServerActionAction\n): Promise<FetchServerActionResult> {\n  const temporaryReferences = createTemporaryReferenceSet()\n  const info = extractInfoFromServerReferenceId(actionId)\n\n  // TODO: Currently, we're only omitting unused args for the experimental \"use\n  // cache\" functions. Once the server reference info byte feature is stable, we\n  // should apply this to server actions as well.\n  const usedArgs =\n    info.type === 'use-cache' ? omitUnusedArgs(actionArgs, info) : actionArgs\n\n  const body = await encodeReply(usedArgs, { temporaryReferences })\n\n  const res = await fetch('', {\n    method: 'POST',\n    headers: {\n      Accept: RSC_CONTENT_TYPE_HEADER,\n      [ACTION_HEADER]: actionId,\n      [NEXT_ROUTER_STATE_TREE_HEADER]: encodeURIComponent(\n        JSON.stringify(state.tree)\n      ),\n      ...(process.env.NEXT_DEPLOYMENT_ID\n        ? {\n            'x-deployment-id': process.env.NEXT_DEPLOYMENT_ID,\n          }\n        : {}),\n      ...(nextUrl\n        ? {\n            [NEXT_URL]: nextUrl,\n          }\n        : {}),\n    },\n    body,\n  })\n\n  const redirectHeader = res.headers.get('x-action-redirect')\n  const [location, _redirectType] = redirectHeader?.split(';') || []\n  let redirectType: RedirectType | undefined\n  switch (_redirectType) {\n    case 'push':\n      redirectType = RedirectType.push\n      break\n    case 'replace':\n      redirectType = RedirectType.replace\n      break\n    default:\n      redirectType = undefined\n  }\n\n  const isPrerender = !!res.headers.get(NEXT_IS_PRERENDER_HEADER)\n  let revalidatedParts: FetchServerActionResult['revalidatedParts']\n  try {\n    const revalidatedHeader = JSON.parse(\n      res.headers.get('x-action-revalidated') || '[[],0,0]'\n    )\n    revalidatedParts = {\n      paths: revalidatedHeader[0] || [],\n      tag: !!revalidatedHeader[1],\n      cookie: revalidatedHeader[2],\n    }\n  } catch (e) {\n    revalidatedParts = {\n      paths: [],\n      tag: false,\n      cookie: false,\n    }\n  }\n\n  const redirectLocation = location\n    ? assignLocation(\n        location,\n        new URL(state.canonicalUrl, window.location.href)\n      )\n    : undefined\n\n  const contentType = res.headers.get('content-type')\n\n  if (contentType?.startsWith(RSC_CONTENT_TYPE_HEADER)) {\n    const response: ActionFlightResponse = await createFromFetch(\n      Promise.resolve(res),\n      { callServer, findSourceMapURL, temporaryReferences }\n    )\n\n    if (location) {\n      // if it was a redirection, then result is just a regular RSC payload\n      return {\n        actionFlightData: normalizeFlightData(response.f),\n        redirectLocation,\n        redirectType,\n        revalidatedParts,\n        isPrerender,\n      }\n    }\n\n    return {\n      actionResult: response.a,\n      actionFlightData: normalizeFlightData(response.f),\n      redirectLocation,\n      redirectType,\n      revalidatedParts,\n      isPrerender,\n    }\n  }\n\n  // Handle invalid server action responses\n  if (res.status >= 400) {\n    // The server can respond with a text/plain error message, but we'll fallback to something generic\n    // if there isn't one.\n    const error =\n      contentType === 'text/plain'\n        ? await res.text()\n        : 'An unexpected response was received from the server.'\n\n    throw new Error(error)\n  }\n\n  return {\n    redirectLocation,\n    redirectType,\n    revalidatedParts,\n    isPrerender,\n  }\n}\n\n/*\n * This reducer is responsible for calling the server action and processing any side-effects from the server action.\n * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.\n */\nexport function serverActionReducer(\n  state: ReadonlyReducerState,\n  action: ServerActionAction\n): ReducerState {\n  const { resolve, reject } = action\n  const mutable: ServerActionMutable = {}\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n  // If the route has been intercepted, the action should be as well.\n  // Otherwise the server action might be intercepted with the wrong action id\n  // (ie, one that corresponds with the intercepted route)\n  const nextUrl =\n    state.nextUrl && hasInterceptionRouteInCurrentTree(state.tree)\n      ? state.nextUrl\n      : null\n\n  return fetchServerAction(state, nextUrl, action).then(\n    async ({\n      actionResult,\n      actionFlightData: flightData,\n      redirectLocation,\n      redirectType,\n      isPrerender,\n      revalidatedParts,\n    }) => {\n      let redirectHref: string | undefined\n\n      // honor the redirect type instead of defaulting to push in case of server actions.\n      if (redirectLocation) {\n        if (redirectType === RedirectType.replace) {\n          state.pushRef.pendingPush = false\n          mutable.pendingPush = false\n        } else {\n          state.pushRef.pendingPush = true\n          mutable.pendingPush = true\n        }\n\n        redirectHref = createHrefFromUrl(redirectLocation, false)\n        mutable.canonicalUrl = redirectHref\n      }\n\n      if (!flightData) {\n        resolve(actionResult)\n\n        // If there is a redirect but no flight data we need to do a mpaNavigation.\n        if (redirectLocation) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectLocation.href,\n            state.pushRef.pendingPush\n          )\n        }\n        return state\n      }\n\n      if (typeof flightData === 'string') {\n        // Handle case when navigating to page in `pages` from `app`\n        resolve(actionResult)\n\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      const actionRevalidated =\n        revalidatedParts.paths.length > 0 ||\n        revalidatedParts.tag ||\n        revalidatedParts.cookie\n\n      for (const normalizedFlightData of flightData) {\n        const {\n          tree: treePatch,\n          seedData: cacheNodeSeedData,\n          head,\n          isRootRender,\n        } = normalizedFlightData\n\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('SERVER ACTION APPLY FAILED')\n          resolve(actionResult)\n\n          return state\n        }\n\n        // Given the path can only have two items the items are only the router state and rsc for the root.\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          redirectHref ? redirectHref : state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          resolve(actionResult)\n\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          resolve(actionResult)\n\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectHref || state.canonicalUrl,\n            state.pushRef.pendingPush\n          )\n        }\n\n        // The server sent back RSC data for the server action, so we need to apply it to the cache.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[1]\n          const cache: CacheNode = createEmptyCacheNode()\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          cache.loading = cacheNodeSeedData[3]\n          fillLazyItemsTillLeafWithHead(\n            cache,\n            // Existing cache is not passed in as server actions have to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head\n          )\n\n          mutable.cache = cache\n          mutable.prefetchCache = new Map()\n\n          if (actionRevalidated) {\n            await refreshInactiveParallelSegments({\n              state,\n              updatedTree: newTree,\n              updatedCache: cache,\n              includeNextUrl: Boolean(nextUrl),\n              canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n            })\n          }\n        }\n\n        mutable.patchedTree = newTree\n        currentTree = newTree\n      }\n\n      if (redirectLocation && redirectHref) {\n        // Because the RedirectBoundary will trigger a navigation, we need to seed the prefetch cache\n        // with the FlightData that we got from the server action for the target page, so that it's\n        // available when the page is navigated to and doesn't need to be re-fetched.\n        // We only do this if the server action didn't revalidate any data, as in that case the\n        // client cache will be cleared and the data will be re-fetched anyway.\n        if (!actionRevalidated) {\n          createSeededPrefetchCacheEntry({\n            url: redirectLocation,\n            data: {\n              flightData,\n              canonicalUrl: undefined,\n              couldBeIntercepted: false,\n              prerendered: false,\n              postponed: false,\n              // TODO: We should be able to set this if the server action\n              // returned a fully static response.\n              staleTime: -1,\n            },\n            tree: state.tree,\n            prefetchCache: state.prefetchCache,\n            nextUrl: state.nextUrl,\n            kind: isPrerender ? PrefetchKind.FULL : PrefetchKind.AUTO,\n          })\n          mutable.prefetchCache = state.prefetchCache\n        }\n\n        // If the action triggered a redirect, the action promise promise will be rejected with\n        // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n        // action result to resolve the promise with. This will effectively reset the state of\n        // the component that called the action as the error boundary will remount the tree.\n        // The status code doesn't matter here as the action handler will have already sent\n        // a response with the correct status code.\n        reject(\n          getRedirectError(\n            hasBasePath(redirectHref)\n              ? removeBasePath(redirectHref)\n              : redirectHref,\n            redirectType || RedirectType.push\n          )\n        )\n      } else {\n        resolve(actionResult)\n      }\n\n      return handleMutable(state, mutable)\n    },\n    (e: any) => {\n      // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n      reject(e)\n\n      return state\n    }\n  )\n}\n"],"names":["callServer","findSourceMapURL","ACTION_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","RSC_CONTENT_TYPE_HEADER","createFromFetch","createTemporaryReferenceSet","encodeReply","process","env","NEXT_RUNTIME","require","PrefetchKind","assignLocation","createHrefFromUrl","handleExternalUrl","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","handleMutable","fillLazyItemsTillLeafWithHead","createEmptyCacheNode","hasInterceptionRouteInCurrentTree","handleSegmentMismatch","refreshInactiveParallelSegments","normalizeFlightData","getRedirectError","RedirectType","createSeededPrefetchCacheEntry","removeBasePath","hasBasePath","extractInfoFromServerReferenceId","omitUnusedArgs","fetchServerAction","state","nextUrl","actionId","actionArgs","temporaryReferences","info","usedArgs","type","body","res","fetch","method","headers","Accept","encodeURIComponent","JSON","stringify","tree","NEXT_DEPLOYMENT_ID","redirectHeader","get","location","_redirectType","split","redirectType","push","replace","undefined","isPrerender","revalidatedParts","revalidatedHeader","parse","paths","tag","cookie","e","redirectLocation","URL","canonicalUrl","window","href","contentType","startsWith","response","Promise","resolve","actionFlightData","f","actionResult","a","status","error","text","Error","serverActionReducer","action","reject","mutable","currentTree","preserveCustomHistoryState","then","flightData","redirectHref","pushRef","pendingPush","actionRevalidated","length","normalizedFlightData","treePatch","seedData","cacheNodeSeedData","head","isRootRender","console","log","newTree","rsc","cache","prefetchRsc","loading","prefetchCache","Map","updatedTree","updatedCache","includeNextUrl","Boolean","patchedTree","url","data","couldBeIntercepted","prerendered","postponed","staleTime","kind","FULL","AUTO"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6629, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 6635, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/next/dist/src/client/components/router-reducer/router-reducer.ts"],"sourcesContent":["import {\n  ACTION_NAVIGATE,\n  ACTION_SERVER_PATCH,\n  ACTION_RESTORE,\n  ACTION_REFRESH,\n  ACTION_PREFETCH,\n  ACTION_HMR_REFRESH,\n  ACTION_SERVER_ACTION,\n} from './router-reducer-types'\nimport type {\n  ReducerActions,\n  ReducerState,\n  ReadonlyReducerState,\n} from './router-reducer-types'\nimport { navigateReducer } from './reducers/navigate-reducer'\nimport { serverPatchReducer } from './reducers/server-patch-reducer'\nimport { restoreReducer } from './reducers/restore-reducer'\nimport { refreshReducer } from './reducers/refresh-reducer'\nimport { prefetchReducer } from './reducers/prefetch-reducer'\nimport { hmrRefreshReducer } from './reducers/hmr-refresh-reducer'\nimport { serverActionReducer } from './reducers/server-action-reducer'\n\n/**\n * Reducer that handles the app-router state updates.\n */\nfunction clientReducer(\n  state: ReadonlyReducerState,\n  action: ReducerActions\n): ReducerState {\n  switch (action.type) {\n    case ACTION_NAVIGATE: {\n      return navigateReducer(state, action)\n    }\n    case ACTION_SERVER_PATCH: {\n      return serverPatchReducer(state, action)\n    }\n    case ACTION_RESTORE: {\n      return restoreReducer(state, action)\n    }\n    case ACTION_REFRESH: {\n      return refreshReducer(state, action)\n    }\n    case ACTION_HMR_REFRESH: {\n      return hmrRefreshReducer(state, action)\n    }\n    case ACTION_PREFETCH: {\n      return prefetchReducer(state, action)\n    }\n    case ACTION_SERVER_ACTION: {\n      return serverActionReducer(state, action)\n    }\n    // This case should never be hit as dispatch is strongly typed.\n    default:\n      throw new Error('Unknown action')\n  }\n}\n\nfunction serverReducer(\n  state: ReadonlyReducerState,\n  _action: ReducerActions\n): ReducerState {\n  return state\n}\n\n// we don't run the client reducer on the server, so we use a noop function for better tree shaking\nexport const reducer =\n  typeof window === 'undefined' ? serverReducer : clientReducer\n"],"names":["ACTION_NAVIGATE","ACTION_SERVER_PATCH","ACTION_RESTORE","ACTION_REFRESH","ACTION_PREFETCH","ACTION_HMR_REFRESH","ACTION_SERVER_ACTION","navigateReducer","serverPatchReducer","restoreReducer","refreshReducer","prefetchReducer","hmrRefreshReducer","serverActionReducer","clientReducer","state","action","type","Error","serverReducer","_action","reducer","window"],"mappings":";;;AAAA,SACEA,eAAe,EACfC,mBAAmB,EACnBC,cAAc,EACdC,cAAc,EACdC,eAAe,EACfC,kBAAkB,EAClBC,oBAAoB,QACf,yBAAwB;AAM/B,SAASC,eAAe,QAAQ,8BAA6B;AAC7D,SAASC,kBAAkB,QAAQ,kCAAiC;AACpE,SAASC,cAAc,QAAQ,6BAA4B;AAC3D,SAASC,cAAc,QAAQ,6BAA4B;AAC3D,SAASC,eAAe,QAAQ,8BAA6B;AAC7D,SAASC,iBAAiB,QAAQ,iCAAgC;AAClE,SAASC,mBAAmB,QAAQ,mCAAkC;;;;;;;;;AAEtE;;CAEC,GACD,SAASC,cACPC,KAA2B,EAC3BC,MAAsB;IAEtB,OAAQA,OAAOC,IAAI;QACjB,4NAAKjB,kBAAAA;YAAiB;gBACpB,QAAOO,iPAAAA,EAAgBQ,OAAOC;YAChC;QACA,4NAAKf,sBAAAA;YAAqB;gBACxB,8OAAOO,qBAAAA,EAAmBO,OAAOC;YACnC;QACA,4NAAKd,iBAAAA;YAAgB;gBACnB,sOAAOO,iBAAAA,EAAeM,OAAOC;YAC/B;QACA,4NAAKb,iBAAAA;YAAgB;gBACnB,sOAAOO,iBAAAA,EAAeK,OAAOC;YAC/B;QACA,KAAKX,4OAAAA;YAAoB;gBACvB,6OAAOO,oBAAAA,EAAkBG,OAAOC;YAClC;QACA,4NAAKZ,kBAAAA;YAAiB;gBACpB,uOAAOO,kBAAAA,EAAgBI,OAAOC;YAChC;QACA,4NAAKV,uBAAAA;YAAsB;gBACzB,QAAOO,6PAAAA,EAAoBE,OAAOC;YACpC;QACA,+DAA+D;QAC/D;YACE,MAAM,IAAIE,MAAM;IACpB;AACF;AAEA,SAASC,cACPJ,KAA2B,EAC3BK,OAAuB;IAEvB,OAAOL;AACT;AAGO,MAAMM,UACX,OAAOC,WAAW,cAAcH,gBAAgBL,cAAa","ignoreList":[0]}},
    {"offset": {"line": 6695, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}